<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Mr. X ‚Äì Live Analyse</title>

  <link rel="manifest" href="/manifest.webmanifest">
  <link rel="apple-touch-icon" href="/icons/apple-touch-icon.png">
  <meta name="theme-color" content="#000000">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <link rel="stylesheet" href="/app.css">

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Leaflet Draw -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.css">
  <script src="https://unpkg.com/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>

  <!-- Turf -->
  <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>

  <style>
    :root{
      --bg0:#05080f; --bg1:#070c16;
      --panel:rgba(17,24,39,.72);
      --panel2:rgba(20,28,46,.78);
      --border:rgba(255,255,255,.10);
      --text:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.62);
      --accent:#3ee38c; --accent2:#2fce7a;
      --danger:#ff4d6d;
      --shadow:0 18px 60px rgba(0,0,0,.55);
      --radius:18px;
      --chip: rgba(255,255,255,0.06);
      --ok: rgba(62,227,140,0.14);
      --warn: rgba(255,210,77,0.12);
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:'Segoe UI', Tahoma, sans-serif;
      color:var(--text);
      background: radial-gradient(1200px 700px at 20% 10%, rgba(62,227,140,0.10), transparent 55%),
                  radial-gradient(900px 600px at 85% 20%, rgba(79,140,255,0.08), transparent 55%),
                  linear-gradient(180deg, var(--bg0), var(--bg1));
      min-height:100vh;
    }
    .shell{width:min(1200px, 100%); margin:0 auto; padding:18px 14px 28px;}
    .topbar{display:flex; align-items:center; justify-content:space-between; gap:12px; margin-bottom:12px;}
    .title{display:flex; flex-direction:column; gap:2px;}
    .title h1{margin:0; font-size:1.35rem; letter-spacing:.2px;}
    .title .sub{color:var(--muted); font-size:.92rem}
    .actions{display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end; align-items:center;}

    .btn{
      appearance:none;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.06);
      color:var(--text);
      padding:10px 12px;
      border-radius:14px;
      cursor:pointer;
      font-weight:800;
      transition:transform .12s ease, filter .2s ease;
      user-select:none;
      display:inline-flex;
      align-items:center;
      gap:8px;
      white-space:nowrap;
      text-decoration:none;
    }
    .btn:hover{filter:brightness(1.04)}
    .btn:active{transform:translateY(1px)}
    .btn.primary{
      background: linear-gradient(180deg, var(--accent), var(--accent2));
      color:#03130a;
      box-shadow:0 10px 24px rgba(62,227,140,0.14);
      border-color: rgba(62,227,140,.22);
    }
    .btn.danger{
      background: rgba(255,77,109,0.12);
      border-color: rgba(255,77,109,0.28);
      color:#ffd3db;
    }
    .btn.icon{width:42px; justify-content:center; padding:10px 0;}
    .btn.small{padding:7px 10px; border-radius:12px; font-weight:900;}

    .grid{display:grid; grid-template-columns: 1.35fr .65fr; gap:12px;}
    .card{
      background:var(--panel);
      border:1px solid var(--border);
      backdrop-filter: blur(14px);
      -webkit-backdrop-filter: blur(14px);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      overflow:hidden;
    }
    .cardHeader{
      padding:12px 14px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      border-bottom:1px solid rgba(255,255,255,.08);
      background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.00));
    }
    .cardHeader .h{font-weight:900; letter-spacing:.2px;}
    .cardHeader .hint{color:var(--muted); font-size:.9rem;}
    #map{height: 70vh; min-height: 440px; width:100%;}
    .side{display:flex; flex-direction:column; min-height: 70vh;}
    .sideBody{padding:12px 14px 14px; display:flex; flex-direction:column; gap:10px;}

    .row{display:flex; gap:8px; flex-wrap:wrap; align-items:center;}
    .field{display:flex; flex-direction:column; gap:6px; flex:1; min-width:180px;}
    .field label{font-size:.82rem; color:var(--muted);}
    .field input, .field select, .field textarea{
      font-size:16px; /* iOS: kein Zoom */
      width:100%;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.06);
      color:var(--text);
      outline:none;
      resize: vertical;
    }
    .chip{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      background:var(--chip);
      color:var(--text);
      font-weight:800;
      font-size:.9rem;
      user-select:none;
    }
    .chip small{color:var(--muted); font-weight:700}

    .list{
      display:flex;
      flex-direction:column;
      gap:8px;
      max-height: 210px;
      overflow:auto;
      padding-right:4px;
    }
    .ping{
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.05);
      border-radius:14px;
      padding:10px 12px;
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .ping .top{display:flex; align-items:center; justify-content:space-between; gap:10px; font-weight:900;}
    .ping .meta{color:var(--muted); font-size:.88rem; line-height:1.25; word-break:break-word;}
    .ping .stats{
      display:flex; flex-wrap:wrap; gap:6px;
      font-size:.88rem;
      color:rgba(255,255,255,.80);
    }
    .tag{
      display:inline-flex; gap:6px; align-items:center;
      padding:5px 8px; border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.04);
    }

    .aiBox{
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.05);
      border-radius:14px;
      padding:10px 12px;
      white-space:pre-wrap;
      line-height:1.35;
      min-height: 170px;
      max-height: 280px;
      overflow:auto;
    }
    .aiBox.muted{color:var(--muted);}
    .sep{height:1px; background:rgba(255,255,255,.08); margin:2px 0;}
    .notice{
      border:1px solid rgba(255,255,255,.10);
      background:rgba(255,255,255,.04);
      border-radius:14px;
      padding:10px 12px;
      color:var(--muted);
      line-height:1.35;
      font-size:.9rem;
    }
    .notice.ok{background:var(--ok); color:rgba(255,255,255,.88); border-color:rgba(62,227,140,.20);}
    .notice.warn{background:var(--warn); color:rgba(255,255,255,.88); border-color:rgba(255,210,77,.18);}

    /* Modal */
    .modalBackdrop{
      position:fixed; inset:0;
      background: rgba(0,0,0,.55);
      display:none;
      align-items:center;
      justify-content:center;
      padding:14px;
      z-index:9999;
    }
    .modalBackdrop.show{display:flex;}
    .modal{
      width:min(560px, 100%);
      background: rgba(10,14,26,.96);
      border:1px solid rgba(255,255,255,.12);
      border-radius:18px;
      box-shadow:0 24px 80px rgba(0,0,0,.65);
      overflow:hidden;
    }
    .modalHead{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      padding:12px 14px;
      border-bottom:1px solid rgba(255,255,255,.10);
    }
    .modalHead .h{font-weight:900;}
    .modalBody{padding:12px 14px 14px; display:flex; flex-direction:column; gap:10px;}
    .modalActions{display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end;}

    @media (max-width: 980px){
      .grid{grid-template-columns: 1fr;}
      #map{height: 54vh; min-height: 360px;}
      .side{min-height:auto;}
    }
  </style></head>
<body>
  <div class="shell">
    <div class="topbar">
      <div class="title">
        <h1>Mr. X ‚Äì Standort-Analyse</h1>
        <div class="sub">Polygon = Spielfeld ¬∑ Pings importieren/eingeben ¬∑ √úbersicht + KI</div>
      </div>
      <div class="actions">
        <a class="btn" href="/home">‚¨ÖÔ∏è Home</a>
        <button class="btn danger" id="btnReset" title="Alles l√∂schen">üß® Reset</button>
      </div>
    </div>

    <div class="grid">
      <!-- MAP -->
      <div class="card">
        <div class="cardHeader">
          <div>
            <div class="h">Karte</div>
            <div class="hint">1) Spielfeld einzeichnen ¬∑ 2) Ping einf√ºgen</div>
          </div>
          <div class="row">
            <span class="chip" id="chipArea"><small>Spielfeld:</small> <span id="areaState">‚Äî</span></span>
            <span class="chip"><small>Pings:</small> <span id="pingCount">0</span></span>
          </div>
        </div>
        <div id="map"></div>
      </div>

      <!-- SIDE -->
      <div class="card side">
        <div class="cardHeader">
          <div>
            <div class="h">√úbersicht</div>
            <div class="hint">Du kannst Pings reinschreiben</div>
          </div>
          <button class="btn icon" id="btnCollapse" title="Ein-/Ausklappen">‚ñæ</button>
        </div>

        <div class="sideBody" id="sideBody">
          <div class="row">
            <div class="field">
              <label>Spielname (lokal)</label>
              <input id="gameName" placeholder="z.B. Abendrunde">
            </div>
          </div>

          <div class="row">
            <div class="field">
              <label>Spielfeld-Vorlagen</label>
              <select id="fieldSelect"></select>
            </div>
            <button class="btn" id="btnFieldInsert" title="Vorlage als aktuelles Spielfeld setzen">üì• Einf√ºgen</button>
            <button class="btn" id="btnFieldSave" title="Aktuelles Spielfeld als Vorlage speichern">üíæ Speichern</button>
            <button class="btn danger" id="btnFieldDelete" title="Ausgew√§hlte Vorlage l√∂schen">üóëÔ∏è</button>
          </div>


          <div class="row">
            <div class="field">
              <label>Geh-Tempo</label>
              <select id="walkMode">
                <option value="1.4">Normal (‚âà 5 km/h)</option>
                <option value="2.0">Schnell (‚âà 7.2 km/h)</option>
                <option value="2.8">Sprint (‚âà 10 km/h)</option>
              </select>
            </div>
            <div class="field">
              <label>Zeitraum pro Runde</label>
              <select id="windowSec">
                <option value="300">5 Minuten</option>
                <option value="240">4 Minuten</option>
                <option value="360">6 Minuten</option>
              </select>
            </div>
          </div>

          <div class="notice ok" id="overviewBox">
            <b>√úbersicht:</b> F√ºge mindestens 2 Pings ein f√ºr Richtung/Geschwindigkeit.
          </div>

          <div class="row">
            <button class="btn primary" id="btnInsert">‚ûï Ping einf√ºgen</button>
            <button class="btn" id="btnAnalyze">ü§ñ Analysieren</button>
          </div>
<div class="sep"></div>

          <div class="row" style="justify-content:space-between; align-items:flex-end">
            <div style="display:flex; flex-direction:column; gap:2px">
              <div style="font-weight:900">Pings</div>
              <div style="color:var(--muted); font-size:.9rem">Neuester oben ¬∑ mit Stats</div>
            </div>
          </div>

          <div class="list" id="pingList"></div>

          <div class="sep"></div>

          <div style="font-weight:900">KI-Analyse</div>
          <div class="aiBox muted" id="aiOut">Noch keine Analyse. Zeichne ein Spielfeld und f√ºge 1‚Äì2 Pings ein.</div>
        </div>
      </div>
    </div>
  </div>

  <!-- MODAL: Paste / Manual Entry -->
  <div class="modalBackdrop" id="modalBackdrop">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
      <div class="modalHead">
        <div class="h" id="modalTitle">Ping einf√ºgen</div>
        <button class="btn icon" id="btnModalClose" title="Schlie√üen">‚úï</button>
      </div>
      <div class="modalBody">
        <div class="notice">
          Du kannst hier alles reinwerfen:<br>
          ‚Ä¢ <b>lat,lng</b> (z.B. <code>49.0123, 8.4045</code>)<br>
          ‚Ä¢ Google Maps Link (enth√§lt oft <code>@lat,lng</code>)<br>
          ‚Ä¢ WhatsApp Text mit Koordinaten<br><br>
          Optional: Zeit (wenn du‚Äôs wei√üt). Wenn leer ‚Üí jetzt.
        </div>

        <div class="field">
          <label>Ping Text / Link</label>
          <textarea id="pasteText" rows="4" placeholder="Hier rein‚Ä¶"></textarea>
        </div>

        <div class="row">
          <div class="field">
            <label>Zeit (optional)</label>
            <input id="pasteTime" type="datetime-local">
          </div>
          <div class="field">
            <label>Genauigkeit (optional, Meter)</label>
            <input id="pasteAcc" type="number" min="0" step="1" placeholder="z.B. 15">
          </div>
        </div>

        <div class="modalActions">
          <button class="btn" id="btnPasteParse">‚úÖ √úbernehmen</button>
          <button class="btn danger" id="btnPasteCancel">Abbrechen</button>
        </div>
      </div>
    </div>
  </div>

<script>
/* =========================
   AUTH (wie bei Home)
========================= */
async function enforceAuth() {
  try {
    const r = await fetch("/api/me", { credentials: "include" });
    if (r.status === 401) location.href = "/login?returnTo=" + encodeURIComponent(location.pathname + location.search);
  } catch (_) {
    location.href = "/login?returnTo=" + encodeURIComponent(location.pathname + location.search);
  }
}
window.addEventListener("pageshow", (e) => { if (e.persisted) enforceAuth(); });
enforceAuth();

/* =========================
   STATE (localStorage MVP)
========================= */
const LS_KEY = "mrx_state_v2";
const LS_FIELDS_KEY = "mrx_fields_v1";
function loadState(){
  try{
    const s = JSON.parse(localStorage.getItem(LS_KEY) || "null");
    if (!s) return { name:"", area:null, pings:[] };
    if (!Array.isArray(s.pings)) s.pings = [];
    return s;
  }catch{ return { name:"", area:null, pings:[] }; }
}
function saveState(){ localStorage.setItem(LS_KEY, JSON.stringify(state)); }

let fields = loadFields();

function loadFields(){
  try{
    const a = JSON.parse(localStorage.getItem(LS_FIELDS_KEY) || "[]");
    return Array.isArray(a) ? a : [];
  }catch{ return []; }
}
function saveFields(){
  localStorage.setItem(LS_FIELDS_KEY, JSON.stringify(fields));
}
function uid(){
  return "f_" + Math.random().toString(16).slice(2) + Date.now().toString(16);
}
function refreshFieldSelect(){
  const sel = document.getElementById("fieldSelect");
  if (!sel) return;
  const cur = sel.value;
  sel.innerHTML = "";
  const opt0 = document.createElement("option");
  opt0.value = "";
  opt0.textContent = "‚Äî Vorlage w√§hlen ‚Äî";
  sel.appendChild(opt0);

  fields
    .slice()
    .sort((a,b)=>(b.createdAt||0)-(a.createdAt||0))
    .forEach(f=>{
      const o=document.createElement("option");
      o.value=f.id;
      o.textContent = f.name || ("Spielfeld " + f.id.slice(-4));
      sel.appendChild(o);
    });

  // restore selection if possible
  if (cur) sel.value = cur;
}

let state = loadState();

/* =========================
   UI refs
========================= */
const elAreaState = document.getElementById("areaState");
const elPingCount = document.getElementById("pingCount");
const elPingList  = document.getElementById("pingList");
const elAiOut     = document.getElementById("aiOut");
const elGameName  = document.getElementById("gameName");
const elWalkMode  = document.getElementById("walkMode");
const elWindowSec = document.getElementById("windowSec");
const chipArea    = document.getElementById("chipArea");
const elOverview  = document.getElementById("overviewBox");

/* Modal refs */
const modalBackdrop = document.getElementById("modalBackdrop");
const pasteText = document.getElementById("pasteText");
const pasteTime = document.getElementById("pasteTime");
const pasteAcc  = document.getElementById("pasteAcc");

/* =========================
   MAP
========================= */
const map = L.map("map", { zoomControl: true }).setView([49.013, 8.404], 13);
L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
  maxZoom: 19,
  attribution: "¬© OpenStreetMap"
}).addTo(map);

const drawnItems = new L.FeatureGroup();
map.addLayer(drawnItems);

const pingLayer = new L.LayerGroup().addTo(map);
const candidateLayer = new L.LayerGroup().addTo(map);
let reachableCircle = null;

const drawControl = new L.Control.Draw({
  draw: {
    polyline:false, rectangle:false, circle:false, circlemarker:false, marker:false,
    polygon:{ allowIntersection:false, showArea:true }
  },
  edit:{ featureGroup: drawnItems, remove:true }
});
map.addControl(drawControl);

map.on(L.Draw.Event.CREATED, function (e) {
  drawnItems.clearLayers();
  const layer = e.layer;
  drawnItems.addLayer(layer);
  state.area = layer.toGeoJSON();
  saveState();
  renderAll(true);
});
map.on("draw:edited", () => {
  const layers = drawnItems.getLayers();
  if (layers.length) {
    state.area = layers[0].toGeoJSON();
    saveState();
    renderAll(true);
  }
});
map.on("draw:deleted", () => {
  state.area = null;
  saveState();
  renderAll(true);
});

/* =========================
   HELPERS
========================= */
function fmt(n, d=5){ if (!Number.isFinite(n)) return "‚Äî"; return Number(n).toFixed(d); }
function nowMs(){ return Date.now(); }
function timeLabel(ms){
  const d = new Date(ms);
  return d.toLocaleString("de-DE", { hour:"2-digit", minute:"2-digit", second:"2-digit" });
}
function haversineMeters(a, b){
  const R=6371000, toRad=x=>x*Math.PI/180;
  const dLat=toRad(b.lat-a.lat), dLng=toRad(b.lng-a.lng);
  const lat1=toRad(a.lat), lat2=toRad(b.lat);
  const s=Math.sin(dLat/2)**2 + Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLng/2)**2;
  return 2*R*Math.asin(Math.min(1, Math.sqrt(s)));
}
function bearingDeg(a, b){
  const toRad=x=>x*Math.PI/180, toDeg=x=>x*180/Math.PI;
  const lat1=toRad(a.lat), lat2=toRad(b.lat);
  const dLng=toRad(b.lng-a.lng);
  const y=Math.sin(dLng)*Math.cos(lat2);
  const x=Math.cos(lat1)*Math.sin(lat2) - Math.sin(lat1)*Math.cos(lat2)*Math.cos(dLng);
  return (toDeg(Math.atan2(y,x))+360)%360;
}
function destPoint(a, brngDeg, distM){
  const R=6371000, toRad=x=>x*Math.PI/180, toDeg=x=>x*180/Math.PI;
  const brng=toRad(brngDeg);
  const lat1=toRad(a.lat), lon1=toRad(a.lng);
  const dr=distM/R;
  const lat2=Math.asin(Math.sin(lat1)*Math.cos(dr) + Math.cos(lat1)*Math.sin(dr)*Math.cos(brng));
  const lon2=lon1 + Math.atan2(Math.sin(brng)*Math.sin(dr)*Math.cos(lat1), Math.cos(dr)-Math.sin(lat1)*Math.sin(lat2));
  return { lat: toDeg(lat2), lng: ((toDeg(lon2)+540)%360)-180 };
}
function areaPolygon(){
  if (!state.area) return null;
  try{
    return state.area.type==="Feature" ? state.area : { type:"Feature", geometry: state.area, properties:{} };
  }catch{ return null; }
}
function pointInArea(lat,lng){
  const poly=areaPolygon();
  if (!poly) return true;
  try{ return turf.booleanPointInPolygon(turf.point([lng,lat]), poly); }catch{ return true; }
}
function clampIntoArea(from,p){
  if (pointInArea(p.lat,p.lng)) return p;
  const brng=bearingDeg(from,p);
  let dist=haversineMeters(from,p);
  for (let i=0;i<12;i++){
    dist*=0.75;
    const cand=destPoint(from, brng, dist);
    if (pointInArea(cand.lat,cand.lng)) return cand;
  }
  return p;
}

/* =========================
   OVERVIEW (Stats)
========================= */
function computeOverview(){
  const pings=[...state.pings].sort((a,b)=>a.t-b.t);
  if (pings.length===0){
    return { text:"√úbersicht: Noch keine Pings.", cls:"ok" };
  }
  if (pings.length===1){
    return { text:"√úbersicht: 1 Ping vorhanden. Setze/importiere einen zweiten f√ºr Richtung & Tempo.", cls:"ok" };
  }
  const last=pings[pings.length-1], prev=pings[pings.length-2];
  const d=haversineMeters(prev,last);
  const dt=Math.max(1, (last.t-prev.t)/1000);
  const spd=d/dt;
  const br=bearingDeg(prev,last);

  const windowS=Number(elWindowSec.value||"300");
  const predictDist=spd*windowS;

  let warn="";
  if (dt < 60) warn=" (Achtung: sehr kurzer Zeitabstand)";
  if (dt > 900) warn=" (Achtung: gro√üer Zeitabstand)";
  return {
    text:`√úbersicht: Letzte Strecke ‚âà ${Math.round(d)}m in ‚âà ${Math.round(dt)}s ‚Üí ‚âà ${spd.toFixed(2)} m/s ¬∑ Richtung ‚âà ${Math.round(br)}¬∞ ¬∑ In ${windowS/60}min bei gleichem Tempo ‚âà ${Math.round(predictDist)}m.${warn}`,
    cls: warn ? "warn" : "ok"
  };
}

/* =========================
   RENDER
========================= */
function renderAreaOnMap(){
  drawnItems.clearLayers();
  if (!state.area) return;
  const layer=L.geoJSON(state.area);
  layer.eachLayer(l => drawnItems.addLayer(l));
  const b=layer.getBounds();
  if (b.isValid()) map.fitBounds(b.pad(0.12));
}
function renderPingsOnMap(){
  pingLayer.clearLayers();
  const pings=[...state.pings].sort((a,b)=>b.t-a.t);
  pings.forEach((p,idx)=>{
    const isLatest=idx===0;
    const m=L.circleMarker([p.lat,p.lng], { radius:isLatest?9:7, weight:2, opacity:1, fillOpacity:0.85 }).addTo(pingLayer);
    m.bindPopup(`<b>${isLatest?"Letzter Ping":"Ping"}</b><br>${timeLabel(p.t)}<br>${fmt(p.lat)} , ${fmt(p.lng)}${p.accuracy?`<br>¬± ${Math.round(p.accuracy)}m`:``}`);
  });
}
function renderPingList(){
  const pings=[...state.pings].sort((a,b)=>b.t-a.t);
  elPingList.innerHTML="";
  if (!pings.length){
    elPingList.innerHTML=`<div class="ping"><div class="meta">Noch keine Pings.</div></div>`;
    return;
  }
  // For stats per row: compare to next (older) ping
  const chron=[...state.pings].sort((a,b)=>a.t-b.t);
  const idxByT=new Map(chron.map((p,i)=>[p.t,i]));

  pings.forEach((p,idx)=>{
    const div=document.createElement("div");
    div.className="ping";

    const iChron=idxByT.get(p.t);
    let statsHtml=`<span class="tag">üìå <b>Ping</b></span>`;
    if (iChron!=null && iChron>0){
      const prev=chron[iChron-1];
      const d=haversineMeters(prev,p);
      const dt=Math.max(1,(p.t-prev.t)/1000);
      const spd=d/dt;
      const br=bearingDeg(prev,p);
      statsHtml += ` <span class="tag">üìè ${Math.round(d)}m</span>`;
      statsHtml += ` <span class="tag">‚è±Ô∏è ${Math.round(dt)}s</span>`;
      statsHtml += ` <span class="tag">üèÉ ${spd.toFixed(2)} m/s</span>`;
      statsHtml += ` <span class="tag">üß≠ ${Math.round(br)}¬∞</span>`;
    } else {
      statsHtml += ` <span class="tag">‚Äî erster Ping</span>`;
    }

    div.innerHTML=`
      <div class="top">
        <span>${idx===0?"üìå Letzter Ping":"üìç Ping"}</span>
        <span class="row" style="gap:6px">
          <button class="btn small" data-zoom="${p.t}">üîé</button>
          <button class="btn small danger" data-del="${p.t}">L√∂schen</button>
        </span>
      </div>
      <div class="meta">${timeLabel(p.t)} ¬∑ ${fmt(p.lat)} , ${fmt(p.lng)}${p.accuracy?` ¬∑ ¬± ${Math.round(p.accuracy)}m`:``}</div>
      <div class="stats">${statsHtml}</div>
    `;
    elPingList.appendChild(div);
  });

  elPingList.querySelectorAll("[data-del]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const t=Number(btn.getAttribute("data-del"));
      state.pings=state.pings.filter(x=>x.t!==t);
      saveState();
      renderAll(true);
    });
  });
  elPingList.querySelectorAll("[data-zoom]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const t=Number(btn.getAttribute("data-zoom"));
      const p=state.pings.find(x=>x.t===t);
      if (!p) return;
      map.setView([p.lat,p.lng], Math.max(map.getZoom(), 16), { animate:true });
    });
  });
}
function renderChips(){
  elPingCount.textContent=String(state.pings.length);
  if (state.area){ elAreaState.textContent="gesetzt"; chipArea.style.borderColor="rgba(62,227,140,0.35)"; }
  else { elAreaState.textContent="fehlt"; chipArea.style.borderColor="rgba(255,255,255,0.10)"; }
}
function renderOverview(){
  const o=computeOverview();
  elOverview.classList.remove("ok","warn");
  elOverview.classList.add(o.cls);
  elOverview.innerHTML = `<b>√úbersicht:</b> ${o.text.replace(/^√úbersicht:\s*/,"")}`;
}
function clearOverlays(){
  candidateLayer.clearLayers();
  if (reachableCircle){ map.removeLayer(reachableCircle); reachableCircle=null; }
}
function renderAll(redrawOverlay=false){
  elGameName.value=state.name||"";
  renderChips();
  renderAreaOnMap();
  renderPingsOnMap();
  renderPingList();
  renderOverview();
  if (redrawOverlay) drawPredictionOverlay();
}

/* =========================
   CANDIDATES / OVERLAY
========================= */
function computeCandidates(){
  const pings=[...state.pings].sort((a,b)=>a.t-b.t);
  const last=pings[pings.length-1];
  const prev=pings.length>=2 ? pings[pings.length-2] : null;

  const speedSet=Number(elWalkMode.value||"1.4");
  const windowS=Number(elWindowSec.value||"300");
  const distMax=Math.max(30, speedSet*windowS);

  let baseBearing=0;
  let effSpeed=null;
  if (prev){
    baseBearing=bearingDeg(prev,last);
    const d=haversineMeters(prev,last);
    const dt=Math.max(1,(last.t-prev.t)/1000);
    effSpeed=d/dt;
  }
  const angles = prev ? [0, 25, -25, 55, -55, 180] : [0, 45, -45, 90, -90, 180];
  let dBase = prev && effSpeed ? Math.min(distMax, Math.max(60, effSpeed * windowS * 0.95)) : distMax * 0.85;

  const out=[];
  for (let i=0;i<angles.length;i++){
    const brng=(baseBearing+angles[i]+360)%360;
    let p=destPoint(last, brng, dBase);
    p=clampIntoArea(last,p);
    if (!pointInArea(p.lat,p.lng) && state.area) continue;
    out.push({ ...p, note: prev ? `Richtung ${Math.round(brng)}¬∞` : `Richtung ${Math.round(brng)}¬∞ (ohne Verlauf)` });
  }
  let tries=0;
  while(out.length<6 && tries<12){
    tries++; dBase*=0.78;
    const brng=(baseBearing + (tries%2?35:-35) + 360)%360;
    let p=destPoint(last, brng, dBase);
    p=clampIntoArea(last,p);
    if (pointInArea(p.lat,p.lng)) out.push({ ...p, note:`Kurzstrecke ${Math.round(dBase)}m` });
  }
  return out.slice(0,6);
}
function drawPredictionOverlay(){
  clearOverlays();
  const last=state.pings.length ? [...state.pings].sort((a,b)=>b.t-a.t)[0] : null;
  if (!last) return;

  const speedSet=Number(elWalkMode.value||"1.4");
  const windowS=Number(elWindowSec.value||"300");
  const radius=Math.max(30, speedSet*windowS);

  reachableCircle=L.circle([last.lat,last.lng], { radius, weight:2, opacity:1, fillOpacity:0.10 }).addTo(map);

  const candidates=computeCandidates();
  candidates.forEach((c,i)=>{
    const m=L.circleMarker([c.lat,c.lng], { radius:7, weight:2, fillOpacity:0.85 }).addTo(candidateLayer);
    m.bindTooltip(String(i+1), { permanent:true, direction:"center" });
    m.bindPopup(`<b>Kandidat ${i+1}</b><br>${fmt(c.lat)} , ${fmt(c.lng)}<br><small>${c.note||""}</small>`);
  });
}

/* =========================
   AI
========================= */
function buildAiPrompt(){
  const poly=areaPolygon();
  const pings=[...state.pings].sort((a,b)=>a.t-b.t);
  const candidates=computeCandidates();

  const last=pings[pings.length-1]||null;
  const prev=pings.length>=2 ? pings[pings.length-2] : null;

  let d=null, brng=null, dt=null, spd=null;
  if (last && prev){
    d=haversineMeters(prev,last);
    dt=Math.max(1,(last.t-prev.t)/1000);
    brng=bearingDeg(prev,last);
    spd=d/dt;
  }

  const speedSet=Number(elWalkMode.value||"1.4");
  const windowS=Number(elWindowSec.value||"300");

  return [
`Du bist ein Helfer f√ºr ein Live-Spiel "Mr. X".`,
`Aufgabe: Bewerte die wahrscheinlichsten n√§chsten Positionen in den n√§chsten ${windowS/60} Minuten.`,
`Nutze nur Pings + Kandidaten + Spielfeld-Polygon. Keine Fantasie-Orte.`,
`Gib am Ende:`,
`1) Top-6 Kandidaten (1..6) mit 1 Satz Begr√ºndung je Punkt.`,
`2) Profil (max 6 Bulletpoints).`,
`3) Verfolger-Taktik (max 5 Bulletpoints).`,
``,
`Daten:`,
`- Spielname: ${state.name||"(ohne)"}`,
`- Geh-Tempo gesetzt: ${speedSet} m/s`,
`- Spielfeld-Polygon: ${poly ? JSON.stringify(poly.geometry) : "nicht gesetzt"}`,
`- Pings: ${JSON.stringify(pings.map(p=>({t:p.t, lat:p.lat, lng:p.lng, acc:p.accuracy||null})))}`,
(prev && last ? `- Letzte Bewegung: Distanz‚âà${Math.round(d)}m, Zeit‚âà${Math.round(dt)}s, Speed‚âà${spd.toFixed(2)}m/s, Bearing‚âà${Math.round(brng)}¬∞` : `- Letzte Bewegung: nur 1 Ping`),
`- Kandidaten (zu ranken): ${JSON.stringify(candidates.map((c,i)=>({k:i+1, lat:c.lat, lng:c.lng, note:c.note||""})))}`,
``,
`Wichtig: Wenn Polygon fehlt, sag kurz "Polygon fehlt".`,
  ].join("\n");
}

async function runAi(){
  if (!state.pings.length){
    elAiOut.classList.add("muted");
    elAiOut.textContent="Keine Pings vorhanden.";
    return;
  }
  elAiOut.classList.remove("muted");
  elAiOut.textContent="Analysiere‚Ä¶";
  const prompt=buildAiPrompt();

  try{
    const r=await fetch("/api/ai", {
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      credentials:"include",
      body: JSON.stringify({ prompt })
    });
    const j=await r.json().catch(()=>null);
    if (!r.ok || !j){
      elAiOut.textContent="KI-Fehler: " + (j?.error ? JSON.stringify(j) : `HTTP ${r.status}`);
      return;
    }
    elAiOut.textContent = j.text || "(leer)";
  }catch(e){
    elAiOut.textContent="KI-Fehler: " + String(e?.message || e);
  }
}

/* =========================
   PING ACTIONS
========================= */
function addPing(lat,lng,accuracy,tOverrideMs){
  if (!Number.isFinite(lat) || !Number.isFinite(lng)) return;

  if (state.area && !pointInArea(lat,lng)){
    alert("Ping liegt au√üerhalb des Spielfelds (Polygon).");
    return;
  }

  const t = Number.isFinite(tOverrideMs) ? tOverrideMs : nowMs();

  state.pings.push({
    t,
    lat:Number(lat),
    lng:Number(lng),
    accuracy:Number.isFinite(accuracy) ? Number(accuracy) : null
  });

  // dedupe same timestamp (keep latest)
  const seen=new Set();
  state.pings = state.pings
    .sort((a,b)=>a.t-b.t)
    .filter(p=>{
      if (seen.has(p.t)) return false;
      seen.add(p.t); return true;
    })
    .slice(-80);

  saveState();
  renderAll(true);
}

let manualMode=false;


document.getElementById("btnAnalyze").addEventListener("click", ()=>{
  drawPredictionOverlay();
  runAi();
});


/* =========================
   SPIELFELD-VORLAGEN
========================= */
function bindFieldUI(){
  const sel = document.getElementById("fieldSelect");
  const btnSave = document.getElementById("btnFieldSave");
  const btnInsert = document.getElementById("btnFieldInsert");
  const btnDelete = document.getElementById("btnFieldDelete");
  if (!sel || !btnSave || !btnInsert || !btnDelete) return;

  refreshFieldSelect();

  btnSave.addEventListener("click", ()=>{
    if (!state.area){
      alert("Kein Spielfeld (Polygon) gesetzt. Zeichne zuerst eins in die Karte.");
      return;
    }
    const defName = (state.name||"").trim() || "Spielfeld";
    const name = (prompt("Name f√ºr dieses Spielfeld:", defName) || "").trim();
    if (!name) return;

    fields.push({
      id: uid(),
      name,
      area: state.area,
      createdAt: Date.now()
    });
    saveFields();
    refreshFieldSelect();
    alert("Spielfeld gespeichert ‚úÖ");
  });

  btnInsert.addEventListener("click", ()=>{
    const id = sel.value || "";
    if (!id){ alert("Bitte erst eine Vorlage ausw√§hlen."); return; }
    const f = fields.find(x=>x.id===id);
    if (!f){ alert("Vorlage nicht gefunden."); return; }
    state.area = f.area;
    saveState();
    renderAll(true);
    alert("Spielfeld eingef√ºgt ‚úÖ");
  });

  btnDelete.addEventListener("click", ()=>{
    const id = sel.value || "";
    if (!id){ alert("Bitte erst eine Vorlage ausw√§hlen."); return; }
    const f = fields.find(x=>x.id===id);
    if (!f) return;
    const ok = confirm(`Vorlage "${f.name}" l√∂schen?`);
    if (!ok) return;
    fields = fields.filter(x=>x.id!==id);
    saveFields();
    refreshFieldSelect();
  });
}
/* =========================
   IMPORT / PASTE PARSER
========================= */
function openModal(){
  pasteText.value="";
  pasteAcc.value="";
  pasteTime.value="";
  modalBackdrop.classList.add("show");
  setTimeout(()=>pasteText.focus(), 0);
}
function closeModal(){
  modalBackdrop.classList.remove("show");
}

document.getElementById("btnInsert").addEventListener("click", openModal);
document.getElementById("btnModalClose").addEventListener("click", closeModal);
document.getElementById("btnPasteCancel").addEventListener("click", closeModal);
modalBackdrop.addEventListener("click", (e)=>{ if (e.target===modalBackdrop) closeModal(); });

function parseLatLngFromText(text){
  const t = (text||"").trim();
  if (!t) return null;

  // 1) Google Maps style: @lat,lng
  let m = t.match(/@(-?\d+(?:\.\d+)?),\s*(-?\d+(?:\.\d+)?)/);
  if (m) return { lat: Number(m[1]), lng: Number(m[2]) };

  // 2) plain "lat, lng" or "lat lng"
  m = t.match(/(-?\d{1,3}(?:\.\d+)?)[,\s]+(-?\d{1,3}(?:\.\d+)?)/);
  if (m) return { lat: Number(m[1]), lng: Number(m[2]) };

  // 3) "lat: x lng: y"
  m = t.match(/lat[^0-9-]*(-?\d+(?:\.\d+)?)[^0-9-]+lng[^0-9-]*(-?\d+(?:\.\d+)?)/i);
  if (m) return { lat: Number(m[1]), lng: Number(m[2]) };

  return null;
}

function isValidLatLng(ll){
  return ll && Number.isFinite(ll.lat) && Number.isFinite(ll.lng) && ll.lat>=-90 && ll.lat<=90 && ll.lng>=-180 && ll.lng<=180;
}

async function resolveLatLng(text){
  // 1) Direkt aus Text/Link extrahieren
  const direct = parseLatLngFromText(text);
  if (isValidLatLng(direct)) return direct;

  // 2) Kurzlink (maps.app.goo.gl) √ºber Worker aufl√∂sen
  const urlMatch = String(text||"").match(/https?:\/\/\S+/);
  if (!urlMatch) return null;

  try{
    const r = await fetch("/api/resolve-maps?url=" + encodeURIComponent(urlMatch[0]), { credentials:"include" });
    const j = await r.json().catch(()=>null);
    if (j && j.ok) {
      const ll = { lat: Number(j.lat), lng: Number(j.lng) };
      if (isValidLatLng(ll)) return ll;
    }
  }catch(_){}
  return null;
}


function parseTimeMs(){
  const v = (pasteTime.value||"").trim();
  if (!v) return null;
  const d = new Date(v);
  const ms = d.getTime();
  return Number.isFinite(ms) ? ms : null;
}

document.getElementById("btnPasteParse").addEventListener("click", async ()=>{
  const text = pasteText.value || "";
  const ll = await resolveLatLng(text);

  if (!ll){
    alert("Konnte keine Koordinaten finden. Tipp: Bei iOS-Maps Kurzlinks (maps.app.goo.gl) geht‚Äôs jetzt auch ‚Äì Link einfach reinkopieren.");
    return;
  }

  const acc = (pasteAcc.value==="" ? null : Number(pasteAcc.value));
  const tms = parseTimeMs();
  addPing(ll.lat, ll.lng, acc, tms);

  // direkt auf den Ping springen
  map.setView([ll.lat, ll.lng], Math.max(map.getZoom(), 16), { animate:true });

  closeModal();
});


/* =========================
   RESET / COLLAPSE
========================= */
document.getElementById("btnReset").addEventListener("click", ()=>{
  const ok = confirm("Alles l√∂schen? (Polygon + Pings + KI-Text)");
  if (!ok) return;
  state = { name:"", area:null, pings:[] };
  saveState();
  elAiOut.classList.add("muted");
  elAiOut.textContent="Noch keine Analyse. Zeichne ein Spielfeld und f√ºge 1‚Äì2 Pings ein.";
  clearOverlays();
  renderAll(true);
});

let collapsed=false;
document.getElementById("btnCollapse").addEventListener("click", ()=>{
  collapsed=!collapsed;
  document.getElementById("sideBody").style.display = collapsed ? "none" : "";
  document.getElementById("btnCollapse").textContent = collapsed ? "‚ñ∏" : "‚ñæ";
});

/* Name sync */
elGameName.addEventListener("input", ()=>{
  state.name = elGameName.value || "";
  saveState();
});

/* Overlay update on param change */
[elWalkMode, elWindowSec].forEach(el => el.addEventListener("change", ()=> drawPredictionOverlay()));

/* Initial */
renderAll(true);
bindFieldUI();
</script>
</body>
</html>
