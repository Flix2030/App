<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Lucky Cube</title>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="theme-color" content="#05080f" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <style>
/* ===== Base ===== */
body {
  font-family: Arial, sans-serif;
  background: #f0f8ff;
  text-align: center;
  margin: 0;
  padding: 20px;
}
h1 {
  color: #006080;
  font-size: 2.2em;
  margin-top: 20px;
}
.button {
  display:inline-block;
  background:#00cc44;
  color:#fff;
  padding:12px 18px;
  margin:8px;
  border-radius:8px;
  cursor:pointer;
  user-select:none;
  font-size:1.05em;
  width:200px;
}
.button:hover { background:#00e65c; }
select, input {
  padding:10px;
  border-radius:5px;
  border:1px solid #ccc;
  font-size:1em;
  margin:5px;
}

#app-section { margin-top: 20px; }

/* ===== Shared layout ===== */
.section {
  background: none;
  border: none;
  border-radius: 0;
  padding: 0;
  margin-top: 14px;
  max-width: 640px;
  margin-left: auto;
  margin-right: auto;
  text-align: center;
}
.row {
  display:flex;
  align-items:center;
  gap:10px;
  margin:8px 0;
  flex-wrap:wrap;
}
.small { font-size:.9em; color:#555; }
.error { color:#c30000; margin-top:6px; font-size:.9em; }

/* ===== Auction ===== */
.auction-wrap { max-width:640px; margin:0 auto; text-align:left; }
.input-eur {
  display:flex;
  align-items:center;
  border:1px solid #ccc;
  border-radius:6px;
  padding:0 10px;
}
.input-eur input {
  border:none;
  outline:none;
  padding:10px 6px;
  width:120px;
  background:transparent;
}
.input-eur span { margin-left:6px; }
.bid-list { margin-top:10px; }
.bid-item {
  background:#fff;
  border:1px solid #ddd;
  border-radius:6px;
  padding:8px 10px;
  margin:6px 0;
}

/* ===== Battle ===== */
.battle-wrap { max-width:640px; margin:0 auto; text-align:left; }
.mode-btn {
  display:inline-block;
  padding:8px 12px;
  border:1px solid #006080;
  border-radius:8px;
  cursor:pointer;
}
.mode-btn.active { background:#006080; color:#fff; }

/* ===== Name setup & manager ===== */
.player-row {
  display:flex;
  align-items:center;
  justify-content:center;
  gap:8px;
  margin:6px auto;
  width:100%;
  max-width:400px;
}
.drag-handle {
  width:36px;
  height:36px;
  display:grid;
  place-items:center;
  border-radius:6px;
  background:#eee;
  cursor:grab;
  user-select:none;
  font-size:1.1em;
  flex-shrink:0;
}
.drag-handle:active { background:#ddd; cursor:grabbing; }
.player-row input {
  flex:1;
  min-width:0;
  padding:8px;
  border:1px solid #ccc;
  border-radius:6px;
  font-size:1em;
}
.name-counter {
  font-size:.9em;
  color:#555;
  white-space:nowrap;
  flex-shrink:0;
}

/* ===== Lotto Bereich ===== */
.lotto-area {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
  width: min(560px, 92vw);
  margin: 0 auto;
}

/* EINMAL definiert, Grid bleibt bestehen */
.lotto-header {
  display: grid;
  grid-template-columns: 48px 1fr 48px;  /* links | mitte | rechts */
  align-items: center;
  width: 50%;
  gap: 12px;
  margin-bottom: 20px;
}

.lotto-header .icon-btn:first-child { justify-self: start; }
.lotto-header .icon-btn:last-child  { justify-self: end; }

.lotto-btn-left, .lotto-btn-right {
  position: absolute;
  top: -50px;
  width: 40px;
  height: 40px;
  border-radius: 10px;
  background: #00cc44;
  color: #fff;
  display: grid;
  place-items: center;
  cursor: pointer;
}
.lotto-btn-left { left: 0; }
.lotto-btn-right { right: 0; }
.lotto-btn-left:hover,
.lotto-btn-right:hover { background:#00e65c; }
.lotto-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 20px;
}
.lotto-title {
  justify-self: center;
  text-align: center;
  font-weight: 700;
  font-size: 1.4rem;   /* gr√∂√üer als Standard */
}

.lotto-player {
  text-align: center;
  font-weight: 700;
  font-size: 1.6rem;   /* jetzt deutlich sichtbar */
  margin: 6px 0 0 0;
}
.lotto-grid { margin-top: 8px; }

.lotto-area p {
  margin: 12px 0;              /* konsistente Abst√§nde */
  text-align: center;
}
.lotto-grid {
  display: flex;
  justify-content: center;
  gap: 14px;
}
.lotto-num {
  width: 90px;
  height: 90px;
  border-radius: 12px;
  border: 2px solid #cfe2ff;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 2rem;
  font-weight: 700;
  user-select: none;
}
.lotto-num.open   { color:#b00020; border-color:#ffb3b3; background:#ffe6e6; }
.lotto-num.active { color:#0057d9; border-color:#a7c4ff; background:#eaf1ff; cursor:pointer; }
.lotto-num.done   { color:#0b7a28; border-color:#a5d6a7; background:#e8f5e9; cursor:pointer; }

/* ===== Icon Button (‚ùì / ‚öôÔ∏è / ‚úñ) ===== */
.icon-btn {
  width: 44px;
  height: 44px;
  border-radius: 10px;
  background: #00cc44;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  user-select: none;
}
.icon-btn span { font-size: 1.4em; line-height: 1; display: block; }
.icon-btn:hover { background: #00e65c; }

.lotto-num.clickable { cursor: pointer; }

/* ===== Hauptbuttons konsistent gr√ºn ===== */
#app-section .button {
  display: block;
  margin: 10px auto;
  width: 240px;
}

/* ===== Header (auch f√ºr Settings/Jackpot/Streak) ===== */
.auction-header {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 10px;
  margin-bottom: 20px;
}
.auction-title {
  font-size: 2em;
  font-weight: 700;
}
.main-header {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 10px;
  position: relative;
  margin-bottom: 20px;
}
.main-header h1 {
  font-size: 2.2em;
  font-weight: 700;
  margin: 0;
  display: flex;
  align-items: center;
  gap: 10px;
}
/* Lotterie/Lucky-Streak Header wirklich zentriert */
.lotto-header{
  display: grid !important;
  grid-template-columns: 44px 1fr 44px;
  align-items: center;
  gap: 12px;
  width: 100%;              /* nicht 50% */
  max-width: 300px;         /* optional, passend zu .lotto-area */
  margin: 0 auto 20px;      /* zentriert den Block */
}

.lotto-header .icon-btn:first-child { justify-self: start; }
.lotto-header .icon-btn:last-child  { justify-self: end;  }

.lotto-title{
  justify-self: center;
  text-align: center;
  font-weight: 700;
  font-size: 1.4rem;
}


/* ===== Popup Overlay ===== */
.help-overlay {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  background: rgba(0,0,0,0.6);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}
.help-box {
  background: #fff;
  padding: 20px;
  border-radius: 12px;
  max-width: 600px;
  width: 90%;
  box-shadow: 0 4px 15px rgba(0,0,0,0.3);
  position: relative;
}
.help-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 15px;
}
.help-header h2 { margin: 0; font-size: 1.4em; color: #006080; }
.help-close { font-size: 1.4em; font-weight: bold; cursor: pointer; color: #333; }
.help-close:hover { color: #c30000; }

/* ===== Settings Box ===== */
.settings-section {
  background: #ffffff;
  border-radius: 14px;
  padding: 20px;
  box-shadow: 0 4px 15px rgba(0,0,0,0.1);
  max-width: 400px;
  margin: 0 auto;
}
.settings-title {
  font-size: 1.6em;
  font-weight: 700;
  margin-bottom: 16px;
  color: #006080;
}

/* Settings Zeilen + Responsive */
.settings-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 14px;
  margin: 12px 0;
  font-size: 1.05em;
}
.settings-row label:first-child {
  min-width: 260px;   /* genug Platz, damit alles einzeilig bleibt */
  text-align: left;
  font-weight: 600;
  color: #333;
}
@media (max-width: 480px) {
  .settings-row { align-items: flex-start; }
  .settings-row label:first-child { min-width: 0; }
}

/* ===== EINDEUTIGER Toggle: an links / aus rechts ===== */
.switch {
  position: relative;           /* wichtig: Referenz f√ºr .track */
  display: inline-block;
  width: 88px;                  /* Breite des Schalters */
  height: 36px;                 /* H√∂he des Schalters */
}
.switch input {
  position: absolute;
  opacity: 0;                   /* unsichtbar, aber fokussierbar */
  width: 0;
  height: 0;
}
.switch .track {
  position: absolute;
  inset: 0;
  background: #cfd8dc;
  border-radius: 999px;
  transition: background .2s ease;
  box-shadow: inset 0 0 0 1px rgba(0,0,0,.06);
}
.switch .track::after {         /* Knopf */
  content: "";
  position: absolute;
  width: 28px;
  height: 28px;
  left: 4px;
  top: 4px;
  background: #fff;
  border-radius: 50%;
  box-shadow: 0 2px 6px rgba(0,0,0,.25);
  transition: transform .2s ease;
}
/* Basis: AUS -> Text rechts */
.switch .track::before {
  content: attr(data-off);
  position: absolute;
  right: 14px;
  top: 50%;
  transform: translateY(-50%);
  font-weight: 700;
  font-size: .85rem;
  color: #455a64;
  transition: all .2s ease;
}
/* AN: gr√ºn, Knopf rechts, Text links */
.switch input:checked + .track { background: #00cc44; }
.switch input:checked + .track::after { transform: translateX(52px); } /* 88 - 36 = 52 */
.switch input:checked + .track::before {
  content: attr(data-on);
  left: 14px;
  right: auto;
  color: #fff;
}
/* deaktiviert (optional) */
.switch input:disabled + .track { background: #e0e0e0; }
.switch input:disabled + .track::after { box-shadow: none; }

/* ===== Dice Animation ===== */
.dice-el {
  position: fixed;
  top: 0; left: 0;
  width: 80px; height: 80px;
  background: #fff;
  border-radius: 12px;
  box-shadow: 0 10px 26px rgba(0,0,0,.28);
  display: grid;
  place-items: center;
  font-size: 48px;
  user-select: none;
  pointer-events: none;
  z-index: 2000;
}

/* ===== Poker UI (aufger√§umt) ===== */
.poker-area{
  width:min(680px,95vw);
  margin:0 auto;
  background:#fff;
  border:1px solid #ddd;
  border-radius:12px;
  padding:10px 12px;
}
.poker-row{
  display:grid;
  grid-template-columns:1fr 100px 200px;
  align-items:center;
  gap:12px;
  padding:8px 0;
  border-bottom:1px solid #eee;
}
.poker-row:last-child{border-bottom:none}
.poker-name{
  font-weight:600;
  overflow:hidden;
  text-overflow:ellipsis;
  white-space:nowrap;
  text-align:left;
}
.poker-payout{
  text-align:right;
  padding-right:6px;
  white-space:nowrap;
  font-variant-numeric:tabular-nums;
}
.poker-boxes{
  display:grid;
  grid-template-columns:repeat(5,32px);
  gap:8px;
  justify-content:start;
}
.poker-check{
  width:32px;height:32px;
  display:grid;place-items:center;
  border:1px solid #ccc;border-radius:6px;
  cursor:pointer;user-select:none;
  font-size:1.05rem;background:#fff;
}
.poker-check.active{background:#e8f5e9;border-color:#a5d6a7}

@media (max-width:520px){
  .poker-row{
    grid-template-columns:1fr 90px;
    grid-template-areas:
      "name payout"
      "boxes boxes";
  }
  .poker-name{grid-area:name}
  .poker-payout{grid-area:payout}
  .poker-boxes{grid-area:boxes}
}

/* ===== Modal-Ausrichtung: ‚ÄûWer spielt diese Runde?‚Äú mittig ===== */
.modal .field{margin:12px 0;text-align:center}
.modal .field label{display:block;font-weight:600;margin-bottom:6px;text-align:center}


/* ===== 50-50 ===== */
    .auction-header {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      margin-bottom: 20px;
    }
    .auction-title {
      font-size: 2em;
      font-weight: 700;
    }
    .icon-btn {
      width: 44px;
      height: 44px;
      border-radius: 10px;
      background: #00cc44;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      user-select: none;
    }
    .icon-btn span { font-size: 1.4em; }
    .icon-btn:hover { background:#00e65c; }

    .allnothing-wrap {
      max-width: 400px;
      margin: 0 auto;
      background: #fff;
      padding: 20px;
      border-radius: 12px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    }
    .button {
      display:inline-block;
      background:#00cc44;
      color:#fff;
      padding:14px 20px;
      margin:12px;
      border-radius:10px;
      cursor:pointer;
      user-select:none;
      font-size:1.2em;
      width:200px;
    }
    .button:hover { background:#00e65c; }

    .result {
      font-size: 1.4em;
      margin-top: 18px;
      font-weight: 700;
    }
    .lose { color:#d32f2f; }
    .win { color:#2e7d32; }
	
/* ===== Roulette (sauber) ===== */
.roulette-wrap{
  position:relative;
  width:320px;
  aspect-ratio:1/1;
  margin:0 auto 20px;
}
.roulette-wheel{
  width:100%; height:100%;
  border-radius:50%;
  border:6px solid #222;
  transform: rotate(0deg);
  transition: transform 3s cubic-bezier(.1,.7,.3,1);
  box-shadow: 0 12px 30px rgba(0,0,0,.18), inset 0 0 0 6px #222;
  position:relative;
  overflow:hidden;
}
.roulette-numlabel{
  position:absolute;
  left:50%; top:50%;
  font-weight:700;
  font-size:1rem;
  color:#fff;
  text-shadow:0 0 2px #000, 0 0 4px #000;
  pointer-events:none;
  white-space:nowrap;
}
.roulette-ball-container{
  position:absolute;
  inset:0;
  transform: rotate(-90deg);   /* 12-Uhr-Start */
  transition: transform 3s cubic-bezier(.1,.7,.3,1);
  pointer-events:none;
}
.roulette-ball{
  position:absolute;
  width:8%; height:8%;
  border-radius:50%;
  background:#fff;
  box-shadow:0 2px 6px rgba(0,0,0,.25);
  top: 50%;
  left: 50%;
  transform: translate(-50%,-50%);
}

.roulette-grid{
  display:grid; grid-template-columns:1fr 1fr; gap:12px;
  max-width:340px; margin:10px auto;
}
.roulette-btn{
  padding:12px; border-radius:10px; cursor:pointer;
  background:#00cc44; color:#fff; text-align:center; font-size:1.05em; user-select:none;
  border:3px solid transparent;
}
.roulette-btn:hover{ background:#00e65c; }
.roulette-btn.active{ border-color:#000; }

.roulette-input{
  display:flex; align-items:center; gap:8px; justify-content:center;
  background:#fff; border:1px solid #ccc; border-radius:10px; padding:6px 10px;
}
.roulette-input input{ width:70px; border:none; outline:none; font-size:1rem; text-align:center; }

.roulette-small{ font-size:.9em; color:#555; margin-top:6px; text-align:center; }

.action-row {
  display: flex;
  justify-content: center;
  gap: 20px;
  max-width: 340px;
  margin: 12px auto 6px;
}

#playBtn,
#stakeBtn {
  flex: 1;              /* beide gleich gro√ü */
  max-width: 160px;     /* ca. halbes Roulette */
  text-align: center;
}

.disabled{ filter:grayscale(.4); opacity:.7; cursor:not-allowed; }

#warnMsg{ color:#c62828; margin-top:6px; min-height:1.2em; }

.roulette-number-row {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 8px;
  grid-column: span 2; /* nimmt volle Breite in Grid */
}

.roulette-number-row input {
  width: 60px;          /* viel kleiner */
  height: 28px;         /* halb so hoch wie Standard */
  padding: 4px;
  text-align: center;
  font-size: 1em;
  border: 1px solid #ccc;
  border-radius: 6px;
}

.roulette-number-green-row {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 8px;
  grid-column: span 2;
  margin-top: 6px;
}

.roulette-number-green-row input {
  width: 60px;
  height: 28px;
  padding: 4px;
  text-align: center;
  font-size: 1em;
  border: 1px solid #ccc;
  border-radius: 6px;
}

/* gr√ºner Button breiter machen */
.roulette-btn.wide {
  flex: 1;           /* nimmt mehr Platz */
  min-width: 120px;  /* ungef√§hr wie Gerade/Ungerade */
  text-align: center;
}

/* ===== Modal Styles ===== */
.modal-backdrop {
  position: fixed;
  inset: 0; /* top:0; right:0; bottom:0; left:0 */
  background: rgba(0,0,0,0.6);
  display: none;       /* Standard: unsichtbar */
  align-items: center; /* zentriert vertikal */
  justify-content: center; /* zentriert horizontal */
  z-index: 2000;
}

.modal {
  background: #fff;
  padding: 20px;
  border-radius: 12px;
  max-width: 400px;
  width: 90%;
  box-shadow: 0 4px 15px rgba(0,0,0,0.3);
  text-align: center;
}

.modal h2 {
  margin-top: 0;
  color: #006080;
}

.modal .hint {
  font-size: .9em;
  color: #555;
  margin-bottom: 10px;
}

.modal .field {
  margin: 12px 0;
}

.modal .field label {
  display: block;
  font-weight: 600;
  margin-bottom: 6px;
}

.modal .field input {
  width: 120px;         /* statt 100% */
  padding: 6px 8px;
  font-size: 1em;
  border: 1px solid #ccc;
  border-radius: 6px;
  text-align: center;   /* Zahl mittig */
}

.modal-actions {
  display: flex;
  justify-content: flex-end;
  gap: 10px;
  margin-top: 14px;
}

.modal .btn {
  padding: 10px 16px;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-size: 1em;
}

.modal .btn.primary {
  background: #00cc44;
  color: #fff;
}

.modal .btn.primary:hover {
  background: #00e65c;
}

.inventory {
  background: #fff;
  border: 1px solid #ccc;
  border-radius: 10px;
  padding: 10px;
  margin: 10px auto;
  max-width: 500px;
  text-align: left;
}

.inv-cards {
  margin-top: 6px;
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.inv-card {
  background: #f0f8ff;
  border: 1px solid #aaa;
  border-radius: 6px;
  padding: 6px;
  font-size: 0.95em;
  display: flex;
  justify-content: space-between;
  align-items: center;
}
.inv-card button {
  background: #00cc44;
  color: #fff;
  border: none;
  border-radius: 6px;
  padding: 4px 8px;
  cursor: pointer;
}
.inv-card button:hover {
  background: #00e65c;
}

/* Einheitliche Button-Reihe in Modals */
.modal-actions.centered {
  justify-content: center;
  gap: 12px;
}

/* Gleich breite Modal-Buttons */
.modal .btn.equal {
  flex: 1;
  max-width: 140px;
}

/* ===== Event Log (Layout wie Skizze) ===== */
.event-log{
  display: flex;
  flex-direction: column;
  align-items: center;   /* Karten zentrieren */
  gap: 14px;
}

.event-card{
  background:#fff;
  border:1px solid #ccc;
  border-radius:12px;
  padding:14px 18px;
  box-shadow:0 4px 10px rgba(0,0,0,0.08);

  max-width: 650px;   /* ungef√§hr wie oben zwischen ? und ‚öôÔ∏è */
  width: 100%;

  display:grid;
  grid-template-columns: 180px 1fr;
  gap: 12px 20px;
}

/* Linke Spalte: Spieler + Zeit mittig */
.event-left{
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  gap:6px;
}

.event-player{
  font-weight:700;
  color:#006080;
  display:flex;
  align-items:center;
  gap:6px;
}

.event-time{
  color:#555;
  font-size:0.9em;
  display:flex;
  align-items:center;
  gap:6px;
}

/* Rechte Spalte neu strukturieren */
.event-right{
  display:flex;
  flex-direction:column;
  align-items:center;   /* zentriert statt rechts */
  text-align:center;
}

.event-kind{
  margin-bottom:6px;
  padding:4px 10px;
  border-radius:10px;
  background:#f6fbff;
  border:1px solid #cfe2ff;
  font-weight:700;
}

.event-text{
  color:#333;
  word-break:break-word;
}

// bei Ereigniskarten
eventLog.unshift({
  player: player,
  text: "Ereigniskarte: Goldregen: jeder +10 ‚Ç¨, du +20 ‚Ç¨",
  kind: "card",
  time: now.toLocaleTimeString()
});

// bei Troph√§en
eventLog.unshift({
  player: player,
  text: `üèÜ ${amount} Troph√§e${amount>1?"n":""} erhalten`,
  kind: "trophy",
  time: now.toLocaleTimeString()
});

// bei Artefaktum-K√§ufen
eventLog.unshift({
  player: player,
  text: `üõí ${itemName} gekauft`,
  kind: "shop",
  time: now.toLocaleTimeString()
});

/* ===== Panel (gemeinsamer wei√üer Kasten) ===== */
.panel{
  background:#ffffff;
  border-radius:14px;
  padding:20px;
  box-shadow:0 4px 15px rgba(0,0,0,0.1);
  max-width:400px;         /* gleiche Breite wie .settings-section */
  margin:0 auto;           /* zentriert */
}

/* Statistik nutzt den gleichen Kasten wie die Settings */
.stats-section{ /* nur Alias ‚Äì falls du sp√§ter abweichende Abst√§nde brauchst */
}

/* Tabelle kompakt und zentriert im Panel */
.stats-table{
  width:100%;
  border-collapse:separate;
  border-spacing:12px 10px;    /* etwas Luft zwischen Spalten/Zeilen */
  font-size:1.05em;
}
.stats-table th{
  text-align:left;
  font-weight:700;
  padding-bottom:6px;
}
.stats-table td{
  text-align:left;
  white-space:nowrap;
}

/* ===== Statistik ===== */
.panel.stats-section {
  background: #fff;
  border-radius: 12px;
  padding: 16px;
  max-width: 600px;
  margin: 20px auto;
  box-shadow: 0 2px 10px rgba(0,0,0,0.08);
}

.stats-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.95em;
}

.stats-table th,
.stats-table td {
  padding: 6px 10px;
  border-bottom: 1px solid #eee;
  text-align: left;
}

.stats-table th {
  font-weight: 600;
  color: #333;
}

.stats-table tr:last-child td {
  border-bottom: none;
}

/* ==== Artefaktum (3 Karten untereinander) ==== */
.arte-wrap{max-width:520px;margin:0 auto}
.arte-col{display:flex;flex-direction:column;gap:16px}
.arte-card{
  background:#fff;border:1px solid #ddd;border-radius:14px;
  padding:14px;text-align:center;display:flex;flex-direction:column;align-items:center
}
.arte-emoji{font-size:2.2rem;line-height:1}
.arte-name{margin-top:6px;font-size:1.05rem}
.arte-price{margin-top:8px;font-size:2rem;font-weight:800}
.arte-buy{margin-top:10px;width:200px}
.arte-foot{margin-top:8px;font-size:.9rem;color:#555;text-align:center}
.button.disabled {
  background:#cdeac7;   /* hellgr√ºn-wei√ü */
  color:#666;
  cursor:default;
  pointer-events:none;
}

  </style>
<style>

/* ===== Theme (Dark default) ===== */
:root{
  --bg0:#05080f;
  --bg1:#0a1020;
  --panel:rgba(18,28,55,.72);
  --panel2:rgba(10,18,38,.78);
  --border:rgba(255,255,255,.10);
  --text:rgba(255,255,255,.94);
  --mut:rgba(255,255,255,.66);
  --acc:#2ee88f;
  --shadow:0 22px 70px rgba(0,0,0,.55);
}
body{
  color:var(--text);
  background:
    radial-gradient(1200px 600px at 15% 0%, rgba(46,232,143,.18), transparent 60%),
    radial-gradient(1200px 700px at 85% 10%, rgba(90,120,255,.12), transparent 60%),
    linear-gradient(180deg,var(--bg1),var(--bg0));
}

/* Inputs/Selects: nicht hellgrau */
input,select,textarea{
  background:rgba(0,0,0,.22) !important;
  color:var(--text) !important;
  border:1px solid var(--border) !important;
}
select option{ background:#0b1326 !important; color:var(--text) !important; }

/* Cards/Boxes */
.settings-section,.auction-section,.event-section,.players-section,.stats-section,.mode-box,.game-box,.card,.panel,.box{
  background:var(--panel);
  border:1px solid var(--border);
  box-shadow:var(--shadow);
}

/* Buttons */
.button, button, .btn, .btn-primary{
  border:1px solid rgba(255,255,255,.10);
  background:rgba(255,255,255,.08);
  color:var(--text);
}
.btn-primary, .primary, .ok, .confirm, .green{
  background:linear-gradient(180deg, rgba(46,232,143,.95), rgba(46,232,143,.70)) !important;
  color:#00150a !important;
  border-color:rgba(46,232,143,.45) !important;
  box-shadow:0 14px 40px rgba(46,232,143,.18) !important;
}

/* Fixed background (verhindert "Cuts"/Streifen bei wenig Inhalt) */
html{ background: var(--bg0); }
body{ margin:0; min-height:100vh; background: none; padding: clamp(14px, 2.2vw, 22px);
      padding-top: calc(clamp(14px, 2.2vw, 22px) + env(safe-area-inset-top));
      padding-left: calc(clamp(14px, 2.2vw, 22px) + env(safe-area-inset-left));
      padding-right: calc(clamp(14px, 2.2vw, 22px) + env(safe-area-inset-right));
      padding-bottom: calc(clamp(14px, 2.2vw, 22px) + env(safe-area-inset-bottom));
}
body:not(.light)::before{
  content:"";
  position: fixed;
  inset: 0;
  z-index: -1;
  background: radial-gradient(1200px 600px at 15% 0%, rgba(38,255,168,.18), transparent 60%),
              radial-gradient(900px 600px at 100% 20%, rgba(80,140,255,.16), transparent 55%),
              linear-gradient(180deg, var(--bg0), var(--bg1));
}

body.light::before{
  content:"";
  position: fixed;
  inset: 0;
  z-index: -1;
  background: radial-gradient(1000px 520px at 10% 0%, rgba(38,255,168,.10), transparent 60%),
              radial-gradient(900px 520px at 100% 10%, rgba(80,140,255,.10), transparent 55%),
              linear-gradient(180deg, #e9f5ff, #ffffff);
}

/* Buttons (einheitlicher Stil) */
.btn-action{ padding:10px 14px; border-radius:14px; font-weight:900; }
.btn-sm{ padding:9px 12px; border-radius:12px; font-weight:800; font-size: 14px; }
.btn.wide, .btn-primary.wide{ width:100%; max-width:360px; }

/* Rundenliste */
.round-item{
  display:flex; align-items:center; gap:12px;
  background: rgba(255,255,255,.04);
  border: 1px solid var(--border);
  border-radius: 16px;
  padding: 12px;
  margin: 10px 0;
}
.round-item.active{ border-color: rgba(46,232,143,.55); box-shadow: 0 0 0 2px rgba(46,232,143,.12) inset; }
.round-icon{ font-size:22px; width:34px; height:34px; display:grid; place-items:center; border-radius:12px;
  background: rgba(46,232,143,.10); border:1px solid rgba(46,232,143,.22);
}
.round-meta{ flex:1; min-width: 180px; text-align:left; }
.round-name{ font-weight: 950; }
.round-players{ color: var(--mut); font-size: 13px; margin-top:2px; }
.round-actions{ display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end; }

@media (max-width: 520px){
  .round-item{ padding: 12px; }
  .round-meta{ min-width: 0; width: 100%; }
  .round-actions{ width:100%; justify-content:stretch; }
  .round-actions button{ flex:1; }
}

/* Popups/Modals -> Dark */
.modal, .help-overlay{
  background: rgba(0,0,0,.55) !important;
}
.modal .modal-content, .help-box, .result{
  background: var(--panel2) !important;
  color: var(--text) !important;
  border: 1px solid var(--border) !important;
  box-shadow: 0 18px 60px rgba(0,0,0,.55) !important;
}
.help-header h2{ color: var(--text) !important; }
.help-close{ background: rgba(255,255,255,.06) !important; border:1px solid var(--border) !important; }
.help-close:hover{ background: rgba(255,255,255,.10) !important; }

/* Eventkarten Vorschau */
.card-preview{
  background: rgba(255,255,255,.06);
  border: 1px solid var(--border);
  border-radius: 14px;
  padding: 16px;
  margin: 16px auto;
  max-width: 520px;
  font-size: 1.05em;
  line-height: 1.35;
  box-shadow: 0 10px 30px rgba(0,0,0,.35);
}

/* Inputs/Selects im Dark-Mode (Dropdown am PC nicht hellgrau) */
input, select, textarea{
  background: rgba(8,14,28,.65);
  color: var(--text);
  border: 1px solid var(--border);
}
option{ background: #0b1226; color: #fff; }

/* iOS: verhindert wei√üen Rand oben */
@supports (padding: max(0px)){
  body{ background-color: var(--bg0); }
}


/* Light theme (wenn Dark Mode aus) */
body.light{
  --bg0:#f2f6ff;
  --bg1:#e6eeff;
  --panel:rgba(255,255,255,.86);
  --panel2:rgba(255,255,255,.92);
  --border:rgba(0,0,0,.10);
  --text:rgba(0,0,0,.88);
  --mut:rgba(0,0,0,.55);
  --shadow:0 18px 55px rgba(0,0,0,.14);
  background:linear-gradient(180deg,var(--bg1),var(--bg0));
}
body.light input, body.light select, body.light textarea{
  background:rgba(0,0,0,.04) !important;
  color:var(--text) !important;
}
body.light select option{ background:#ffffff !important; color:#000 !important; }



/* ===== UI FIX: OPAQUE DARK POPUPS + DARK INPUTS (2026-01-20) ===== */
:root{
  --panelSolid:#0c1426;
  --panelSolid2:#0a1020;
  --fieldBg:#070c16;
  --fieldBorder:rgba(255,255,255,.14);
}
body.light{
  --panelSolid:#ffffff;
  --panelSolid2:#ffffff;
  --fieldBg:#ffffff;
  --fieldBorder:rgba(0,0,0,.16);
}

/* make ALL overlays cover the full screen */
.modal-backdrop, .help-overlay{ position:fixed !important; inset:0 !important; }

/* OPAQUE modal/content (no glass) */
.modal .modal-content, .help-box, .result, .modal{
  background: var(--panelSolid) !important;
  color: var(--text) !important;
  border: 1px solid var(--border) !important;
  backdrop-filter: none !important;
  -webkit-backdrop-filter: none !important;
  opacity: 1 !important;
}
body.light .modal .modal-content,
body.light .help-box,
body.light .result,
body.light .modal{
  background: #fff !important;
  color: #0b1220 !important;
  border-color: rgba(0,0,0,.12) !important;
}

/* Fix white panels inside modes */
.inventory-slot,
.inventory-card,
.poker-area,
.event-card,
.panel,
.panel.stats-section,
.bid-item{
  background: var(--panelSolid) !important;
  color: var(--text) !important;
  border: 1px solid var(--border) !important;
}
body.light .inventory-slot,
body.light .inventory-card,
body.light .poker-area,
body.light .event-card,
body.light .panel,
body.light .panel.stats-section,
body.light .bid-item{
  background:#fff !important;
  color:#0b1220 !important;
  border-color: rgba(0,0,0,.12) !important;
}

/* Form controls */
select, input, textarea{
  background: var(--fieldBg) !important;
  color: var(--text) !important;
  border: 1px solid var(--fieldBorder) !important;
}
body.light select, body.light input, body.light textarea{
  background:#fff !important;
  color:#0b1220 !important;
  border-color: rgba(0,0,0,.16) !important;
}
select option{
  background: var(--panelSolid2);
  color: var(--text);
}
body.light select option{
  background:#fff;
  color:#0b1220;
}

/* Roulette: selected bet + stake indicator */
.roulette-btn.active{
  outline: 2px solid #fff !important;
  outline-offset: 2px;
}
#stakeBtn.active{
  outline: 2px solid #fff !important;
  outline-offset: 2px;
}

/* Auction list items */
.bid-item{
  padding: 10px 14px !important;
  border-radius: 12px !important;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap: 10px;
}
.bid-item strong{ color: var(--text) !important; }

/* Ensure the page background never "shrinks" with content */
html, body{ min-height:100%; }
body{
  margin:0 !important;
  padding:0 !important;
  background: radial-gradient(1200px 700px at 20% -10%, rgba(46,232,143,.18), transparent 55%),
              radial-gradient(1200px 700px at 80% 0%, rgba(46,232,143,.10), transparent 60%),
              linear-gradient(180deg, var(--bg0), var(--bg1)) !important;
  background-attachment: fixed !important;
}
</style>

</head>
<body>

<div class="main-header">
  <h1>
    <div class="icon-btn" onclick="showHelp(currentContext)">‚ùì</div>
    üé≤ Lucky Cube üé≤
    <div class="icon-btn" onclick="goHomeApp()" title="Home">üè†</div>
    <div class="icon-btn" onclick="openSettings()" title="Einstellungen">‚öôÔ∏è</div>
  </h1>
</div>

  <div id="app-section"><div class="settings-section"><div style="color:var(--mut);font-weight:800;">Lade‚Ä¶</div></div></div>

  <script>
/* ===== Global ===== */
let totalPlayers = 0;
let playerNames = [];
let eventLog = [];  // [{player:"Alice", text:"Goldregen", time:"12:34:56"}]
// === Snapshot f√ºr Ereigniskarten (UI-Zustand merken) ===
window._eventcardSnapshot = null;

// --- EventLog NICHT mehr automatisch loeschen (wird ueber D1 gespeichert) ---

/* === Event-Log persistent speichern === */
function saveEventLog() {
  try {
    localStorage.setItem("eventLog", JSON.stringify(eventLog.slice(0, 300))); // capped
  } catch(e) { console.warn("saveEventLog failed:", e); }
}
function loadEventLog() {
  try {
    const raw = localStorage.getItem("eventLog");
    if (raw) {
      const arr = JSON.parse(raw);
      if (Array.isArray(arr)) eventLog = arr;
    }
  } catch(e) { console.warn("loadEventLog failed:", e); }
}
loadEventLog();

// Auction mit geheimem Wert
let auctionState = {
  highestBid: 0,
  highestBidder: null,
  bids: [],
  ended: true,
  prize: null // Geheimwert
};

// Battle: immer frisch
let battleState = { challenger: null, opponent: null, wager: 0, mode: "highest", rollA: null, rollB: null, ended: false, error: "" };

// Lotto: 4 gemeinsame Zahlen (1‚Äì9), Zustand bleibt bis Rundenende
let lottoState = {
  numbers: [],       // [{ value:1..9, done:false }, ...] (4 St√ºck)
  winner: null,
  active: false,
  ended: true,
  turnIndex: 0,      // wer ist dran
  activeIdx: 0       // welche der 4 Zahlen ist blau/aktiv
};

// Lucky Streak
let streakState = {
  buyIn: 0,           // 5/10/15/20
  multiplier: 1,      // 1.25 / 1.5 / 1.75 / 2
  steps: 0,           // wie oft erfolgreich (keine 1)
  base: 10,           // Basisgewinn je Erfolg
  ended: false,
  payout: 0
};

// Jackpot
let jackpotState = {
  pot: 0,                 // aktueller Pot in ‚Ç¨
  history: [],            // [{round:n, winner:'Name', amount:‚Ç¨}, ...]
  round: 1
};

let settings = {
  darkMode: true,
  devMode: false,
  externalRoll: false,
  directHome: false,
};

// beim Start laden
const saved = localStorage.getItem("settings");
if (saved) {
  try {
    settings = JSON.parse(saved);
    settings.externalRoll = (settings.externalRoll === true || settings.externalRoll === "yes");
    settings.devMode      = (settings.devMode === true || settings.devMode === "yes");
    settings.directHome   = (settings.directHome === true || settings.directHome === "yes");
    if (typeof settings.darkMode === "undefined") settings.darkMode = true;
  } catch (e) {
    console.error("Fehler beim Laden", e);
  }
}

function saveSettings() {
  localStorage.setItem("settings", JSON.stringify(settings));
  try { persistRuntimeToGame(); } catch(e) {}
}

/* ===== D1 Storage + Runden (Sessions) ===== */
let cloudData = { currentId: null, order: [], games: {}, lastPlayerCount: "" };
let _saveTimer = null;
let _savePending = false;

async function apiGetLucky() {
  const r = await fetch("/api/luckycube/data", { credentials:"include" });
  if (r.status === 401) { location.href = "/login.html"; return null; }
  const j = await r.json().catch(()=>null);
  if (!j || j.ok !== true) throw new Error(j?.error || "load_failed");
  return j.data || { currentId:null, order:[], games:{}, lastPlayerCount:"" };
}

async function apiPutLucky(data) {
  const r = await fetch("/api/luckycube/data", {
    method:"PUT",
    headers:{ "Content-Type":"application/json" },
    credentials:"include",
    body: JSON.stringify(data)
  });
  if (r.status === 401) { location.href = "/login.html"; return; }
  const j = await r.json().catch(()=>null);
  if (!j || j.ok !== true) throw new Error(j?.error || "save_failed");
  try { persistRuntimeToGame(); } catch(e) {}
}

function scheduleSave() {
  _savePending = true;
  if (_saveTimer) return;
  _saveTimer = setTimeout(async ()=>{
    _saveTimer = null;
    if (!_savePending) return;
    _savePending = false;
    try { await apiPutLucky(cloudData); }
    catch(e){ console.error("D1 save failed", e); }
  }, 250);
}

function makeId() {
  return "game_" + Date.now().toString(36) + "_" + Math.random().toString(36).slice(2,8);
}

function getGame(id) {
  if (!id) return null;
  return cloudData.games?.[id] || null;
}

function ensureGame(id) {
  if (!cloudData.games) cloudData.games = {};
  if (!cloudData.order) cloudData.order = [];
  if (!cloudData.games[id]) {
    cloudData.games[id] = {
      id,
      name: "Runde",
      createdAt: Date.now(),
      updatedAt: Date.now(),
      totalPlayers: 0,
      playerNames: [],
      settings: null,
      stats: null,
      trophyStats: null,
      eventLog: []
    };
  }
  return cloudData.games[id];
}

function setActiveGame(id) {
  cloudData.currentId = id;
  ensureGame(id);
  if (!cloudData.order.includes(id)) cloudData.order.unshift(id);
  scheduleSave();
}

function applyTheme() {
  const dark = (settings.darkMode !== false);
  document.body.classList.toggle("light", !dark);
}

function persistRuntimeToGame() {
  const g = getGame(cloudData.currentId);
  if (!g) return;
  g.updatedAt = Date.now();
  g.totalPlayers = totalPlayers || g.totalPlayers || 0;
  g.playerNames = Array.isArray(playerNames) ? playerNames.slice() : (g.playerNames||[]);
  g.settings = settings;
  try { g.stats = stats; } catch {}
  try { g.trophyStats = trophyStats; } catch {}
  g.eventLog = Array.isArray(eventLog) ? eventLog.slice(0,300) : [];
  scheduleSave();
}

function loadGameToRuntime(g) {
  if (!g) return;
  totalPlayers = g.totalPlayers || 0;
  playerNames = Array.isArray(g.playerNames) ? g.playerNames.slice() : [];
  settings = g.settings || settings;
  if (typeof settings.darkMode === "undefined") settings.darkMode = true;
  applyTheme();
  try { stats = g.stats || stats; } catch {}
  try { trophyStats = g.trophyStats || trophyStats; } catch {}
  eventLog = Array.isArray(g.eventLog) ? g.eventLog.slice() : [];
}

function goHomeApp() {
  try { persistRuntimeToGame(); } catch {}
  location.href = "/home";
}

function goRoundsMenu() {
  try { persistRuntimeToGame(); } catch {}
  renderRoundsMenu();
}

function renderRoundsMenu() {
  currentContext = "setup";
  const el = document.getElementById("app-section");
  if (!el) return;

  const rows = (cloudData.order || []).filter(id => cloudData.games && cloudData.games[id]).map(id => cloudData.games[id]);

  const list = rows.length ? rows.map(g=>{
    const active = (g.id === cloudData.currentId);
    const players = (g.playerNames||[]).length ? g.playerNames.join(", ") : "‚Äî";
    return `
      <div class="round-item ${active ? 'active' : ''}">
        <div class="round-icon">üé≤</div>
        <div class="round-meta">
          <div class="round-name">${escapeHtml(g.name||"Runde")}</div>
          <div class="round-players">Spieler: ${escapeHtml(players)}</div>
        </div>
        <div class="round-actions">
          <button class="btn-primary btn-sm" onclick="openRound('${g.id}')">√ñffnen</button>
          <button class="btn btn-sm" onclick="renameRoundPrompt('${g.id}')">Umbenennen</button>
          <button class="btn btn-sm danger" onclick="deleteRoundPrompt('${g.id}')">L√∂schen</button>
        </div>
      </div>
    `;
}).join("") : `<div style="color:var(--mut);">Keine Runden vorhanden.</div>`;

  const last = cloudData.lastPlayerCount || "";
  el.innerHTML = `
    <div class="settings-section">
      <div class="auction-header">
        <div class="auction-title">üé≤ Runden</div>
        <div style="display:flex;gap:10px;">
          <div class="icon-btn" onclick="showHelp('setup')" title="Hilfe">‚ùì</div>
          <div class="icon-btn" onclick="openSettings()" title="Einstellungen">‚öôÔ∏è</div>
        </div>
      </div>

      <h2>Neue Runde</h2>
      <label>Rundenname</label>
      <input id="roundName" type="text" maxlength="30" placeholder="z.B. Freitagabend">
      <br><br>
      <label>Spieleranzahl w√§hlen</label>
      <select id="playerCount">
        <option value="" ${last===""?"selected":""} disabled>Bitte w√§hlen</option>
        ${[2,3,4,5,6,7,8].map(n=>`<option value="${n}" ${String(n)===String(last)?"selected":""}>${n} Spieler</option>`).join("")}
      </select>
      <br><br>
      <button class="btn-primary wide" onclick="createRound()">üé≤ Runde erstellen</button>

      <h2 style="margin-top:18px;">Aktuelle Spiele</h2>
      ${list}
    </div>
  `;
}

function escapeHtml(s){
  return String(s||"").replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
}

function createRound() {
  const name = (document.getElementById("roundName")?.value || "").trim() || "Runde";
  const pc = document.getElementById("playerCount")?.value;
  if (!pc) { alert("Bitte Spieleranzahl w√§hlen."); return; }
  cloudData.lastPlayerCount = pc;
  const id = makeId();
  setActiveGame(id);
  const g = ensureGame(id);
  g.name = name;
  g.totalPlayers = parseInt(pc,10);
  g.playerNames = [];
  g.eventLog = [];
  g.settings = settings;
  totalPlayers = g.totalPlayers;
  playerNames = [];
  eventLog = [];
  persistRuntimeToGame();
  showNameInputs();
}

function openRound(id){
  persistRuntimeToGame();
  setActiveGame(id);
  const g = ensureGame(id);
  loadGameToRuntime(g);
  // If names missing -> names screen else home menu
  if (!playerNames || !playerNames.length) showNameInputs();
  else { initDeck(); ensureEventSystemReady(); showHome(); }
}

function renameRoundPrompt(id){
  const g = getGame(id);
  if (!g) return;
  const n = prompt("Neuer Name:", g.name || "Runde");
  if (n === null) return;
  g.name = (n.trim() || g.name || "Runde");
  g.updatedAt = Date.now();
  scheduleSave();
  renderRoundsMenu();
}

function deleteRoundPrompt(id){
  if (!confirm("Runde wirklich l√∂schen?")) return;
  delete cloudData.games[id];
  cloudData.order = (cloudData.order||[]).filter(x=>x!==id);
  if (cloudData.currentId === id) cloudData.currentId = cloudData.order[0] || null;
  scheduleSave();
  renderRoundsMenu();
}

function openRoundFromSettings(){
  goRoundsMenu();
}

function endGameFromSettings(){
  // Zusammenfassung + Optionen
  const g = getGame(cloudData.currentId);
  const name = g?.name || "Runde";
  const players = (g?.playerNames || playerNames || []).join(", ") || "‚Äî";
  const html = `
    <div class="help-overlay">
      <div class="help-box">
        <div class="help-header">
          <h2>Spiel beenden: ${escapeHtml(name)}</h2>
          <div class="help-close" onclick="document.body.removeChild(this.closest('.help-overlay'))">‚úñ</div>
        </div>
        <div style="color:var(--mut);margin-bottom:10px;">Spieler: ${escapeHtml(players)}</div>
        <div style="display:flex;gap:10px;flex-wrap:wrap;">
          <button class="btn" onclick="document.body.removeChild(this.closest('.help-overlay')); openRoundFromSettings();">Zum Runden-Men√º</button>
          <button class="btn" onclick="document.body.removeChild(this.closest('.help-overlay')); deleteRoundPrompt('${escapeHtml(cloudData.currentId)}');">Runde l√∂schen</button>
          <button class="btn-primary" onclick="document.body.removeChild(this.closest('.help-overlay')); closeSettings();">Zur√ºck ins Spiel</button>
        </div>
      </div>
    </div>
  `;
  document.body.insertAdjacentHTML("beforeend", html);
}



let currentContext = "home";

let _settingsPrevContext = null;
let _settingsPrevHTML = "";

/* ===== Setup ===== */
function confirmPlayerCount() {
  const selected = document.getElementById("playerCount").value;
  if (!selected) {
    document.getElementById("app-section").innerHTML += "<p class='error'>Bitte zuerst die Spieleranzahl w√§hlen.</p>";
    return;
  }
  totalPlayers = parseInt(selected, 10);

  if (settings.devMode && settings.directHome) {
    // sofort ins Men√º
    playerNames = ["Alice", "Bob", "Carol", "Dave"];
    showHome();
  } else if (settings.devMode && totalPlayers === 4) {
    // DevMode: Namen schon drin
    playerNames = ["Alice", "Bob", "Carol", "Dave"];
    showNameInputs();
  } else {
    // normal
    showNameInputs();
  }
}
const DEV_MODE = true;

function showNameInputs() {
  currentContext = "players";

  let defaultNames = ["Alice", "Bob", "Carol", "Dave"];

  let html = `<h2>Spielernamen eingeben</h2><div id="nameList">`;

  for (let i = 1; i <= totalPlayers; i++) {
    let prefill = "";
    if (settings.devMode && totalPlayers === 4) {
      prefill = defaultNames[i-1] || "";
    }
    html += `
      <div class="player-row" data-index="${i}">
        <span class="drag-handle" draggable="true" title="Ziehen">‚â°</span>
        <div style="display:flex; align-items:center; gap:6px;">
          <input type="text" id="name${i}" maxlength="20" placeholder="Spieler ${i}" value="${prefill}"
                 oninput="updateNameCounter('name${i}')">
          <span id="counter-name${i}" class="name-counter">${prefill.length}/20</span>
        </div>
      </div>`;
  }

  html += `</div>
           <div id="nameError" class="error"></div>
           <div class="button" onclick="saveNames()">Weiter</div>`;

  document.getElementById("app-section").innerHTML = html;
  enableNameDragDrop();
}

function enableNameDragDrop() {
  const list = document.getElementById("nameList");
  let draggingRow = null;

  // Drag nur am Griff starten
  list.querySelectorAll(".drag-handle").forEach(handle => {
    handle.addEventListener("dragstart", e => {
      draggingRow = handle.closest(".player-row");
      e.dataTransfer.effectAllowed = "move";
      e.dataTransfer.setData("text/plain", "drag");
    });
  });

  // Droppen auf Zeilen
  list.querySelectorAll(".player-row").forEach(row => {
    row.addEventListener("dragover", e => e.preventDefault());
    row.addEventListener("drop", e => {
      e.preventDefault();
      if (!draggingRow || draggingRow === row) return;

      const all = Array.from(list.children);
      const from = all.indexOf(draggingRow);
      const to   = all.indexOf(row);
      if (from < to) row.after(draggingRow);
      else row.before(draggingRow);

      // IDs der Inputs neu setzen (name1, name2, ‚Ä¶)
      Array.from(list.querySelectorAll(".player-row input")).forEach((inp, i) => {
        inp.id = "name" + (i + 1);
      });
    });
  });
}

function saveNames() {
  let message = "";
  const temp = [];
  for (let i = 1; i <= totalPlayers; i++) {
    const val = document.getElementById(`name${i}`).value.trim();
    if (!val) { message = "Bitte alle Namen eingeben!"; break; }
    if (temp.includes(val)) { message = `Der Name "${val}" ist bereits vergeben!`; break; }
    temp.push(val);
  }
  const err = document.getElementById("nameError");
  if (message) { err.textContent = message; return; } else { err.textContent = ""; }
  playerNames = temp;
  try { persistRuntimeToGame(); } catch(e) {}
  showHome();
  initDeck();
}

function showHome() {
  currentContext = "home";
  if (typeof _killOverlays === "function") _killOverlays();

  // Buttons zusammenbauen
  let html = "";

  html += `
    <div class="button" id="btnLotto">üéØ Lotto</div>
    <div class="button" id="btnAuction">üí∞ Auktion</div>
    <div class="button" id="btnJackpot">üé∞ Jackpot</div>
    <div class="button" id="btnStreak">üé≤ Lucky Streak</div>
    <div class="button" id="btnPoker">üÉè Poker</div>
    <div class="button" id="btnAllNothing">üé≤ All or Nothing</div>
	<div class="button" id="btnRoulette">üé° Roulette</div>
    <div class="button" id="btnEventCards">üé¥ Ereigniskarten</div>
    <div class="button" id="btnInventory">üéí Inventar</div>
    <div class="button" id="btnArtefaktum">üóø Artefaktum</div>
  `;

  if (!settings.externalRoll) {
    html += `<div class="button" id="btnBattle">‚öîÔ∏è Battle</div>`;
  }

  const app = document.getElementById("app-section");
  if (app) app.innerHTML = html;

  // Sicheres Binden: nur wenn Ziel wirklich eine Funktion ist
  const bind = (id, fn) => {
    const el = document.getElementById(id);
    if (el && typeof fn === "function") el.addEventListener("click", fn);
  };

  bind("btnRoulette", window.startRoulette);
  bind("btnLotto",      window.startLotto);
  bind("btnAuction",    window.startAuction);
  bind("btnJackpot",    window.startJackpot);
  bind("btnStreak",     window.startStreak);
  bind("btnPoker",      window.startPoker);
  bind("btnAllNothing", window.startAllNothing);
  bind("btnEventCards", window.startEventCardDraw);
  bind("btnInventory",  window.showInventory);   // ‚Üê existiert jetzt sicher (eigene Funktion anlegen)
  if (!settings.externalRoll) bind("btnBattle",  window.startBattle);
  bind("btnArtefaktum", window.startArtefaktum);
}

// global verf√ºgbar machen
window.showHome = showHome;

// global machen
window.showHome = showHome;

// global machen (falls woanders √ºberschrieben wurde)
window.showHome = showHome;

function renderPlayerInventories() {
  let html = "<h2>üéí Inventar</h2>";

  playerNames.forEach((name, idx) => {
    const cards = playerHands[idx] || [];
    let cardHtml = "";

    if (cards.length === 0) {
      cardHtml = "<div class='small'>Keine Karten</div>";
    } else {
      cardHtml = cards.map((c, i) => `
        <div class="inv-card">
          ${c.text}
          <button onclick="playEventCard(${idx}, ${i})">Spielen</button>
        </div>
      `).join("");
    }

    html += `
      <div class="inventory">
        <b>${name}</b>
        <div class="inv-cards">${cardHtml}</div>
      </div>
    `;
  });

  return html;
}

// === Ereigniskarten ===
// Kategorien:
//   - mode: "instant" ‚Üí sofort ausspielen
//   - mode: "inventory" ‚Üí muss ins Inventar gelegt werden
//   - mode: "both" ‚Üí Spieler darf w√§hlen (sofort oder ins Inventar)

const EVENT_CARDS = [
  { text: "Du erh√§ltst +5 ‚Ç¨", mode: "instant" },
  { text: "Du erh√§ltst +10 ‚Ç¨", mode: "instant" },
  { text: "Du erh√§ltst +15 ‚Ç¨", mode: "instant" },
  { text: "Du erh√§ltst +20 ‚Ç¨", mode: "instant" },
  { text: "Du erh√§ltst +25 ‚Ç¨", mode: "instant" },
  { text: "Du verlierst ‚Äì5 ‚Ç¨", mode: "instant" },
  { text: "Du verlierst ‚Äì10 ‚Ç¨", mode: "instant" },
  { text: "Du verlierst ‚Äì15 ‚Ç¨", mode: "instant" },
  { text: "Du verlierst ‚Äì20 ‚Ç¨", mode: "instant" },
  { text: "Du verlierst ‚Äì25 ‚Ç¨", mode: "instant" },
  { text: "Erhalte 1 Troph√§e", mode: "instant" },
  { text: "Erhalte 2 Troph√§en (selten)", mode: "instant" },
  { text: "Stehle 1 Troph√§e von einem Mitspieler", mode: "instant" },
  { text: "Du musst 1 Troph√§e an einen Mitspieler abgeben", mode: "instant" },
  { text: "Dein n√§chster Wurf wird verdoppelt", mode: "instant" },
  { text: "Setze eine Runde aus", mode: "instant" },
  { text: "Erhalte einen Extra-Zug", mode: "instant" },

  { text: "1 Runde unbesiegbar gegen Knockback", mode: "both" },
  { text: "1 Runde sicher vor Diebstahl", mode: "both" },
  { text: "2 Runden sicher vor Knockback", mode: "both" },
  { text: "2 Runden sicher vor Diebstahl", mode: "both" },
  { text: "Dein Inventar kann nicht beklaut werden", mode: "both" },
  { text: "Das Museum kann nicht ausgeraubt werden", mode: "both" },

  { text: "Erhalte 20 Gratis-Lose im Lotto", mode: "inventory" },

  { text: "Erhalte ein Knockback-Upgrade", mode: "instant" },
  { text: "W√§hle einen Spieler, der 1 Runde aussetzt", mode: "instant" },
  { text: "Tausche deine Position mit einem Mitspieler", mode: "instant" },
  { text: "Tausche eine Ereigniskarte mit einem Mitspieler", mode: "instant" },
  { text: "Gib 10 ‚Ç¨ einem Mitspieler und erhalte daf√ºr 1 Troph√§e von ihm", mode: "instant" },
  { text: "Ziehe sofort eine zweite Ereigniskarte", mode: "instant" },
  { text: "W√ºrfle: gerade = +30 ‚Ç¨, ungerade = ‚Äì30 ‚Ç¨", mode: "instant" },
  { text: "Risiko-Karte: Verdopple deinen n√§chsten Gewinn oder Verlust", mode: "instant" },
  { text: "Bestimme, wer der n√§chste Spieler ist", mode: "instant" },
  { text: "W√§hle, ob ein Mitspieler 10 ‚Ç¨ bekommt oder verliert", mode: "instant" },
  { text: "Alle Spieler w√ºrfeln: kleinste Zahl verliert 5 ‚Ç¨ an jeden", mode: "instant" },
  { text: "Mini-Steuer: alle Spieler geben dir 5 ‚Ç¨", mode: "instant" },
  { text: "Zwangsspende: du gibst allen Spielern 5 ‚Ç¨", mode: "instant" },
  { text: "Goldregen: jeder +10 ‚Ç¨, du +20 ‚Ç¨", mode: "instant" },
  { text: "Schwarzer Tag: jeder ‚Äì5 ‚Ç¨, du ‚Äì10 ‚Ç¨", mode: "instant" },
  { text: "Tausche deinen W√ºrfel mit dem linken Nachbarn", mode: "instant" },
  { text: "Stehle 1 Ereigniskarte von einem Mitspieler", mode: "instant" },
  { text: "Blockiere 1 Ereigniskarte eines Mitspielers", mode: "instant" },
  { text: "Gib 1 Troph√§e ab an einen Mitspieler", mode: "instant" },
  { text: "Dein Knockbackstick verliert ein Upgrade", mode: "instant" }
];

function startEventCardDraw() {
  currentContext = "eventcard";
  pendingEventCard = null;
  ensureEventSystemReady();

  const options = playerNames.map((n,i)=>`<option value="${i}">${n}</option>`).join("");

  document.getElementById("app-section").innerHTML = `
    <div class="auction-header">
      <div class="auction-title">üé¥ Ereigniskarte ziehen</div>
      <div class="icon-btn" onclick="showHome()">‚úñ</div>
    </div>

    <div style="text-align:center;">
      <div class="small">W√§hle einen Spieler:</div>
      <select id="eventPlayer" onchange="enableEventDrawBtn()">
        <option value="" disabled selected>Bitte w√§hlen</option>
        ${options}
      </select>
      <div style="margin-top:12px;">
        <div id="eventDrawBtn" class="button disabled" onclick="confirmEventDraw()"
             style="pointer-events:none;opacity:0.6;">
          Karte ziehen
        </div>
      </div>
      <div id="eventCardResult"></div>
    </div>
  `;
}

function enableEventDrawBtn() {
  const sel = document.getElementById("eventPlayer");
  const btn = document.getElementById("eventDrawBtn");
  if (!sel || !btn) return;
  const ok = sel.value !== "";
  btn.classList.toggle("disabled", !ok);
  btn.style.pointerEvents = ok ? "auto" : "none";
  btn.style.opacity = ok ? "1" : "0.6";
}

// === State ===
let playerHands = [];        // Inventar pro Spieler
let pendingEventCard = null; // gerade gezogene Karte

// Karten mischen
function shuffleEventCards() {
  for (let i = EVENT_CARDS.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [EVENT_CARDS[i], EVENT_CARDS[j]] = [EVENT_CARDS[j], EVENT_CARDS[i]];
  }
}

// N√§chste Karte erzeugen (inkl. eindeutiger ID)
function randomEventCard() {
  const base = EVENT_CARDS[Math.floor(Math.random() * EVENT_CARDS.length)];
  return { ...base, _uid: Math.random().toString(36).slice(2) + Date.now().toString(36) };
}

// H√§nde initialisieren
function initDeck() {
  playerHands = playerNames.map(() => []);
}

// Immer sicherstellen, dass H√§nde passen
function ensureEventSystemReady() {
  if (!Array.isArray(playerHands) || playerHands.length !== playerNames.length) {
    const old = Array.isArray(playerHands) ? playerHands : [];
    playerHands = playerNames.map((_, i) => old[i] || []);
  }
}

// Karte ziehen
function drawEventCard(playerIdx, returnOnly = false) {
  const card = randomEventCard();
  if (returnOnly) return card;

  if (card.mode === "instant") {
    resolveEventCard(card, playerIdx);
  } else if (card.mode === "inventory") {
    if (!playerHands[playerIdx]) playerHands[playerIdx] = [];
    playerHands[playerIdx].push(card);
  } else if (card.mode === "both") {
    pendingEventCard = card; // Spieler darf w√§hlen im UI
  }
  return card;
}

function showInventory() {
  currentContext = "inventory";
  ensureEventSystemReady();

  const app = document.getElementById("app-section");
  if (!app) return;

  app.innerHTML = `
    <div class="auction-header">
      <div class="auction-title">üß≥ Inventar</div>
      <div class="icon-btn" onclick="showHome()">‚úñ</div>
    </div>
    ${renderPlayerInventories()}
  `;
}
window.showInventory = showInventory; // global verf√ºgbar machen

// UI: Karte zeigen nach Ziehen
function confirmEventDraw() {
  const sel = document.getElementById("eventPlayer");
  const idx = Number(sel && sel.value);
  if (isNaN(idx)) return;

  ensureEventSystemReady();

  // üëâ Nur VORSCHAU: Karte ziehen, aber NICHT ins Inventar legen und NICHT loggen
  const card = drawEventCard(idx, true); // returnOnly = true  -> keine Seiteneffekte
  pendingEventCard = card;

  let html = `
    <div style="font-size:1.4em;margin-top:12px;">${playerNames[idx]} zieht:</div>
    <div class="card-preview">${card.text}</div>
  `;

  if (card.mode === "instant") {
    html += `
      <div class="small">(Sofortkarte ‚Äì muss direkt eingesetzt werden)</div>
      <div class="button" onclick="playEventCardImmediate(${idx})">Jetzt ausf√ºhren</div>
    `;
  } else if (card.mode === "inventory") {
    html += `
      <div class="small">(Inventarkarte ‚Äì wird gesichert)</div>
      <div class="button" onclick="keepEventCard(${idx})">Sichern</div>
    `;
  } else if (card.mode === "both") {
    html += `
      <div class="small">(Kann sofort gespielt oder ins Inventar gelegt werden)</div>
      <div class="button" onclick="playEventCardImmediate(${idx})">Jetzt ausf√ºhren</div>
      <div class="button" onclick="keepEventCard(${idx})">Behalten</div>
    `;
  }

  const box = document.getElementById("eventCardResult");
  if (box) box.innerHTML = html;

  // ‚õîÔ∏è KEIN eventLog hier ‚Äì erst beim tats√§chlichen Einl√∂sen
}

// Karte sofort ausf√ºhren
function playEventCardImmediate(playerIdx) {
  if (!pendingEventCard) return;
  const card = pendingEventCard;
  pendingEventCard = null;

  // üëâ Jetzt WIRKLICH einl√∂sen (hier wird geloggt)
  resolveEventCard(card, playerIdx);

  const target = document.getElementById("eventCardResult");
  if (target) {
    target.innerHTML = `
      <div style="margin-top:15px;color:#006080;font-weight:600;">
        üéØ Karte wurde ausgespielt.
      </div>
    `;
  }
}

// Karte ins Inventar legen
function keepEventCard(playerIdx) {
  if (!pendingEventCard) return;
  ensureEventSystemReady();

  // üëâ Nur ins Inventar legen ‚Äì KEIN Log!
  if (!playerHands[playerIdx]) playerHands[playerIdx] = [];
  playerHands[playerIdx].push(pendingEventCard);
  pendingEventCard = null;

  const target = document.getElementById("eventCardResult");
  if (target) {
    target.innerHTML = `
      <div style="margin-top:15px;color:#0b7a28;font-weight:600;">
        ‚úÖ Karte wurde ins Inventar gelegt.
      </div>
      <div style="margin-top:20px;">
        <div class="button" onclick="showInventory()">üéí Inventar √∂ffnen</div>
      </div>
    `;
  }
}

// Karte aus Inventar spielen
function playEventCard(playerIdx, cardIdx) {
  const card = (playerHands[playerIdx] || []).splice(cardIdx, 1)[0];
  if (!card) return;
  resolveEventCard(card, playerIdx);
  showInventory();
}

// Effekte (Platzhalter ‚Äì hier kannst du deine Logik einbauen)
function resolveEventCard(card, playerIdx) {
  // 1) Basics
  const player = (playerNames && playerNames[playerIdx]) ? playerNames[playerIdx] : "Spieler";
  const now    = new Date();

  // 2) Ereignis im Verlauf loggen (mit Typ "card") + speichern
  try {
    if (typeof addEventLog === "function") {
      // Einheitliche zentrale Logging-Funktion (beschriftet & speichert)
      addEventLog({
        player: player,
        kind:   "card",                     // ‚Üê WICHTIG: damit showEventLog korrekt labelt
        text:   String(card && card.text ? card.text : ""),
        time:   now.toLocaleTimeString()
      });
    } else {
      // Fallback: direkt ins Array + optional speichern
      window.eventLog = Array.isArray(window.eventLog) ? window.eventLog : [];
      window.eventLog.unshift({
        player: player,
        kind:   "card",                     // ‚Üê WICHTIG
        text:   String(card && card.text ? card.text : ""),
        time:   now.toLocaleTimeString()
      });
      if (typeof saveEventLog === "function") {
        try { saveEventLog(); } catch (e) { /* noop */ }
      } else {
        // Minimaler Fallback: selbst persistieren (ohne Gr√∂√üenlimit)
        try { localStorage.setItem("eventLog", JSON.stringify(window.eventLog)); } catch (e) {}
      }
    }
  } catch (e) {
    console.warn("Ereigniskarte konnte nicht geloggt werden:", e);
  }

  // 3) Effekte der Karte anwenden (hier deine Game-Logik einbauen ‚Äì Beispiele/Platzhalter)
  try {
    const text = String(card && card.text ? card.text : "");

    // Beispielhafte, einfache Muster ‚Äì passe das an deine Regeln an:
    if (/erh√§ltst\s*\+?(\d+)\s*‚Ç¨/i.test(text)) {
      const amount = parseInt(RegExp.$1, 10);
      // TODO: Guthaben des Spielers um 'amount' erh√∂hen
    } else if (/verlierst\s*[-‚Äì‚Äî]?\s*(\d+)\s*‚Ç¨/i.test(text)) {
      const amount = parseInt(RegExp.$1, 10);
      // TODO: Guthaben des Spielers um 'amount' verringern
    } else if (/Erhalte\s*(\d+)\s*Troph√§/i.test(text)) {
      const n = parseInt(RegExp.$1, 10) || 1;
      if (typeof awardTrophies === "function") {
        try { awardTrophies(player, n); } catch (e) {}
      }
    } else if (/Erhalte\s*1\s*Troph√§/i.test(text)) {
      if (typeof awardTrophies === "function") {
        try { awardTrophies(player, 1); } catch (e) {}
      }
    }

    // ggf. weitere Karten-Typen hier behandeln ‚Ä¶

  } catch (e) {
    console.warn("Karten-Effekt konnte nicht angewendet werden:", e);
  }
}

function showSettings() {
  currentContext = "settings";

  document.getElementById("app-section").innerHTML = `
    <div class="settings-section">
      <!-- Header -->
      <div class="auction-header">
        <div class="auction-title">‚öôÔ∏è Einstellungen</div>
        <div class="icon-btn" onclick="closeSettings()" title="Zur√ºck">‚úñ</div>
      </div>

      <!-- Dark Mode -->
      <div class="settings-row">
        <label for="darkMode">Dark Mode:</label>
        <label class="switch">
          <input type="checkbox" id="darkMode" onchange="toggleDarkMode(this.checked)">
          <span class="track"></span>
        </label>
      </div>

      <div style="display:flex; gap:10px; flex-wrap:wrap; margin:12px 0 6px 0;">
        <button class="btn btn-action" onclick="goRoundsMenu()">üìã Runden-Men√º</button>
        <button class="btn danger btn-action" onclick="endGameFromSettings()">‚õî Spiel beenden</button>
      </div>

      <!-- Extern w√ºrfeln -->
      <div class="settings-row">
        <label for="externalRoll">Extern w√ºrfeln:</label>
        <label class="switch">
          <input type="checkbox" id="externalRoll"
                 ${settings.externalRoll ? "checked" : ""}
                 onchange="toggleExternalRoll(this.checked)">
          <span class="track" data-on="an" data-off="aus"></span>
        </label>
      </div>

      <!-- Dev-Modus -->
      <div class="settings-row">
        <label for="devMode">Dev-Modus:</label>
        <label class="switch">
          <input type="checkbox" id="devMode"
                 ${settings.devMode ? "checked" : ""}
                 onchange="toggleDevMode(this.checked)">
          <span class="track" data-on="an" data-off="aus"></span>
        </label>
      </div>

      <!-- Direkt zum Home-Screen (nur sichtbar, wenn Dev an) -->
      <div class="settings-row" id="directHomeRow" style="display:${settings.devMode ? "flex" : "none"};">
        <label for="directHome">Direkt zum Home-Screen:</label>
        <label class="switch">
          <input type="checkbox" id="directHome"
                 ${settings.directHome ? "checked" : ""}
                 onchange="toggleDirectHome(this.checked)">
          <span class="track" data-on="an" data-off="aus"></span>
        </label>
      </div>

      <!-- Aktionen -->
      <div style="margin-top:18px;">
        <div class="button" onclick="managePlayers()">üë• Spieler verwalten</div>
      </div>

      <div style="margin-top:12px;">
        <div class="button" onclick="openStatistics()">üìä Statistik</div>
      </div>

      <div style="margin-top:12px;">
        <div class="button" onclick="showEventLog()">üìú Ereignisverlauf</div>
      </div>
    </div>
  `;
}

function toggleDevMode(checked) {
  settings.devMode = !!checked;
  saveSettings();
  showSettings(); // zeigt/verbirgt Direct-Home-Zeile sofort
}


function toggleDarkMode(checked) {
  settings.darkMode = !!checked;
  saveSettings();
  applyTheme();
  // speichern in D1
  try { persistRuntimeToGame(); } catch {}
}

function toggleDirectHome(checked) {
  settings.directHome = !!checked;
  saveSettings();
}

function toggleExternalRoll(checked) {
  settings.externalRoll = !!checked;
  saveSettings();
  // kein showHome() -> kein Teleport
}

/* ===== Settings: Kontext merken + Snapshots ===== */
window._settingsPrevContext = window._settingsPrevContext || "home";

function openSettings() {
  // Herkunft merken
  const ctx = (typeof currentContext === "string" && currentContext) ? currentContext : "home";
  window._settingsPrevContext = ctx;

  /* üÉè Poker ‚Äì Snapshot */
  if (ctx === "poker" && window.pokerState) {
    window._pokerSnapshot = JSON.parse(JSON.stringify(window.pokerState));
  } else {
    window._pokerSnapshot = null;
  }

  /* üé¥ Ereigniskarten ‚Äì Snapshot */
  if (ctx === "eventcard") {
    const sel = document.getElementById("eventPlayer");
    const res = document.getElementById("eventCardResult");
    const btn = document.getElementById("eventDrawBtn");
    window._eventcardSnapshot = {
      selected:  sel ? sel.value : "",
      resultHTML: res ? res.innerHTML : "",
      btnEnabled: btn ? !btn.classList.contains("disabled") : false,
      pending:   (typeof pendingEventCard === "object" && pendingEventCard)
                   ? JSON.parse(JSON.stringify(pendingEventCard))
                   : null
    };
  } else {
    window._eventcardSnapshot = null;
  }

  /* ‚öñÔ∏è All or Nothing ‚Äì Snapshot */
  if (ctx === "allnothing") {
    const sel = document.getElementById("aonPlayer");
    const res = document.getElementById("allnothingResult");
    const tro = document.getElementById("allnothingTrophy");
    window._aonSnapshot = {
      selected:  sel ? sel.value : "",
      resultHTML: res ? res.innerHTML : "",
      trophyHTML: tro ? tro.innerHTML : ""
    };
  } else {
    window._aonSnapshot = null;
  }

  /* üé≤ Lucky Streak ‚Äì Snapshot */
  if (ctx === "streak" && typeof window.streakState === "object" && window.streakState) {
    window._streakSnapshot = JSON.parse(JSON.stringify(window.streakState));
  } else {
    window._streakSnapshot = null;
  }

  /* üé∞ Jackpot ‚Äì Snapshot */
  if (ctx === "jackpot") {
    window._jackpotSnapshot = {
      bet:   document.getElementById("jackpotBet")?.value || "",
      roll:  document.getElementById("jackpotRoll")?.value || "",
      pSel:  document.getElementById("jackpotPlayer")?.value || "",
      res:   document.getElementById("jackpotResult")?.innerHTML || "",
      err:   document.getElementById("jackpotErr")?.innerHTML || ""
    };
  } else {
    window._jackpotSnapshot = null;
  }

  currentContext = "settings";
  showSettings();
}

/** ===== Einstellungen schlie√üen ‚Äì exakt zum gemerkten Screen zur√ºck ===== */
function closeSettings() {
  const prev = window._settingsPrevContext || "home";
  window._settingsPrevContext = null;   // Reset f√ºr den n√§chsten Durchlauf
  currentContext = prev;

  /* üÉè Poker: nie neu starten ‚Äì Snapshot rendern */
  if (prev === "poker") {
    if (window._pokerSnapshot) {
      window.pokerState = window._pokerSnapshot;
      window._pokerSnapshot = null;
    }
    if (typeof renderPokerUI === "function") renderPokerUI();
    else if (typeof startPoker === "function") startPoker();
    return;
  }

  /* üé¥ Ereigniskarten: UI + Snapshot zur√ºckspielen */
  if (prev === "eventcard") {
    startEventCardDraw(); // Basis-UI
    if (window._eventcardSnapshot) {
      const snap = window._eventcardSnapshot;

      const sel = document.getElementById("eventPlayer");
      if (sel && snap.selected) sel.value = snap.selected;

      if (typeof enableEventDrawBtn === "function") enableEventDrawBtn();

      const res = document.getElementById("eventCardResult");
      if (res && snap.resultHTML) res.innerHTML = snap.resultHTML;

      if (snap.pending) pendingEventCard = snap.pending;

      const btn = document.getElementById("eventDrawBtn");
      if (btn) {
        if (snap.btnEnabled) {
          btn.classList.remove("disabled");
          btn.style.pointerEvents = "auto";
          btn.style.opacity = "1";
        } else {
          btn.classList.add("disabled");
          btn.style.pointerEvents = "none";
          btn.style.opacity = "0.6";
        }
      }
      window._eventcardSnapshot = null;
    }
    return;
  }

  /* ‚öñÔ∏è All or Nothing: UI + Snapshot zur√ºckspielen */
  if (prev === "allnothing") {
    startAllNothing();
    if (window._aonSnapshot) {
      const snap = window._aonSnapshot;

      const sel = document.getElementById("aonPlayer");
      if (sel && snap.selected) sel.value = snap.selected;

      const res = document.getElementById("allnothingResult");
      if (res && snap.resultHTML) res.innerHTML = snap.resultHTML;

      const tro = document.getElementById("allnothingTrophy");
      if (tro && snap.trophyHTML) tro.innerHTML = snap.trophyHTML;

      window._aonSnapshot = null;
    }
    return;
  }

  /* üé≤ Lucky Streak: Zustand zur√ºck, NICHT neu starten */
  if (prev === "streak") {
    if (window._streakSnapshot) {
      window.streakState = window._streakSnapshot;
      window._streakSnapshot = null;
    }
    if (typeof renderStreakUI === "function") renderStreakUI();
    else if (typeof startStreak === "function") startStreak(); // Fallback
    return;
  }

  /* üé∞ Jackpot: UI + Snapshot zur√ºckspielen */
  if (prev === "jackpot") {
    startJackpot(); // Basis-UI
    try {
      const snap = window._jackpotSnapshot;
      if (snap) {
        const sel   = document.getElementById("jackpotPlayer");
        const betEl = document.getElementById("jackpotBet");
        const rolEl = document.getElementById("jackpotRoll");
        const resEl = document.getElementById("jackpotResult");
        const errEl = document.getElementById("jackpotErr");

        if (sel && snap.pSel !== "") sel.value = snap.pSel;
        if (betEl) betEl.value = snap.bet || "";
        if (rolEl) rolEl.value = snap.roll || "";
        if (resEl) resEl.innerHTML = snap.res || "";
        if (errEl) errEl.innerHTML = snap.err || "";
      }
    } catch (e) {
      console.warn("Jackpot restore failed:", e);
    }
    window._jackpotSnapshot = null;
    return;
  }

/* üóø Artefaktum: zur√ºck zum Angebot */
if (prev === "artefaktum") {
  // Angebote sind via window._arteCache 1 Minute gecached,
  // _bought-Status steckt in den Items ‚Äì einfach neu rendern.
  if (typeof startArtefaktum === "function") startArtefaktum();
  else if (window.startArtefaktum) window.startArtefaktum();
  return;
}

  /* üåç Alle anderen Kontexte normal herstellen */
  switch (prev) {
    case "roulette":  startRoulette();  break;
    case "auction":   startAuction();   break;
    case "lotto":     startLotto();     break;
    case "battle":    startBattle();    break;
    case "inventory": showInventory();  break;
    case "eventlog":  showEventLog();   break;
    case "stats":     showStatistics(); break;
    case "home":      showHome();       break;
    default:          showHome();
  }
}

function setTheme(val) {
  console.log("Theme gesetzt auf:", val);
  // hier sp√§ter CSS-Klassen oder Styles wechseln
}

function toggleSound(on) {
  console.log("Soundeffekte:", on ? "An" : "Aus");
  // hier sp√§ter Sounds steuern
}

function setLanguage(lang) {
  console.log("Sprache:", lang);
  // hier sp√§ter Text-Labels austauschen
}

/* ===== Spieler verwalten ===== */
function updateNameCounter(inputId) {
  const input = document.getElementById(inputId);
  const counter = document.getElementById("counter-" + inputId);
  if (input && counter) {
    counter.textContent = `${input.value.length}/20`;
  }
}

function managePlayers() {
  currentContext = "players";
  const listHTML = playerNames.map((name, idx) => `
    <div class="player-row" data-index="${idx}" style="display:flex;align-items:center;gap:6px;">
      <span class="drag-handle" draggable="true" title="Ziehen">‚â°</span>
      <input type="text" id="player${idx}" maxlength="20" value="${name}"
             oninput="updateNameCounter('player${idx}'); renamePlayer(${idx}, this.value)">
      <span id="counter-player${idx}" class="name-counter">${name.length}/20</span>
      <span class="button" style="width:auto;padding:6px 10px;font-size:.9em;" onclick="deletePlayer(${idx})">‚ùå</span>
    </div>
  `).join("");

  document.getElementById("app-section").innerHTML = `
    <div class="lotto-header">
      <div class="lotto-title">üë• Spieler verwalten</div>
      <div class="icon-btn" onclick="showSettings()">‚úñ</div>
    </div>

    <div id="playerList">${listHTML}</div>

	<div class="input-wrap">
	  <input type="text" id="newPlayerName" maxlength="20" placeholder="Neuer Spieler"
			 oninput="updateNameCounter('newPlayerName')">
	  <span id="counter-newPlayerName" class="name-counter">0/20</span>
	</div>
    <div class="button" style="width:200px;margin-top:8px;" onclick="addPlayer()">‚ûï Hinzuf√ºgen</div>
    <div id="playerError" class="error"></div>
  `;

  enablePlayerDragDrop();
}

/**
 * Benennt einen bestehenden Spieler um. Die Eingabe wird getrimmt und
 * gepr√ºft, ob der Name bereits von einem anderen Spieler verwendet wird.
 * Ist der Name bereits vergeben, wird eine Fehlermeldung angezeigt und
 * das Eingabefeld zur√ºck auf den vorherigen Namen gesetzt.
 */
function renamePlayer(idx, newName) {
  const trimmed = newName.trim();
  const errorEl = document.getElementById("playerError");
  // Leere Namen sind nicht erlaubt
  if (trimmed === "") {
    if (errorEl) {
      errorEl.textContent = "Bitte einen Namen eingeben.";
    }
    const input = document.getElementById('player' + idx);
    if (input) {
      input.value = playerNames[idx];
      updateNameCounter('player' + idx);
    }
    return;
  }
  // Pr√ºfe, ob der neue Name bereits an einer anderen Position verwendet wird
  const duplicate = playerNames.some((n, i) => i !== idx && n === trimmed);
  if (duplicate) {
    if (errorEl) {
      errorEl.textContent = `Der Name "${trimmed}" ist bereits vergeben.`;
    }
    // Eingabefeld wieder auf den alten Wert setzen und Z√§hler aktualisieren
    const input = document.getElementById('player' + idx);
    if (input) {
      input.value = playerNames[idx];
      updateNameCounter('player' + idx);
    }
    return;
  }
  // Kein Duplikat: Fehler zur√ºcksetzen und Namen aktualisieren
  if (errorEl) errorEl.textContent = "";
  playerNames[idx] = trimmed;
}

// === Spieler hinzuf√ºgen (REPLACE) ===
function addPlayer() {
  const name = document.getElementById("newPlayerName").value.trim();
  const errorEl = document.getElementById("playerError");
  if (!name) { errorEl.textContent = "Bitte einen Namen eingeben."; return; }
  if (playerNames.includes(name)) { errorEl.textContent = `Der Name "${name}" ist bereits vergeben.`; return; }
  errorEl.textContent = "";

  playerNames.push(name);
  // neue, leere Hand f√ºr den Spieler
  if (!Array.isArray(playerHands)) playerHands = [];
  playerHands.push([]);

  managePlayers();
}

// === Spieler l√∂schen (REPLACE) ===
function deletePlayer(idx) {
  playerNames.splice(idx, 1);
  if (Array.isArray(playerHands)) playerHands.splice(idx, 1);
  managePlayers();
}

function renderHeader(title, context) {
  return `
    <div style="display:flex;align-items:center;justify-content:center;position:relative;">
      <h1 style="flex:1;text-align:center;">${title}</h1>
      <div class="icon-btn" style="position:absolute;right:50px;top:10px;" onclick="showHelp('${context}')">‚ùì</div>
      <div class="icon-btn" style="position:absolute;right:10px;top:10px;" onclick="showSettings()">‚öôÔ∏è</div>
    </div>
  `;
}

function colorfulRouletteWord() {
  const letters = "Roulette".split("");
  const colors = ["red", "black", "green"];
  return letters.map((ch,i)=>{
    const col = colors[i % colors.length];
    return `<span style="color:${col}">${ch}</span>`;
  }).join("");
}

function showHelp(context) {
  let text = "";
  switch (context) {
	case "lotto":
	  text = "üéØ <b>Lotto:</b><br>" +
			"<div style='text-align:left;margin:10px auto;max-width:600px;'>" +
			 "Es werden zuf√§llig <span style='color:#0057d9;font-weight:bold;'>4 Zahlen</span> gezogen.<br>" +
			 "Dann w√ºrfelt <span style='color:#0057d9;font-weight:bold;'>jeder 1x</span>, wenn er am Zug ist, und legt <span style='color:#0b7a28;font-weight:bold;'>1 ‚Ç¨</span> in den Pot.<br>" +
			 " <br>" +
			 "Variante 1: Der Spieler muss eine <span style='color:#0b7a28;font-weight:bold;'>3</span> W√ºrfeln w√ºrfelt aber eine <span style='color:#b00020;font-weight:bold;'>5</span> und schafft es nicht,<br>" +
			 "dann dr√ºckt man auf den button üë§ und die n√§chste Person ist ander reihe.<br>" +
			 " <br>" +
			 "Variante 2: Der Spieler muss eine <span style='color:#0b7a28;font-weight:bold;'>3</span> W√ºrfeln und w√ºrfelt auch die <span style='color:#0b7a28;font-weight:bold;'>3</span><br>" +
			 "Jetzt wird die Zahl abgehackt, in dem man auf sie dr√ºckt<br>" +
			 " <br>" +
			 "Wer die <span style='color:#b00020;font-weight:bold;'>letzte Zahl</span> ankreuzt, gewinnt den Pot.";
	break;
	case "auction":
	  text = "üí∞ <b>Auktion:</b><br>" +
		"<div style='text-align:left;margin:10px auto;max-width:600px;'>" +
		  "Alle Spieler k√∂nnen Gebote abgeben, ohne den Wert des Gewinns zu kennen.<br>" +
		  "Der Geheimwert liegt zuf√§llig zwischen <b>0 ‚Ç¨</b> und <b>200 ‚Ç¨</b>.<br><br>" +
		  "‚û°Ô∏è Der <span class='text-green'>h√∂chstbietende Spieler</span> gewinnt die Auktion.<br>" +
		  "‚û°Ô∏è Erst nach dem Ende wird der Geheimwert aufgedeckt und ausgezahlt." +
		"</div>";
	  break;
	case "battle":
	  text = "‚öîÔ∏è <b>Battle:</b><br>" +
			"<div style='text-align:left;margin:10px auto;max-width:600px;'>" +
			 "Zwei Spieler treten gegeneinander an.<br>" +
			 "Beide w√§hlen einen Einsatz (üí∂) und w√ºrfeln je 1x.<br><br>" +
			 "<b>Modi:</b><br>" +
			 "üî∫ H√∂chste Zahl gewinnt<br>" +
			 "üîª Kleinste Zahl gewinnt<br><br>" +
			 "‚û°Ô∏è Der Gewinner erh√§lt den <span class='text-green'>Einsatz</span> vom Verlierer.";
	  break;
	case "jackpot":
	  text = "üé∞ <b>Jackpot:</b><br>" +
			"<div style='text-align:left;margin:10px auto;max-width:600px;'>" +
			 "Der Spieler setzt einen Einsatz (üí∂).<br>" +
			 "Dann w√ºrfelt er 1x und tr√§gt sein Ergebnis ein.<br><br>" +
			 "<div style='text-align:left;margin:10px auto;max-width:250px;'>" +
			"‚ùå <span style='color:#e53935;'>1</span> = Alles verloren<br>" +
			"üò¨ <span style='color:#fb8c00;'>2</span> = H√§lfte zur√ºck<br>" +
			"üôÇ <span style='color:#1e88e5;'>3</span> = Einsatz zur√ºck<br>" +
			"üéâ <span style='color:#43a047;'>4</span> = 1,5√ó Gewinn<br>" +
			"ü•≥ <span style='color:#2e7d32;'>5</span> = Doppelter Gewinn<br>" +
			"üé≤ <span style='color:#8e24aa;'>6</span> = Nochmal w√ºrfeln!"
			 "</div>";
	  break;
	case "streak":
	  text = "üé≤ <b>Lucky Streak:</b><br>" +
			"<div style='text-align:left;margin:10px auto;max-width:600px;'>" +
			 "Der Spieler w√ºrfelt so lange, bis er stoppt oder verliert.<br><br>" +
			 "Regeln:<br>" +
		  	 "‚ùå <span class='text-red'>1</span> = Alles verloren<br>" +
		  	 "‚úÖ <span class='text-green'>2‚Äì5</span> = +1 ‚Ç¨ (1‚Ç¨ mehr pro Runde)<br><br>" +
		  	 "üò¨ <span class='text-orange'>6</span> = Gewinn halbiert<br>" +
			 "‚û°Ô∏è Nach jedem erfolgreichen Wurf kann man entscheiden: <b>Weiter</b> oder <b>Stopp</b>.";
	  break;
	case "roulette":
	  text = "üé° <b>Roulette:</b><br>" +
		"<div style='text-align:left;margin:10px auto;max-width:600px;'>" +
		  "Man legt seinen Einsatz fest und w√ºrfelt mit dem <b>" + colorfulRouletteWord() + "</b> W√ºrfel, um festzulegen worauf gesetzt werden soll.<br><br>" +
		  "üëâ <u>Auszahlungen:</u><br>" +
		  "üî¢ Zahl 2‚Äì12 = <b>√ó50</b><br>" +
		  "‚ûñ Gerade / „Ä∞Ô∏è Ungerade = <b>√ó2</b><br>" +
		  "üî¥ Rot / ‚ö´ Schwarz = <b>√ó2</b><br>" +
		  "üü¢ Gr√ºn = <b>√ó30</b><br><br>" +
		"</div>";
	  break;
	case "poker":
  text = "üÉè <b>Poker:</b><br>" +
    "<div style='text-align:left;margin:10px auto;max-width:600px;'>" +
      "Jeder Spieler w√ºrfelt <span style='color:#006080;font-weight:bold;'>5√ó mit allen 5 W√ºrfeln</span>.<br>" +
      "Nach jeder Runde wird das Ergebnis in die Tabelle eingetragen.<br><br>" +

      "<span style='color:#2e7d32;font-weight:bold;'>‚úîÔ∏è Jede Kombination</span> darf <b>nur 1√ó</b> gew√§hlt werden.<br>" +
      "<span style='color:#d32f2f;font-weight:bold;'>‚ùå Ausnahme:</span> <span style='color:#000;'>Niete (0 ‚Ç¨)</span> darf bis zu <b>5√ó</b> gew√§hlt werden.<br><br>" +

      "<span style='color:#fbc02d;font-weight:bold;'>‚≠ê Bonus:</span> Wer " +
      "<span style='color:#9c27b0;font-weight:bold;'>5√ó Niete</span> schafft, gewinnt automatisch " +
      "<span style='color:#1e88e5;font-weight:bold;'>200 ‚Ç¨</span>!<br><br>" +

      "<span style='color:#00897b;font-weight:bold;'>‚û°Ô∏è Ende:</span> Nach <b>5 Eintr√§gen</b> ist das Spiel vorbei.<br><br>" +
	  " Der Einsatz betr√§gt <span style='color:#e53935;'><b>50 ‚Ç¨</b></span> wird aber Automatisch abgezogen" +
    "</div>";
  break;
case "allnothing":
  text = "üé≤ <b>All or Nothing:</b><br>" +
    "Du Bezahlst am Anfang 20 ‚Ç¨.<br>" +
    "Dr√ºcke auf <b>All or Nothing</b>:<br>" +
    "‚úÖ Gewinn = 40 ‚Ç¨ Auszahlung<br>" +
    "‚ùå Verlust = 0 ‚Ç¨<br><br>" +
    "Reine 50/50-Chance!";
  break;

case "home":
  text = "üè† <b>Ziel des Spiels:</b><br>" +
    "<div style='text-align:left;margin:10px auto;max-width:600px;'>" +
      "Sammle Geld, setze es in verschiedenen Gl√ºcksspielen ein und sichere dir Troph√§en.<br>" +
      "Mit deinem gewonnenen Geld kannst du Artefakte kaufen und sie zusammen mit deinen gewonnenen Troph√§en zu neuen Statuen craften.<br>" +
      "So entsteht nach und nach dein eigenes Museum.<br><br>" +
      "<b>Das gro√üe Ziel:</b><br>" +
      "Wer es schafft, sein Museum mit allen vier Statuen von der Steintafel zu f√ºllen " +
      "und zus√§tzlich den goldenen W√ºrfel auszustellen, gewinnt das Spiel." +
    "</div>";
  break;

case "settings":
  text = "‚öôÔ∏è <b>Einstellungen:</b><br>" +
    "<div style='text-align:left;margin:10px auto;max-width:600px;'>" +
      "Hier kannst du festlegen, ob du extern w√ºrfeln m√∂chtest oder direkt in der App.<br><br>" +
      "<b>Spieler verwalten:</b><br>" +
      "Alte Spieler l√∂schen, Spieler umbenennen oder neue Spieler anlegen.<br><br>" +
      "<b>Statistik:</b><br>" +
      "Sieh nach, wie oft du in jedem Spiel gespielt hast ‚Äì sowohl in dieser Session als auch insgesamt seit Beginn des Spiels.<br><br>" +
      "<b>Ereignisverlauf:</b><br>" +
      "Hier erkennst du, wer ein Artefakt gekauft oder eine Ereigniskarte gezogen hat.<br>" +
      "Das ist hilfreich, falls du den Effekt einer Karte noch einmal nachlesen m√∂chtest.<br>" +
      "Au√üerdem wird angezeigt, wer eine Troph√§e erhalten hat." +
    "</div>";
  break;

case "eventcard":
  text = "üé¥ <b>Ereigniskarten:</b><br>" +
    "<div style='text-align:left;margin:10px auto;max-width:600px;'>" +
      "Kaufe eine Ereigniskarte f√ºr <b>10 ‚Ç¨</b>. Anschlie√üend ziehst du eine Karte.<br><br>" +
      "üëâ Steht auf der Karte nur der Button <b>‚ÄûJetzt einl√∂sen‚Äú</b>, musst du den Effekt sofort anwenden. " +
      "Im Ereignisverlauf wird angezeigt, welche Karte du eingel√∂st hast.<br><br>" +
      "üëâ Steht auf der Karte nur der Button <b>‚ÄûJetzt sichern‚Äú</b>, kannst du die Karte in dein Inventar legen " +
      "und sie zu einem sp√§teren Zeitpunkt einl√∂sen.<br><br>" +
      "üëâ Sind beide Buttons vorhanden (<b>‚ÄûJetzt einl√∂sen‚Äú</b> und <b>‚ÄûJetzt sichern‚Äú</b>), kannst du selbst entscheiden, " +
      "ob du den Effekt sofort nutzt oder die Karte f√ºr sp√§ter aufbewahrst." +
    "</div>";
  break;

case "inventory":
  text = "üéí <b>Inventar:</b><br>" +
    "<div style='text-align:left;margin:10px auto;max-width:600px;'>" +
      "Hier siehst du alle deine <b>gesicherten Ereigniskarten</b>.<br>" +
      "Du kannst sie jederzeit aus dem Inventar heraus einl√∂sen." +
    "</div>";
  break;

case "artefaktum":
  text = "üóø <b>Artefaktum:</b><br>" +
    "<div style='text-align:left;margin:10px auto;max-width:600px;'>" +
      "Hier kannst du eines oder mehrere der <b>drei angebotenen Artefakte</b> kaufen.<br>" +
      "Jedes Artefakt kostet <b>50 ‚Ç¨</b>.<br><br>" +
      "Die Auswahl an Artefakten <b>wechselt regelm√§√üig</b>, sodass immer neue M√∂glichkeiten entstehen." +
    "</div>";
  break;

    default:
      text = "‚ÑπÔ∏è Keine Hilfe verf√ºgbar.";
  }

  const overlay = document.createElement("div");
  overlay.className = "help-overlay";
  overlay.innerHTML = `
    <div class="help-box">
      <div class="help-header">
        <h2>‚ÑπÔ∏è Spielinformationen</h2>
        <div class="help-close" onclick="closeHelp(this)">‚úñ</div>
      </div>
      <div>${text.replace(/\n/g, "<br>")}</div>
    </div>
  `;
  document.body.appendChild(overlay);
}

function closeHelp(el) {
  document.body.removeChild(el.closest(".help-overlay"));
}

function enablePlayerDragDrop() {
  const list = document.getElementById("playerList");
  let draggingRow = null;

  // Drag nur am Griff starten
  list.querySelectorAll(".drag-handle").forEach(handle => {
    handle.addEventListener("dragstart", e => {
      draggingRow = handle.closest(".player-row");
      e.dataTransfer.effectAllowed = "move";
      e.dataTransfer.setData("text/plain", "drag");
    });
  });

  // Droppen auf Zeilen
  list.querySelectorAll(".player-row").forEach(row => {
    row.addEventListener("dragover", e => e.preventDefault());
    row.addEventListener("drop", e => {
      e.preventDefault();
      if (!draggingRow || draggingRow === row) return;

      const all = Array.from(list.children);
      const from = all.indexOf(draggingRow);
      const to   = all.indexOf(row);
      if (from < to) row.after(draggingRow);
      else row.before(draggingRow);

      // Array entsprechend neu bauen (nach DOM)
      playerNames = Array.from(list.querySelectorAll(".player-row input")).map(inp => inp.value.trim());
      managePlayers();
    });
  });
}

/* ===== Helpers ===== */
function getRandomIntInclusive(min, max) {
  const lo = Math.ceil(min);
  const hi = Math.floor(max);
  return Math.floor(Math.random() * (hi - lo + 1)) + lo;
}

// === Auktion: Chance berechnen anhand der Distanz zum Geheimpreis ===
// Beispiel: secret=40, bid=20  -> |40-20|/40*100 = 50%
//          secret=24, bid=20   -> |24-20|/24*100 ‚âà 16.7%
//          secret=90, bid=20   -> |90-20|/90*100 ‚âà 77.8%
function calcAuctionTrophyChance(bid, secret) {
  const denom = Math.max(1, Number(secret) || 0); // nie durch 0 teilen
  const dist  = Math.abs((Number(secret) || 0) - (Number(bid) || 0));
  const pct   = Math.round((dist / denom) * 100);
  return Math.min(100, Math.max(0, pct));
}

// Lucky Streak ‚Äì Troph√§en-Chance: linear bis 21 ‚Ç¨ (erste Summe > 20 ‚Ç¨)
function streakTrophyChance(finalWin, cap = 21) {
  const w = Math.max(0, Number(finalWin) || 0);
  return Math.round(Math.min(100, (w / cap) * 100));
}

/* === Lucky Streak: Troph√§en nach finalem Gewinn bewerten === */
function streakTrophyOutcome(finalWin, player) {
  const w = Math.max(0, Number(finalWin) || 0);
  // Standard-Text
  let msg = "‚ùå Du hast keine Troph√§e gewonnen.";

  if (w > 20) {
    // Sicher ab > 20 ‚Ç¨
    if (typeof awardTrophies === "function") awardTrophies(player, 1);
    msg = "üèÜ Du hast eine Troph√§e gewonnen.";
  } else if (w > 0) {
    // Linear bis 20 ‚Ç¨ (10 ‚Ç¨ = 50 %, 20 ‚Ç¨ = 100 %)
    const chance = Math.min(100, Math.round((w / 20) * 100));
    if (Math.random() * 100 < chance) {
      if (typeof awardTrophies === "function") awardTrophies(player, 1);
      msg = "üèÜ Du hast eine Troph√§e gewonnen.";
    }
  }
  return msg;
}

// Vergibt ggf. 1 Troph√§e und gibt eine kurze Zeile f√ºrs UI zur√ºck.
// Keine Prozent-Ausgabe.
function maybeAwardStreakTrophy(finalWin, player = (playerNames[0] || "Spieler")) {
  if (finalWin <= 0) return "";           // bei 0 ‚Ç¨ nichts anzeigen

  if (finalWin >= 21) {                   // garantiert ab >20 ‚Ç¨
    awardTrophies(player, 1);
    return "üèÜ Troph√§e erhalten";
  }

  const chance = streakTrophyChance(finalWin, 21);
  if (Math.random() * 100 < chance) {
    awardTrophies(player, 1);
    return "üèÜ Troph√§e erhalten";
  }
  return "‚ùå Keine Troph√§e";
}

// Glatte Kurve f√ºr < 50 ‚Ç¨: bis 25 ‚Ç¨ linear, danach "ease-out" steiler.
// Beispiele: 25‚Ç¨ ‚Üí 50%, 45‚Ç¨ ‚Üí ~99%, 0‚Ç¨ ‚Üí 0%, 50‚Ç¨+ ‚Üí 100%
function trophyChanceByNet(net, cap = 50) {
  const n = Math.max(0, Number(net) || 0);
  if (n <= 0) return 0;
  if (n >= cap) return 100;

  const half = cap / 2; // 25 bei cap=50
  if (n <= half) {
    // 0..25 ‚Ç¨ ‚Üí 0..50 % (linear)
    return Math.round((n / cap) * 100);
  }
  // 25..50 ‚Ç¨ ‚Üí 50..100 % mit Ease-Out (p=3)
  const t = (n - half) / half;            // 0..1
  const eased = 1 - Math.pow(1 - t, 3);   // easeOutCubic
  return Math.min(100, Math.round(50 + 50 * eased));
}

// Vergibt Troph√§en anhand der AUSZAHLUNG (payout), nicht netto.
// Regel: payout >= 50 ‚Ç¨ -> 100% sicher, darunter Kurve (trophyChanceByNet).
function awardTrophiesByBetPayout(game, player, bet, payout) {
  const p = Math.max(0, Number(payout) || 0);

  let drop = 0;
  let chance = trophyChanceByNet(p, 50);

  // Sicher ab 50 ‚Ç¨
  if (p >= 50) {
    drop = 1;
  } else if (p > 0) {
    if (Math.random() * 100 < chance) drop = 1;
  } else {
    chance = 0;
  }

  if (drop > 0) {
    awardTrophies(player, drop);
    // Optional: kurzes Log (falls du das hier m√∂chtest)
    const now = new Date();
    eventLog.unshift({
      player,
      text: `üèÜ ${drop} Troph√§e${drop>1?"n":""} erhalten`,
      time: now.toLocaleTimeString()
    });
  }

  return { drop, chance, payout: p };
}

/* ===== Lotto ===== */
function startLotto() {
  currentContext = "lotto";

  if (!lottoState.active || lottoState.ended) {
    const startIdx = (playerNames && playerNames.length)
      ? getRandomIntInclusive(0, playerNames.length - 1)
      : 0;

    lottoState = {
      numbers: Array.from({ length: 4 }, () => ({
        value: getRandomIntInclusive(1, 6),
        done: false
      })),
      winner: null,
      trophyWon: null,     // <‚Äî NEU: wird am Ende gesetzt (true/false)
      active: true,
      ended: false,
      turnIndex: startIdx,
      activeIdx: 0
    };
  }

  renderLottoUI();
}

function getLastDoneIndex() {
  let last = -1;
  for (let i = 0; i < lottoState.numbers.length; i++) {
    if (lottoState.numbers[i].done) last = i;
  }
  return last;
}

// Einzelne Kachel rendern
function renderTile(num, idx) {
  // Statusklasse ermitteln
  let cls = "open";
  if (num.done) cls = "done";
  else if (idx === lottoState.activeIdx) cls = "active";

  // Klickbarkeit: 
  // - setzen: nur aktive (blaue) offene Zahl
  // - r√ºckg√§ngig: nur zuletzt gesetzte gr√ºne Zahl
  const lastDone = getLastDoneIndex();
  const isClickable =
    (!num.done && idx === lottoState.activeIdx) ||
    (num.done && idx === lastDone);

  const onClick = isClickable ? `onclick="attemptToggle(${idx})"` : "";
  const clickableClass = isClickable ? "clickable" : "";

  return `
    <div class="lotto-tile">
      <div class="lotto-num ${cls} ${clickableClass}" ${onClick}>${num.value}</div>
    </div>
  `;
}

function attemptToggle(idx) {
  if (lottoState.ended) return;

  const n = lottoState.numbers[idx];

  if (!n.done) {
    // √∂ffnen (üî≥ -> ‚úÖ) nur bei aktiver blauer Zahl
    if (idx !== lottoState.activeIdx) return;
    toggleActiveCheck(idx);
    return;
  }

  // r√ºckg√§ngig (‚úÖ -> üî≥) nur bei der zuletzt gesetzten gr√ºnen
  const last = getLastDoneIndex();
  if (idx !== last) return;
  undoLastDone(idx);
}

function renderLottoUI() {
  const app = document.getElementById("app-section");
  if (!app) return;

  // === GEWINN-SCREEN ===
  if (lottoState.winner) {
    const trophyLine =
      lottoState.trophyWon === true
        ? `<p style="margin:4px 0 12px;">üèÖ Du hast eine Troph√§e gewonnen.</p>`
        : `<p style="margin:4px 0 12px;">‚ùå Du hast keine Troph√§e gewonnen.</p>`;

    app.innerHTML = `
      <div class="lotto-area">
        <div class="lotto-header">
          <!-- Links: Neue Runde -->
          <div class="icon-btn" onclick="startLotto()" title="Neue Runde">üîÅ</div>
          <div class="lotto-title">üéØ Lotto</div>
          <!-- Rechts: Schlie√üen -->
          <div class="icon-btn" onclick="showHome()" title="Schlie√üen">‚úñ</div>
        </div>

        <div class="lotto-player" style="margin-top:8px;">${lottoState.winner}</div>
        <p style="margin:6px 0 6px;">gewinnt den Pot! üèÜ</p>
        ${trophyLine}
      </div>
    `;
    return;
  }

  // === LAUFENDE RUNDE ===
  const pn = (playerNames && playerNames.length) ? playerNames : ["Spieler"];
  const currentPlayer = pn[lottoState.turnIndex % pn.length];

  const tiles = lottoState.numbers.map((n, i) => {
    const cls = n.done ? "done" : (i === lottoState.activeIdx ? "active" : "open");
    return `<div class="lotto-num ${cls}" onclick="attemptToggle(${i})">${n.value}</div>`;
  }).join("");

  app.innerHTML = `
    <div class="lotto-area">
      <div class="lotto-header">
        <!-- Links: N√§chster Spieler -->
        <div class="icon-btn" onclick="nextPlayer()" title="N√§chster Spieler">üë§</div>
        <div class="lotto-title">üéØ Lotto</div>
        <!-- Rechts: Schlie√üen -->
        <div class="icon-btn" onclick="showHome()" title="Schlie√üen">‚úñ</div>
      </div>

      <div class="lotto-player">${currentPlayer}</div>
      <div class="lotto-grid">${tiles}</div>
    </div>
  `;
}

function toggleActiveCheck(idx) {
  if (lottoState.ended) return;
  if (idx !== lottoState.activeIdx) return;

  const n = lottoState.numbers[idx];
  if (!n || n.done) return;

  // Zahl setzen
  n.done = true;

  // Pr√ºfen, ob alle gesetzt sind
  const allDone = lottoState.numbers.every(x => x && x.done === true);
  if (allDone) {
    const pn = (playerNames && playerNames.length) ? playerNames : ["Spieler"];
    const winnerName = pn[lottoState.turnIndex % pn.length];

    lottoState.winner = winnerName;
    lottoState.ended = true;

    // 50%-Chance auf Troph√§e
    lottoState.trophyWon = Math.random() < 0.5;

    // Stats/Troph√§en nur ausf√ºhren, wenn vorhanden ‚Äî niemals Spielabbruch
    if (typeof safeIncreaseStat === "function") safeIncreaseStat("lotto");
    else if (typeof increaseStat === "function") { try { increaseStat("lotto"); } catch(e){ console.warn(e); } }

    if (lottoState.trophyWon) {
      if (typeof safeCalcTrophyDrop === "function") safeCalcTrophyDrop("lotto", winnerName);
      else if (typeof calcTrophyDrop === "function") { try { calcTrophyDrop("lotto", winnerName); } catch(e){ console.warn(e); } }
    }

    // Direkt Endscreen rendern
    return renderLottoUI();
  }

  // N√§chster Spieler & n√§chste offene Zahl aktivieren
  const pn = (playerNames && playerNames.length) ? playerNames : ["Spieler"];
  lottoState.turnIndex = (lottoState.turnIndex + 1) % pn.length;

  const nextOpen = lottoState.numbers.findIndex((z, i) => !z.done && i > idx);
  if (nextOpen !== -1) lottoState.activeIdx = nextOpen;

  renderLottoUI();
}

function undoLastDone(idx) {
  // Nur letzte gr√ºne Zahl darf r√ºckg√§ngig sein ‚Äì das ist bereits in attemptToggle gepr√ºft
  const n = lottoState.numbers[idx];
  n.done = false;

  // Aktive (blaue) Zahl wird diese eben ge√∂ffnete Position
  lottoState.activeIdx = idx;

  // KEIN Spielerwechsel beim R√ºckg√§ngig-machen
  renderLottoUI();
}

function checkActive(idx) {
  const activeIdx = lottoState.numbers.findIndex(n => !n.done);
  if (idx !== activeIdx || lottoState.ended) return;

  const n = lottoState.numbers[idx];
  n.done = true;
  n.checkedBy = playerNames[lottoState.turnIndex % playerNames.length];

  if (lottoState.numbers.every(x => x.done)) {
    lottoState.winner = n.checkedBy || "Spieler";
    lottoState.ended = true;
  } else {
    lottoState.turnIndex = (lottoState.turnIndex + 1) % playerNames.length;
  }
  renderLottoUI();
}

function nextPlayer() {
  if (lottoState.ended) return;

  // Wenn die aktuelle Zahl erledigt ist, blau auf die n√§chste offene schieben
  if (lottoState.numbers[lottoState.activeIdx]?.done) {
    const nextOpen = lottoState.numbers.findIndex((z, i) => !z.done && i > lottoState.activeIdx);
    if (nextOpen !== -1) {
      lottoState.activeIdx = nextOpen;
    } else {
      // keine weitere offene Zahl -> ggf. schon als Sieger markiert
      // (falls noch nicht gesetzt, nicht beenden ‚Äì der Haken bestimmt den Sieger)
    }
  }

  // Spieler reihum
  lottoState.turnIndex = (lottoState.turnIndex + 1) % playerNames.length;
  renderLottoUI();
}

// ==== SAFE HELPERS (optional, aber empfohlen) ====
function safeIncreaseStat(mode) {
  try {
    if (typeof increaseStat === "function") increaseStat(mode);
  } catch (e) {
    console.warn("increaseStat() schlug fehl:", e);
  }
}
function safeCalcTrophyDrop(mode, winnerName) {
  try {
    if (typeof calcTrophyDrop === "function") calcTrophyDrop(mode, winnerName);
  } catch (e) {
    console.warn("calcTrophyDrop() schlug fehl:", e);
  }
}

/* ‚Äî Damit showHome/Buttons SICHER dieses Poker verwenden ‚Äî */
window.startPoker = startPoker;

/* ‚Äî Damit showHome/Buttons SICHER dieses Poker verwenden ‚Äî */
window.startPoker = startPoker;

/* ===== Battle (wie gehabt) ===== */
function startBattle() {
  currentContext = "battle";
  document.getElementById("app-section").innerHTML = `
    <div class="auction-header">
      <div class="auction-title">‚öîÔ∏è Battle</div>
      <div class="icon-btn" onclick="showHome()">‚úñ</div>
    </div>

    <div class="battle-wrap">
      <div class="section">
        <div class="row">
          <div style="flex:1;">
            <div class="small">Herausforderer</div>
            <select id="challenger">${playerNames.map(n=>`<option value="${n}">${n}</option>`).join("")}</select>
          </div>
          <div style="flex:1;">
            <div class="small">Gegner</div>
            <select id="opponent">${playerNames.map(n=>`<option value="${n}">${n}</option>`).join("")}</select>
          </div>
        </div>

        <div class="row">
          <div>
            <div class="small">Einsatz</div>
            <label class="input-eur">
              <input type="number" id="wager" min="1" step="1" placeholder="Betrag">
              <span>‚Ç¨</span>
            </label>
          </div>

          <div style="margin-left:auto;">
            <div class="small">Modus</div>
            <div class="row">
              <div id="modeHighest" class="mode-btn active" onclick="setBattleMode('highest')">H√∂chste Zahl</div>
              <div id="modeLowest" class="mode-btn" onclick="setBattleMode('lowest')">Kleinste Zahl</div>
            </div>
          </div>
        </div>

        <div id="battleError" class="error" style="display:none;"></div>
      </div>

      <div class="section">
        <div class="row" style="justify-content:center;">
          <div class="button" id="battleRollBtn" onclick="doBattleAnimated()">W√ºrfeln</div>
        </div>
        <div id="battleOutcome" style="margin-top:10px;"></div>
      </div>
    </div>
  `;
}

function setBattleMode(mode) {
  battleState.mode = mode;
  const hi = document.getElementById('modeHighest');
  const lo = document.getElementById('modeLowest');
  if (hi && lo) { hi.classList.toggle('active', mode==='highest'); lo.classList.toggle('active', mode==='lowest'); }
}
function showBattleError(msg) {
  const el = document.getElementById('battleError');
  if (!el) return;
  el.textContent = msg || "";
  el.style.display = msg ? 'block' : 'none';
}
function rollDie(max=6) { return Math.floor(Math.random() * max) + 1; }
function doBattle() {
  const challenger = document.getElementById('challenger').value;
  const opponent   = document.getElementById('opponent').value;
  const wager      = Number(document.getElementById('wager').value);
  if (!challenger || !opponent) { showBattleError('Bitte beide Spieler w√§hlen.'); return; }
  if (challenger === opponent)  { showBattleError('Herausforderer und Gegner m√ºssen unterschiedlich sein.'); return; }
  if (!wager || wager <= 0)     { showBattleError('Bitte einen g√ºltigen Einsatz (> 0) eingeben.'); return; }
  showBattleError('');

  const a = rollDie(6), b = rollDie(6);
  let winner = null;
  if (battleState.mode === 'highest') { if (a>b) winner=challenger; else if (b>a) winner=opponent; }
  else { if (a<b) winner=challenger; else if (b<a) winner=opponent; }

  const out = document.getElementById('battleOutcome');
  if (!winner) out.innerHTML = `üé≤ ${challenger} w√ºrfelt <b>${a}</b> | ${opponent} <b>${b}</b><br><span class="small">Unentschieden ‚Äì bitte nochmal.</span>`;
  else {
    const loser = (winner===challenger)?opponent:challenger;
    out.innerHTML = `üé≤ ${challenger} w√ºrfelt <b>${a}</b> | ${opponent} <b>${b}</b><br><b>${winner}</b> gewinnt <b>${wager} ‚Ç¨</b> von ${loser}.`;
  }
}

/* ===== Roulette Logik ===== */

function ensureRouletteReady() {
  // Reihenfolge + Segmentgr√∂√üe bereitstellen, falls noch nicht definiert
  if (!window.ROULETTE_ORDER) window.ROULETTE_ORDER = [1,2,3,4,5,6,7,8,9,10,11,12];
  if (!window.ROULETTE_SEG_DEG) window.ROULETTE_SEG_DEG = 360 / window.ROULETTE_ORDER.length;

  // State anlegen, falls noch nicht initialisiert (z. B. wegen fr√ºherem Fehler im Script)
  if (typeof window.rouletteState !== "object" || window.rouletteState === null) {
    window.rouletteState = {
      betType: null,
      betNumber: null,
      stake: null,
      rotation: 0,
      spinning: false,
      stakeSet: false,
      currentPlayerIdx: null,
      _tempBetType: null
    };
  }
}

function startRoulette(){
  ensureRouletteReady();
  currentContext = "roulette";
  document.getElementById("app-section").innerHTML = `
    <div class="auction-header">
      <div class="auction-title">üé° Roulette</div>
      <div class="icon-btn" onclick="showHome()">‚úñ</div>
    </div>

    <div class="roulette-wrap">
      <div id="rouletteWheel" class="roulette-wheel"></div>
      <div id="rouletteBallContainer" class="roulette-ball-container">
        <div id="rouletteBall" class="roulette-ball"></div>
      </div>
    </div>

    <div class="roulette-grid">
      <div id="btnEven"  class="roulette-btn" onclick="rouletteSelect('even')">Gerade</div>
      <div id="btnOdd"   class="roulette-btn" onclick="rouletteSelect('odd')">Ungerade</div>
      <div id="btnRed"   class="roulette-btn" onclick="rouletteSelect('red')">Rot</div>
      <div id="btnBlack" class="roulette-btn" onclick="rouletteSelect('black')">Schwarz</div>

      <div class="roulette-number-green-row">
        <input id="rouletteNumber" type="number" min="1" max="12" step="1"
               placeholder="" oninput="rouletteSetNumber(this.value)">
        <div id="btnNumber" class="roulette-btn" onclick="rouletteSelect('number')">Setzen</div>
        <div id="btnGreen" class="roulette-btn wide" onclick="rouletteSelect('green')">Gr√ºn</div>
      </div>
    </div>

    <div class="action-row">
      <div id="playBtn"  class="roulette-btn disabled" onclick="rouletteSpin()">Spielen</div>
      <div id="stakeBtn" class="roulette-btn" onclick="openStakeModal()">Einsatz</div>
    </div>
    <div id="warnMsg">Du musst zuerst eine Wette setzen und den Einsatz festlegen.</div>

    <!-- Ergebnis-Modal -->
    <div id="resultModal" class="modal-backdrop" style="display:none;">
      <div class="modal">
        <h2 id="resultTitle">Runden-Ergebnis</h2>
        <div id="resultSummary" class="hint" style="margin-top:6px;"></div>
        <div class="modal-actions" style="margin-top:12px;">
          <button class="btn primary" onclick="closeResultModal()">OK</button>
        </div>
      </div>
    </div>

    <!-- Einsatz-Modal -->
    <div id="stakeModal" class="modal-backdrop" style="display:none;">
      <div class="modal">
        <h2>Einsatz w√§hlen</h2>
        <div class="hint">Gib deinen Einsatz (‚â•1 ‚Ç¨) ein.</div>
        <div class="field">
          <label for="stakeInput">Einsatz (‚Ç¨)</label>
          <input id="stakeInput" type="number" min="1" step="1" value="1" />
        </div>
        <div id="modalError" class="error"></div>
        <div class="modal-actions">
          <button class="btn" onclick="closeStakeModal()">Abbrechen</button>
          <button class="btn primary" onclick="submitStake()">Einsatz setzen</button>
        </div>
      </div>
    </div>
  `;

  // State zur√ºcksetzen
  rouletteState.betType = null;
  rouletteState.betNumber = null;
  rouletteState.stake = null;
  rouletteState.rotation = 0;
  rouletteState.spinning = false;
  rouletteState.stakeSet = false;
  rouletteState.currentPlayerIdx = null;
  rouletteState._tempBetType = null;

  renderWheel();
  enablePlayIfReady();
}

/* ===== Roulette: Konstanten & State ===== */
const ROULETTE_ORDER = [1,2,3,4,5,6,7,8,9,10,11,12];
const ROULETTE_SEG_DEG = 360 / ROULETTE_ORDER.length;

function rouletteColor(n){ return n===1 ? 'green' : (n%2===0 ? 'red' : 'black'); }

let rouletteState = {
  betType:null,
  betNumber:null,
  stake:null,
  rotation:0,
  spinning:false,
  stakeSet:false,
  currentPlayerIdx:null,
  _tempBetType:null
};

/* ===== Rad zeichnen ===== */
function renderWheel(){
  const wheel = document.getElementById("rouletteWheel");
  if(!wheel) return;
  const grad = ROULETTE_ORDER.map((n,i)=>{
    const col = rouletteColor(n)==='green' ? '#1eaf5a' : (rouletteColor(n)==='red' ? '#e74c3c' : '#2c3e50');
    const a0 = i * ROULETTE_SEG_DEG;
    const a1 = (i+1) * ROULETTE_SEG_DEG;
    return `${col} ${a0}deg ${a1}deg`;
  }).join(',');
  wheel.style.background = `conic-gradient(${grad})`;

  const START_OFFSET = -90;
  const BORDER = 6, INNER = 6, labelOffset = 26;
  const RADIUS = wheel.clientWidth/2 - BORDER - INNER - labelOffset;

  wheel.innerHTML = ROULETTE_ORDER.map((n,i)=>{
    const mid = (i + 0.5) * ROULETTE_SEG_DEG + START_OFFSET;
    return `<div class="roulette-numlabel"
      style="transform: translate(-50%,-50%) rotate(${mid}deg) translate(${RADIUS}px) rotate(${-mid}deg);">
      ${n}
    </div>`;
  }).join('');
}

/* ===== Helpers ===== */
function getRotationDegrees(el){
  const tr = getComputedStyle(el).getPropertyValue("transform");
  if (tr === "none") return 0;
  const [a,b] = tr.slice(7,-1).split(',').map(parseFloat);
  let angle = Math.round(Math.atan2(b,a) * (180/Math.PI));
  return (angle<0 ? angle+360 : angle);
}
function getResult(ballAngle, wheelAngle){
  let rel = ((ballAngle - wheelAngle + 90) % 360 + 360) % 360;
  const idx = Math.floor(rel / ROULETTE_SEG_DEG);
  return ROULETTE_ORDER[idx];
}
function jackpotTrophyChance(bet, cap = 50) {
  const b = Math.max(0, Number(bet) || 0);
  const pct = Math.round(Math.min(100, (b / cap) * 100));
  return pct;
}

/* ===== Auswahl & UI ===== */
function clearActive(){ document.querySelectorAll('.roulette-btn').forEach(b=>b.classList.remove('active')); }

function enablePlayIfReady(){
  const play = document.getElementById('playBtn');
  const warn = document.getElementById('warnMsg');
  if(!play || !warn) return;

  const numberOk = (rouletteState.betType!=='number') || (rouletteState.betNumber>=1 && rouletteState.betNumber<=12);
  const playerOk = (rouletteState.currentPlayerIdx !== null && rouletteState.currentPlayerIdx >= 0);
  const ready = !!rouletteState.betType && rouletteState.stakeSet && numberOk && playerOk;

  play.classList.toggle('disabled', !ready);
  warn.textContent = ready ? '' : 'Du musst zuerst eine Wette, den Einsatz und den Spieler festlegen.';

  const stakeBtn = document.getElementById("stakeBtn");
  if (stakeBtn) stakeBtn.classList.toggle("active", !!rouletteState.stakeSet);
}

function rouletteSetNumber(v){
  const n = parseInt(v,10);
  if(!isNaN(n)) rouletteState.betNumber = n;
  enablePlayIfReady();
}
function rouletteSelect(type){
  clearActive();
  const idMap = { even:'btnEven', odd:'btnOdd', red:'btnRed', black:'btnBlack', green:'btnGreen', number:'btnNumber' };
  const elId = idMap[type];
  if (elId){ const el = document.getElementById(elId); if(el) el.classList.add('active'); }
  rouletteState.betType = type;
  enablePlayIfReady();
}

/* ===== Modals ===== */
function openStakeModal(){
  const m = document.getElementById('stakeModal');
  if(!m) return;

  const err = document.getElementById('modalError');
  if (err) err.textContent = '';

  let playerRow = document.getElementById('stakePlayerRow');
  if (!playerRow) {
    const modalBox = m.querySelector('.modal');
    const actions  = m.querySelector('.modal-actions');

    playerRow = document.createElement('div');
    playerRow.className = 'field';
    playerRow.id = 'stakePlayerRow';
    playerRow.innerHTML = `
      <label for="stakePlayerSel">Spieler</label>
      <select id="stakePlayerSel"></select>
    `;
    if (modalBox && actions) modalBox.insertBefore(playerRow, actions);
  }

  const sel = document.getElementById('stakePlayerSel');
  if (sel) {
    sel.innerHTML = playerNames
      .map((n,i)=>`<option value="${i}" ${rouletteState.currentPlayerIdx===i?'selected':''}>${n}</option>`)
      .join('');
  }

  m.style.display = 'flex';
  const input = document.getElementById('stakeInput');
  if (input) { input.focus(); input.select(); }
}
function closeStakeModal(){ const m = document.getElementById('stakeModal'); if(m) m.style.display='none'; }
function openResultModal(html, title = "Runden-Ergebnis") {
  const m = document.getElementById('resultModal');
  const t = document.getElementById('resultSummary');
  if(!m || !t) return;
  t.innerHTML = html;
  m.style.display = 'flex';
}
function closeResultModal(){ const m = document.getElementById('resultModal'); if(m) m.style.display='none'; }

function submitStake(){
  const errEl = document.getElementById('modalError');

  const stake = parseInt(document.getElementById('stakeInput').value,10);
  if (isNaN(stake) || stake < 1){
    if (errEl) errEl.textContent = 'Bitte einen Einsatz von mindestens 1 ‚Ç¨ eingeben.';
    return;
  }

  const sel = document.getElementById('stakePlayerSel');
  const idx = sel ? parseInt(sel.value,10) : NaN;
  if (isNaN(idx)) {
    if (errEl) errEl.textContent = 'Bitte einen Spieler ausw√§hlen.';
    return;
  }

  rouletteState.stake = stake;
  rouletteState.stakeSet = true;
  rouletteState.currentPlayerIdx = idx;

  closeStakeModal();
  enablePlayIfReady();
}

function colorDe(c){ return c==='red'?'rot':c==='black'?'schwarz':c==='green'?'gr√ºn':c; }

/* ===== Spin ===== */
async function rouletteSpin(){
  const play = document.getElementById('playBtn');
  if (!play || play.classList.contains('disabled') || rouletteState.spinning) return;

  rouletteState.spinning = true;
  play.classList.add('disabled');

  try {
    const wheel = document.getElementById("rouletteWheel");
    const ballC = document.getElementById("rouletteBallContainer");
    const ball  = document.getElementById("rouletteBall");

    const wheelTarget = rouletteState.rotation + 1080 + Math.random()*360;
    const ballTarget  = Math.random()*360;

    wheel.style.transition = "transform 3s cubic-bezier(.1,.7,.3,1)";
    wheel.style.transform  = `rotate(${wheelTarget}deg)`;

    ballC.style.transition = "transform 3s cubic-bezier(.1,.7,.3,1)";
    ballC.style.transform  = `rotate(${ballTarget}deg)`;

    const radius = (wheel.clientWidth/2) - 20;
    ball.style.transition  = "transform 0.6s cubic-bezier(.2,.8,.2,1)";
    ball.style.transform   = `translate(-50%,-50%) translateX(${radius}px)`;

    rouletteState.rotation = wheelTarget;

    await new Promise(r=>setTimeout(r, 3000));

    const wheelDeg = getRotationDegrees(wheel);
    const ballDeg  = getRotationDegrees(ballC);
    const result   = getResult(ballDeg, wheelDeg);
    const color    = rouletteColor(result);

    const idx = ROULETTE_ORDER.indexOf(result);
    let midAngle = wheelDeg - 90 + (idx + 0.5) * ROULETTE_SEG_DEG;
    const current = getRotationDegrees(ballC);
    while (midAngle - current > 180) midAngle -= 360;
    while (midAngle - current < -180) midAngle += 360;
    ballC.style.transition = "transform 0.25s ease-out";
    ballC.style.transform  = `rotate(${midAngle}deg)`;

    const betTxt = (() => {
      switch(rouletteState.betType){
        case 'odd':   return 'Ungerade';
        case 'even':  return 'Gerade';
        case 'red':   return 'Rot';
        case 'black': return 'Schwarz';
        case 'green': return 'Gr√ºn';
        case 'number':return `Zahl ${rouletteState.betNumber ?? '‚Äî'}`;
        default:      return '‚Äî';
      }
    })();

    const won = (() => {
      if (rouletteState.betType==='number') return result===rouletteState.betNumber;
      if (rouletteState.betType==='green')  return result===1;
      if (rouletteState.betType==='red')    return color==='red';
      if (rouletteState.betType==='black')  return color==='black';
      if (rouletteState.betType==='even')   return result%2===0;
      if (rouletteState.betType==='odd')    return result%2===1;
      return false;
    })();

    const mult = (() => {
      if (rouletteState.betType==='number') return 50;
      if (rouletteState.betType==='green')  return 30;
      if (['red','black','even','odd'].includes(rouletteState.betType)) return 2;
      return 0;
    })();
    const payout = won ? (rouletteState.stake || 0) * mult : 0;

    const player = playerNames[rouletteState.currentPlayerIdx ?? 0] || "Spieler";

    let trophies = 0;
    if (won) {
      if (['even','odd','red','black'].includes(rouletteState.betType)) {
        trophies = 1;
      } else if (rouletteState.betType === 'green' || rouletteState.betType === 'number') {
        trophies = 10;
      }
    }
    if (trophies > 0) awardTrophies(player, trophies);

    await new Promise(r=>setTimeout(r, 3000));
    ball.style.transition = "transform 0.4s cubic-bezier(.33,1,.68,1)";
    ball.style.transform  = "translate(-50%,-50%)";
    await new Promise(r=>setTimeout(r, 450));

    openResultModal(
      `Du hast <b>${result} ${colorDe(color)}</b>.<br>
       <b>Deine Wette:</b> ${betTxt}.<br>
       <b>Spieler:</b> ${player}.<br>
       <b>Einsatz:</b> ${rouletteState.stake}‚Ç¨.<br>
       <b>Auszahlung:</b> ${payout}‚Ç¨.<br>
       <b>Troph√§en:</b> ${trophies > 0 ? 'üèÜ √ó'+trophies : '‚ùå Keine'}`
    );

    if (typeof increaseStat === 'function') increaseStat('roulette');
  } finally {
    rouletteState.spinning = false;
    play.classList.remove('disabled');
    enablePlayIfReady();
  }
}

/* --- Roulette-Handler global machen (f√ºr onclick="...") --- */
window.startRoulette     = startRoulette;
window.rouletteSelect    = rouletteSelect;
window.rouletteSetNumber = rouletteSetNumber;
window.openStakeModal    = openStakeModal;
window.closeStakeModal   = closeStakeModal;
window.submitStake       = submitStake;
window.rouletteSpin      = rouletteSpin;
window.openResultModal   = openResultModal;
window.closeResultModal  = closeResultModal;

/* --- (optional, aber hilfreich) Overlays wegr√§umen --- */
function _killOverlays() {
  try {
    document.querySelectorAll('.modal-backdrop').forEach(el => el.style.display = 'none');
    document.querySelectorAll('.help-overlay').forEach(el => el.remove());
  } catch (e) {
    console.warn("Overlay-Cleanup failed:", e);
  }
}

/* ===== Auction (ohne Geheimwert) ===== */
function startAuction(){
  currentContext = "auction";
  if (auctionState.ended) {
    auctionState = { highestBid: 0, highestBidder: null, bids: [], ended: false,
                     prize: getRandomIntInclusive(0,200) };
  }
  const opts = playerNames.map(n => `<option value="${n}">${n}</option>`).join("");

  document.getElementById("app-section").innerHTML = `
    <div class="auction-area">
      <div class="auction-header">
        <div class="auction-title">üí∞ Auktion</div>
        <div class="icon-btn" onclick="showHome()">‚úñ</div>
      </div>

      <!-- Geheimwert + H√∂chstgebot im gleichen Block -->
      <div id="topBidBox" style="text-align:center;margin-bottom:15px;">
        <div style="font-size:0.95em;color:#555;">
          Geheimwert: <span id="secretValue">? ‚Ç¨</span>
        </div>
        <div style="font-size:2.2em;font-weight:700;">
          <span id="topBidValue">${auctionState.highestBid}</span> ‚Ç¨
        </div>
        <div style="font-size:1.3em;color:#333;" id="topBidder">
          ${auctionState.highestBidder || "‚Äî"}
        </div>
      </div>

      <!-- Gebot abgeben -->
      <div class="bid-row">
        <input type="number" id="bidAmount" min="1" step="1" placeholder="Betrag">
        <select id="bidPlayer">
          <option value="" disabled selected>Spieler</option>
          ${opts}
        </select>
        <div class="button" onclick="placeBid()">Bieten</div>
      </div>
      <div id="bidError" class="error"></div>

      <!-- Verlauf -->
      <div id="bidList" style="margin-top:20px;"></div>

      <!-- Ende -->
      <div style="margin-top:20px;">
        <div class="button" onclick="endAuction()">Auktion beenden</div>
      </div>
      <div id="result" style="margin-top:10px;"></div>
    </div>
  `;

  renderBidList();
}

function showBidError(msg) {
  const el = document.getElementById('bidError');
  if (!el) return;
  el.textContent = msg || "";
  el.style.display = msg ? 'block' : 'none';
}

function placeBid() {
  if (auctionState.ended) return;
  const amount = Number(document.getElementById('bidAmount').value);
  const player = document.getElementById('bidPlayer').value;

  if (!player) { showBidError('Bitte Spieler ausw√§hlen.'); return; }
  if (!amount || amount <= 0) { showBidError('Bitte einen g√ºltigen Betrag eingeben (> 0).'); return; }
  if (amount <= auctionState.highestBid) { showBidError(`Gebot muss gr√∂√üer als ${auctionState.highestBid} ‚Ç¨ sein.`); return; }

  showBidError('');
  auctionState.highestBid = amount;
  auctionState.highestBidder = player;
  auctionState.bids.push({ name: player, amount });

  document.getElementById('bidAmount').value = '';
  updateTopBidDisplay();
  renderBidList();
}

function updateTopBidDisplay() {
  const v = document.getElementById('topBidValue');
  const b = document.getElementById('topBidder');
  if (v) v.textContent = auctionState.highestBid;
  if (b) b.textContent = auctionState.highestBidder || "‚Äî";
}

function renderBidList() {
  const list = document.getElementById('bidList');
  if (!list) return;
  if (auctionState.bids.length === 0) {
    list.innerHTML = `<div class="small">Noch keine Gebote.</div>`;
    return;
  }
  list.innerHTML = auctionState.bids
    .slice().reverse()
    .map(b => `
      <div class="bid-item" style="text-align:center; font-size:1.2em; margin:8px auto; max-width:200px;">
        <div style="font-weight:700;">${b.amount} ‚Ç¨</div>
        <div style="font-size:0.95em; color:#333;">${b.name}</div>
      </div>
    `)
    .join('');
}

function endAuction() {
  if (auctionState.ended) return;
  auctionState.ended = true;

  const winner = auctionState.highestBidder;
  const bid    = auctionState.highestBid;
  const prize  = auctionState.prize;
  const resultEl = document.getElementById('result');

  document.getElementById('secretValue').textContent = prize + " ‚Ç¨";

  if (!winner) {
    resultEl.innerHTML = `<div class="error">Es gibt kein g√ºltiges Gebot. Die Auktion endet ohne Gewinner.</div>`;
    
    openResultModal(resultEl.innerHTML, "Auktion");
    resultEl.innerHTML = "";
return;
  }

  const profit = prize - bid; 
  const profitText = profit >= 0
    ? `Gewinn: <strong>+${profit} ‚Ç¨</strong> üéâ`
    : `Verlust: <strong>${profit} ‚Ç¨</strong> üò¨`;

  // === Troph√§en-Berechnung ===
  // Formel: je n√§her am Preis, desto schlechter die Chance
  let ratio   = Math.min(bid, prize) / Math.max(bid, prize); // 0..1
  let chance  = Math.round((1 - ratio) * 100);               // in %
  let drop    = (Math.random() * 100 < chance) ? 1 : 0;

  if (drop > 0) awardTrophies(winner, drop);

  resultEl.innerHTML = `
    <div><strong>${winner}</strong> hat die Auktion gewonnen.</div>
    <div>Gebot: <b>${bid} ‚Ç¨</b> ¬∑ Geheimer Wert: <b>${prize} ‚Ç¨</b></div>
    <div style="margin-top:8px;">${profitText}</div>
    <div style="margin-top:6px;">
      ${drop>0 ? "üèÜ "+drop+" Troph√§e erhalten" : "‚ùå Keine Troph√§e erhalten"}
    </div>
  `;

  increaseStat("auction");
}

/* ===== Poker (kompletter Block) ===== */

const POKER_BUYIN = 50; // nur Info ‚Äì NICHT abziehen (Buy-in extern)

let pokerState = {
  entries: [],             // gew√§hlte Kategorien (Indices)
  total: 0,                // Gewinn (ohne Buy-in-Abzug)
  ended: false,            // Runde beendet?
  started: false,          // Spieler bereits gew√§hlt?
  currentPlayerIdx: null,  // Index im playerNames-Array
  currentPlayerName: null  // stabiler Name f√ºr Logs/UI
};

const POKER_CATEGORIES = [
  { name: "Niete",           payout: 0,   max: 5 },
  { name: "Kleine Stra√üe",   payout: 10,  max: 1 },
  { name: "Paar",            payout: 10,  max: 1 },
  { name: "Zwei Paare",      payout: 20,  max: 1 },
  { name: "Drilling",        payout: 30,  max: 1 },
  { name: "Full House",      payout: 40,  max: 1 },
  { name: "Gro√üe Stra√üe",    payout: 50,  max: 1 },
  { name: "Vierling",        payout: 60,  max: 1 },
  { name: "F√ºnfling",        payout: 100, max: 1 }
];

/* === Einstieg === */
function startPoker() {
  currentContext = "poker";
  pokerState = {
    entries: [],
    total: 0,
    ended: false,
    started: false,
    currentPlayerIdx: null,
    currentPlayerName: null
  };

  const app = document.getElementById("app-section");
  app.innerHTML = `
    <div class="lotto-header" style="display:grid;grid-template-columns:48px 1fr 48px;align-items:center;">
      <div class="icon-btn" onclick="showHome()" title="Zur√ºck">‚úñ</div>
      <div class="lotto-title">üÉè Poker</div>
      <div class="icon-btn" onclick="showHelp && showHelp('poker')" title="Hilfe">‚ùì</div>
    </div>
    <div class="section" style="text-align:center;margin-top:10px;">
      <div class="small">Bitte Spieler ausw√§hlen‚Ä¶</div>
    </div>
  `;
  openPokerPlayerModal();
}

/* === Rendering === */
function renderPokerUI() {
  const app = document.getElementById("app-section");
  if (!app) return;

  // Endscreen
  if (pokerState.ended) {
    const onlyNiete = pokerState.entries.every(e => POKER_CATEGORIES[e].name === "Niete");
    const total = pokerState.total || 0;
    const player = pokerState.currentPlayerName || playerNames[pokerState.currentPlayerIdx ?? 0] || "Spieler";

    const headline = onlyNiete ? "Alles Niete!" : "Ende der Runde";
    const winLine  = onlyNiete ? `Alles Niete, Gewinn <b>${total} ‚Ç¨</b>` : `Gewinn: <b>${total} ‚Ç¨</b>`;

    app.innerHTML = `
      <div class="lotto-header" style="display:grid;grid-template-columns:48px 1fr 48px;align-items:center;">
        <div class="icon-btn" onclick="startPoker()" title="Neue Runde">üîÅ</div>
        <div class="lotto-title">üÉè Poker</div>
        <div class="icon-btn" onclick="showHome()" title="Zur√ºck">‚úñ</div>
      </div>
      <div class="poker-result" style="text-align:center;">
        <div class="small" style="margin-top:6px;">Spieler: <b>${player}</b></div>
        <div style="font-size:1.6rem;margin:12px 0;">${headline}</div>
        <div style="font-size:1.4rem;margin:8px 0;">${winLine}</div>
        <div style="margin-top:8px;">${pokerState.trophyLine || "‚ùå Du bekommst keine Troph√§e."}</div>
      </div>
    `;
    return;
  }

  // Kein Spieler gew√§hlt
  if (!pokerState.started) {
    app.innerHTML = `
      <div class="lotto-header" style="display:grid;grid-template-columns:48px 1fr 48px;align-items:center;">
        <div class="icon-btn" onclick="showHome()" title="Zur√ºck">‚úñ</div>
        <div class="lotto-title">üÉè Poker</div>
        <div class="icon-btn" onclick="showHelp && showHelp('poker')" title="Hilfe">‚ùì</div>
      </div>
      <div class="section" style="text-align:center;margin-top:10px;">
        <div class="small">Bitte Spieler ausw√§hlen‚Ä¶</div>
        <div class="button" style="width:220px;margin-top:12px;" onclick="openPokerPlayerModal()">Spieler w√§hlen</div>
      </div>
    `;
    return;
  }

  // Laufende Runde
  const player = pokerState.currentPlayerName || playerNames[pokerState.currentPlayerIdx ?? 0] || "Spieler";
  const cats = POKER_CATEGORIES.map((cat, idx) => {
    const usedCount = pokerState.entries.filter(e => e === idx).length;
    const btns = [];
    for (let i = 0; i < cat.max; i++) {
      const checked = i < usedCount;
      const disabled = pokerState.entries.length >= 5 && !checked;
      btns.push(`
        <span class="poker-check ${checked ? "active" : ""}"
              onclick="selectPoker(${idx}, ${i})"
              style="${disabled ? 'pointer-events:none;opacity:.5;' : ''}">
          ${checked ? "‚úÖ" : "üî≥"}
        </span>
      `);
    }
    return `
      <div class="poker-row">
        <span class="poker-name">${cat.name}</span>
        <span class="poker-payout">${cat.payout} ‚Ç¨</span>
        <span class="poker-boxes">${btns.join("")}</span>
      </div>
    `;
  }).join("");

  app.innerHTML = `
    <div class="lotto-header" style="display:grid;grid-template-columns:48px 1fr 48px;align-items:center;">
      <div class="icon-btn" onclick="startPoker()" title="Neue Runde">üîÅ</div>
      <div class="lotto-title">üÉè Poker</div>
      <div class="icon-btn" onclick="showHome()" title="Zur√ºck">‚úñ</div>
    </div>
    <div class="poker-area">${cats}</div>
  `;
}

/* === Modal: Spielerauswahl === */
function openPokerPlayerModal() {
  closePokerPlayerModal();

  const overlay = document.createElement("div");
  overlay.id = "pokerPlayerModal";
  overlay.className = "modal-backdrop";
  overlay.style.display = "flex";
	overlay.innerHTML = `
	  <div class="modal">
		<h2>Spieler w√§hlen</h2>
		<div class="field" style="margin-top:8px;">
		  <label for="pokerPlayerSel">Wer spielt diese Runde?</label>
		  <select id="pokerPlayerSel">
			<option value="" disabled ${pokerState.currentPlayerIdx===null ? "selected" : ""}>Bitte w√§hlen</option>
			${playerNames.map((n,i)=>`<option value="${i}" ${pokerState.currentPlayerIdx===i ? "selected" : ""}>${n}</option>`).join("")}
		  </select>
		</div>
		<div id="pokerPlayerErr" class="error"></div>

		<!-- Buttons in einer Zeile, gleich gro√ü, mittig -->
		<div class="modal-actions" style="justify-content:center; gap:12px;">
		  <button class="btn" style="flex:1; max-width:140px;" onclick="closePokerPlayerModalAndBack()">Abbrechen</button>
		  <button class="btn primary" style="flex:1; max-width:140px;" onclick="confirmPokerPlayerFromModal()">Runde starten</button>
		</div>
	  </div>
	`;
  document.body.appendChild(overlay);

  const sel = document.getElementById("pokerPlayerSel");
  if (sel) sel.focus();
}
function closePokerPlayerModal(){ const m=document.getElementById("pokerPlayerModal"); if(m) m.remove(); }
function closePokerPlayerModalAndBack(){ closePokerPlayerModal(); if(!pokerState.started) showHome(); }
function confirmPokerPlayerFromModal(){
  const sel = document.getElementById("pokerPlayerSel");
  const err = document.getElementById("pokerPlayerErr");
  const idx = sel ? parseInt(sel.value,10) : NaN;

  if (Number.isNaN(idx)){
    if (err) err.textContent = "Bitte zuerst einen Spieler w√§hlen.";
    return;
  }

  pokerState.currentPlayerIdx  = idx;
  pokerState.currentPlayerName = playerNames[idx] || "Spieler";
  pokerState.started = true;

  closePokerPlayerModal();
  renderPokerUI();
}

/* === Auswahl / Abschluss === */
// KORREKTE Poker-Auswahl: Gewinn ohne Buy-in abziehen + Troph√§e dem gew√§hlten Spieler
function selectPoker(idx, slot) {
  if (pokerState.ended || !pokerState) return;

  const cat = POKER_CATEGORIES[idx];
  const usedCount = pokerState.entries.filter(e => e === idx).length;

  // Ein-/Aushaken pro Kategorie
  if (cat.max === 1) {
    if (usedCount) {
      const pos = pokerState.entries.indexOf(idx);
      if (pos !== -1) pokerState.entries.splice(pos, 1);
    } else {
      pokerState.entries.push(idx);
    }
  } else {
    // Mehrfachkategorie (Niete) sequentiell
    if (slot === usedCount) {
      if (usedCount < cat.max) pokerState.entries.push(idx);
    } else if (slot === usedCount - 1) {
      const pos = pokerState.entries.lastIndexOf(idx);
      if (pos !== -1) pokerState.entries.splice(pos, 1);
    }
  }

  // Ende nach 5 Eintr√§gen
  if (pokerState.entries.length === 5) {
    const onlyNiete = pokerState.entries.every(e => POKER_CATEGORIES[e].name === "Niete");
    const gross = onlyNiete
      ? 200
      : pokerState.entries.map(i => POKER_CATEGORIES[i].payout).reduce((a, b) => a + b, 0);

    // WICHTIG: Buy-in NICHT abziehen ‚Äì Gewinn wird vollst√§ndig angezeigt
    pokerState.total = gross;
    pokerState.ended = true;

    // Statistik (best effort)
    try { if (typeof increaseStat === "function") increaseStat("poker"); } catch {}

    // Den GEW√ÑHLTEN Spieler zuverl√§ssig ermitteln
    const player =
      pokerState.currentPlayerName ||
      (Number.isInteger(pokerState.currentPlayerIdx) ? playerNames[pokerState.currentPlayerIdx] : null) ||
      "Spieler";

    // Troph√§en-Logik:
    // >= 50 ‚Ç¨ => garantiert 1 Troph√§e
    // < 50 ‚Ç¨  => Chance = round(gross/50 * 100)
    let gotTrophy = false;
    if (gross >= 50) {
      try { awardTrophies(player, 1); gotTrophy = true; } catch {}
    } else if (gross > 0) {
      const chance = Math.round((gross / 50) * 100);
      if (Math.random() * 100 < chance) {
        try { awardTrophies(player, 1); gotTrophy = true; } catch {}
      }
    }

    // Optional: kurze Trophy-Zeile in den State, falls du sie im UI zeigen willst
    pokerState.trophyLine = gotTrophy ? "üèÜ Troph√§e erhalten" : "‚ùå Keine Troph√§e";
  }

  renderPokerUI();
}

/* === Hilfe-Text (optional im Help-Overlay) === */
function getPokerHelpText() {
  return `
    <div style='text-align:left;max-width:600px;margin:10px auto;'>
      Jeder Spieler w√ºrfelt <b>5√ó mit allen 5 W√ºrfeln</b> und w√§hlt pro Runde eine Kombination aus.
      <br><br>‚úîÔ∏è Jede Kombi 1√ó, <b>Niete</b> bis zu 5√ó (sequentiell).
      <br><br><b>Bonus:</b> 5√ó Niete ergibt automatisch <b>200 ‚Ç¨ Gewinn</b>.
      <br><br><b>Buy-in:</b> ${POKER_BUYIN} ‚Ç¨ (extern ‚Äì wird nicht abgezogen).
      <br><br><b>Troph√§en:</b> >50 ‚Ç¨ garantiert, sonst Gewinn/50 % Chance.
    </div>`;
}

/* === Globals/Exports === */
window.startPoker = startPoker;
window.openPokerPlayerModal = openPokerPlayerModal;
window.closePokerPlayerModalAndBack = closePokerPlayerModalAndBack;
window.confirmPokerPlayerFromModal = confirmPokerPlayerFromModal;
window.selectPoker = selectPoker;

/* ===== Lucky Streak ===== */
window.streakState = window.streakState || {
  win: 0,
  steps: 0,
  ended: false,
  started: false,
  currentPlayerIdx: null,
  currentPlayerName: null
};

function startStreak(reset = true) {
  currentContext = "streak";

  if (reset) {
    resetStreakState();
  } else {
    // Falls was fehlt, sicherstellen
    streakState = Object.assign({
      win: 0, steps: 0, ended: false, started: false,
      currentPlayerIdx: null, currentPlayerName: null
    }, streakState || {});
  }

  // Wenn noch kein Spieler gew√§hlt: gleich das Popup √∂ffnen
  if (!streakState.started) {
    renderStreakUI();       // Basis UI (Header, Hintergrund)
    openStreakPlayerModal();// Popup direkt √∂ffnen
  } else {
    renderStreakUI();       // normale UI
  }
}

function resetStreakState() {
  streakState = {
    win: 0,
    steps: 0,
    ended: false,
    started: false,
    currentPlayerIdx: null,
    currentPlayerName: null
  };
}

function renderStreakUI() {
  const app = document.getElementById("app-section");
  if (!app) return;

  // Spieler noch nicht gew√§hlt
  if (!streakState.started) {
    app.innerHTML = `
      <div class="lotto-header">
        <div class="icon-btn" onclick="showHome()" title="Zur√ºck">‚úñ</div>
        <div class="lotto-title">üé≤ Lucky Streak</div>
        <div class="icon-btn" onclick="showHelp && showHelp('streak')" title="Hilfe">‚ùì</div>
      </div>
      <div class="section" style="text-align:center;margin-top:10px;">
        <div class="small">Bitte Spieler ausw√§hlen‚Ä¶</div>
      </div>
    `;
    return;
  }

  // Runde l√§uft / beendet
  const win   = streakState.win ?? 0;
  const steps = streakState.steps ?? 0;
  const next  = streakState.ended ? null : (win + (steps + 1));
  const player = streakState.currentPlayerName || playerNames[streakState.currentPlayerIdx ?? 0] || "Spieler";

  app.innerHTML = `
    <div class="lotto-header">
      <div class="icon-btn" onclick="startStreak()" title="Neue Runde">üîÅ</div>
      <div class="lotto-title">üé≤ Lucky Streak</div>
      <div class="icon-btn" onclick="showHome()" title="Zur√ºck">‚úñ</div>
    </div>

      <div style="font-size:2.2em;font-weight:700;margin:6px 0 14px;">
        Aktueller Gewinn:
        <span id="streakWin">${win} ‚Ç¨</span>
        ${streakState.ended ? "" : `<span id="streakNext" class="small" style="font-weight:600;"> ‚û°Ô∏è ${next} ‚Ç¨</span>`}
      </div>

      <div style="display:flex;gap:12px;justify-content:space-between;align-items:center;max-width:360px;margin:0 auto 10px;">
        <div id="btnStreak1" class="button" style="width:100px;" onclick="handleStreakRoll(1)">1</div>
        <div id="btnStreak2to5" class="button" style="width:100px;" onclick="handleStreakRoll('2-5')">2‚Äì5</div>
        <div id="btnStreak6" class="button" style="width:100px;" onclick="handleStreakRoll(6)">6</div>
      </div>

      <div class="button" style="width:240px;" onclick="endStreak()">Stopp</div>

      <div id="streakResult" style="margin-top:14px;font-size:1.1em;"></div>
    </div>
  `;

  if (streakState.ended) setStreakButtonsDisabled(true);
}

/* === Modal: Spielerwahl (wie Poker) === */
function openStreakPlayerModal() {
  closeStreakPlayerModal();

  const overlay = document.createElement("div");
  overlay.id = "streakPlayerModal";
  overlay.className = "modal-backdrop";
  overlay.style.display = "flex";
  overlay.innerHTML = `
    <div class="modal">
      <h2>Spieler w√§hlen</h2>
      <div class="field">
        <label for="streakPlayerSel">Wer spielt diese Runde?</label>
        <select id="streakPlayerSel">
          <option value="" disabled ${streakState.currentPlayerIdx===null ? "selected" : ""}>Bitte w√§hlen</option>
          ${playerNames.map((n,i)=>`<option value="${i}" ${streakState.currentPlayerIdx===i ? "selected" : ""}>${n}</option>`).join("")}
        </select>
      </div>
      <div id="streakPlayerErr" class="error"></div>

      <!-- exakt wie Poker -->
      <div class="modal-actions centered">
        <button class="btn equal" onclick="closeStreakPlayerModalAndBack()">Abbrechen</button>
        <button class="btn primary equal" onclick="confirmStreakPlayerFromModal()">Runde starten</button>
      </div>
    </div>
  `;
  document.body.appendChild(overlay);

  const sel = document.getElementById("streakPlayerSel");
  if (sel) sel.focus();
}

function closeStreakPlayerModal(){ const m=document.getElementById("streakPlayerModal"); if(m) m.remove(); }
function closeStreakPlayerModalAndBack(){ closeStreakPlayerModal(); if(!streakState.started) showHome(); }
function confirmStreakPlayerFromModal(){
  const sel = document.getElementById("streakPlayerSel");
  const err = document.getElementById("streakPlayerErr");
  const idx = sel ? parseInt(sel.value,10) : NaN;

  if (Number.isNaN(idx)){
    if (err) err.textContent = "Bitte zuerst einen Spieler w√§hlen.";
    return;
  }

  streakState.currentPlayerIdx  = idx;
  streakState.currentPlayerName = playerNames[idx] || "Spieler";
  streakState.started = true;

  closeStreakPlayerModal();
  renderStreakUI();
}

/* === Spiel-Logik === */
function handleStreakRoll(type) {
  if (streakState.ended) return;
  const out = document.getElementById("streakResult");
  if (out) out.innerHTML = "";

  const player =
    streakState.currentPlayerName ||
    playerNames[streakState.currentPlayerIdx ?? 0] ||
    "Spieler";

  if (type === 1) {
    // ‚ùå 1 = Alles verloren
    streakState.win = 0;
    streakState.ended = true;
    if (typeof increaseStat === "function") increaseStat("streak");

    const winEl = document.getElementById("streakWin");
    if (winEl) winEl.textContent = `${streakState.win} ‚Ç¨`;

    if (out) {
      out.innerHTML =
        `‚ùå 1 gew√ºrfelt ‚Äì alles verloren!<br>` +
        `Spieler: <b>${player}</b>`;
    }
  }
  else if (type === "2-5") {
    // ‚úÖ 2‚Äì5 = +1 ‚Ç¨, progressiv
    streakState.steps = (streakState.steps || 0) + 1;
    streakState.win   = (streakState.win   || 0) + streakState.steps;

    const winEl  = document.getElementById("streakWin");
    const nextEl = document.getElementById("streakNext");
    if (winEl)  winEl.textContent  = `${streakState.win} ‚Ç¨`;
    if (nextEl) nextEl.textContent = ` ‚û°Ô∏è ${streakState.win + (streakState.steps + 1)} ‚Ç¨`;
    return; // Runde l√§uft weiter
  }
  else if (type === 6) {
    // üò¨ 6 = Gewinn halbiert + Runde endet
    streakState.win   = Math.floor((streakState.win || 0) / 2);
    streakState.ended = true;
    if (typeof increaseStat === "function") increaseStat("streak");

    const winEl = document.getElementById("streakWin");
    if (winEl) winEl.textContent = `${streakState.win} ‚Ç¨`;

    // üèÜ Troph√§e pr√ºfen nach neuer Regel
    const trophyMsg = streakTrophyOutcome(streakState.win, player);

    if (out) {
      out.innerHTML =
        `üò¨ 6 gew√ºrfelt ‚Äì Gewinn halbiert.<br>` +
        `üèÅ Auszahlung: <b>${streakState.win} ‚Ç¨</b><br>` +
        `${trophyMsg}<br>` ;
    }
  }

  if (streakState.ended) {
    const nextEl = document.getElementById("streakNext");
    if (nextEl) nextEl.remove();
    setStreakButtonsDisabled(true);
  }
}

function endStreak() {
  if (streakState.ended) return;
  streakState.ended = true;
  if (typeof increaseStat === "function") increaseStat("streak");

  const player = streakState.currentPlayerName
    || playerNames[streakState.currentPlayerIdx ?? 0]
    || "Spieler";

  // ‚úÖ Troph√§e anhand des finalen Gewinns pr√ºfen
  const trophyMsg = streakTrophyOutcome(streakState.win, player);

  const out = document.getElementById("streakResult");
  if (out) {
    out.innerHTML =
      `Auszahlung: <b>${streakState.win} ‚Ç¨</b><br>` +
      `${trophyMsg}<br>`;
  openResultModal(resHtml, "Lucky Streak");
  out.innerHTML = "";
}
  const nextEl = document.getElementById("streakNext");
  if (nextEl) nextEl.remove();
  setStreakButtonsDisabled(true);
}

function setStreakButtonsDisabled(disabled) {
  ["btnStreak1", "btnStreak2to5", "btnStreak6"].forEach(id => {
    const el = document.getElementById(id);
    if (!el) return;
    el.style.opacity = disabled ? "0.6" : "1";
    el.style.pointerEvents = disabled ? "none" : "auto";
  });
}

/* Exporte, damit showHome-Bindings sicher funktionieren */
window.startStreak = startStreak;
window.openStreakPlayerModal = openStreakPlayerModal;
window.confirmStreakPlayerFromModal = confirmStreakPlayerFromModal;

/* ===== Jackpot ===== */
function startJackpot() {
  currentContext = "jackpot";

  const playerOpts = (playerNames || []).map((n, i) => `<option value="${i}">${n}</option>`).join("");

  document.getElementById("app-section").innerHTML = `
    <div class="auction-header">
      <div class="auction-title">üé∞ Jackpot</div>
      <div class="icon-btn" onclick="showHome()">‚úñ</div>
    </div>

    <div class="section" style="text-align:center;">
      <div class="row" style="justify-content:center; gap:14px; flex-wrap:wrap;">
        <div>
          <div class="small">Spieler</div>
          <select id="jackpotPlayer">
            <option value="" disabled selected>Bitte w√§hlen</option>
            ${playerOpts}
          </select>
        </div>

        <div>
          <div class="small">Einsatz (‚Ç¨)</div>
          <input type="number" id="jackpotBet" min="1" step="1" placeholder="Einsatz ‚Ç¨">
        </div>

        <div>
          <div class="small">W√ºrfel (1‚Äì6)</div>
          <input type="number" id="jackpotRoll" min="1" max="6" step="1"
                 placeholder="W√ºrfel (1-6)" oninput="limitRoll(this)">
        </div>
      </div>

      <div id="jackpotErr" class="error" style="margin-top:6px;"></div>

      <div class="button" onclick="evaluateJackpot()">Auswerten</div>
      <div id="jackpotResult" style="margin-top:16px;font-size:1.2em;"></div>
    </div>
  `;
}

/** Abrunden zugunsten der Bank (immer nach unten) */
function bankFloor(x) {
  return Math.floor(Number(x) || 0);
}

function evaluateJackpot() {
  const errEl = document.getElementById("jackpotErr");
  const outEl = document.getElementById("jackpotResult");
  if (errEl) errEl.textContent = "";
  if (outEl) outEl.textContent = "";

  const pIdx = parseInt((document.getElementById("jackpotPlayer") || {}).value, 10);
  const bet  = parseInt((document.getElementById("jackpotBet") || {}).value, 10);
  const roll = parseInt((document.getElementById("jackpotRoll") || {}).value, 10);

  if (Number.isNaN(pIdx)) { if (errEl) errEl.textContent = "Bitte einen Spieler w√§hlen."; return; }
  if (!bet || bet < 1)     { if (errEl) errEl.textContent = "Bitte g√ºltigen Einsatz (‚â• 1 ‚Ç¨) eingeben."; return; }
  if (!roll || roll < 1 || roll > 6) { if (errEl) errEl.textContent = "W√ºrfelzahl muss 1‚Äì6 sein."; return; }

  const player = playerNames[pIdx] || "Spieler";

  // Payout nach deinen Regeln
  let payout = 0;
  let line   = "";

  switch (roll) {
    case 1:
      payout = 0;
      line = "Alles verloren.";
      break;
    case 2:
      payout = bankFloor(bet / 2);
      line = `H√§lfte zur√ºck ‚Äì ${payout} ‚Ç¨ von ${bet} ‚Ç¨.`; 
      break;
    case 3:
      payout = bet;
      line = `Einsatz zur√ºck ‚Äì ${payout} ‚Ç¨.`;
      break;
    case 4:
      payout = bankFloor(bet * 1.5);
      line = `√ó1,5 ‚Äì Auszahlung ${payout} ‚Ç¨.`;
      break;
    case 5:
      payout = bet * 2;
      line = `Doppelgewinn ‚Äì Auszahlung ${payout} ‚Ç¨.`;
      break;
    case 6:
      if (outEl) {
        outEl.innerHTML = `Du hast eine <b>6</b> eingetragen. üé≤ Bitte <b>nochmal w√ºrfeln</b> und die neue Zahl eintragen.`;
      
  openResultModal(outEl.innerHTML, "Jackpot");
  outEl.innerHTML = "";
}
      return;
  }

  const net = Math.max(0, payout - bet);

  // Statistik (best effort)
  try { if (typeof increaseStat === "function") increaseStat("jackpot"); } catch {}

  // Troph√§en ‚Äì nur bei positivem Netto-Gewinn
  let trophyText = "‚ùå Du hast keine Troph√§e erhalten.";
  if (net > 0) {
    let res = null;
    if (typeof awardTrophiesByBetPayout === "function") {
      try {
        res = awardTrophiesByBetPayout("jackpot", player, bet, payout);
      } catch {}
    } else if (typeof awardTrophies === "function") {
      // Fallback: tats√§chliche Vergabe (einfach 1) ‚Äì dein awardTrophies schreibt ins Ereignis-Log
      try { awardTrophies(player, 1); res = { drop: 1, chance: 100, net }; } catch {}
    }

    // Anzeige je nach R√ºckgabe
    if (res && typeof res.drop === "number") {
      trophyText = res.drop > 0 ? "üèÜ Du hast eine Troph√§e erhalten." : "‚ùå Du hast keine Troph√§e erhalten.";
    } else {
      // Falls keine Info zur√ºckkam: bei positivem Netto konservativ davon ausgehen, dass evtl. vergeben wurde
      // (nur Anzeige ‚Äì die echte Vergabe passiert in den Funktionen oben)
      trophyText = "üèÜ Du hast eine Troph√§e erhalten.";
    }
  }

  if (outEl) {
    outEl.innerHTML = `
      Spieler: <b>${player}</b><br>
      Gew√ºrfelt: <b>${roll}</b><br>
      ${line}<br>
      <div style="margin-top:8px;">${trophyText}</div>
    `;
  }
}

/* ===== Statistik-Navigation (zur√ºck zur Quelle) ===== */
window._statsPrevContext = window._statsPrevContext || null;

function openStatistics() {
  // merken, woher wir Statistik √∂ffnen (Settings, Home, ‚Ä¶)
  window._statsPrevContext = typeof currentContext === "string" ? currentContext : "home";
  showStatistics();
}

function closeStatistics() {
  // wenn Statistik aus Settings kam -> zur√ºck zu Settings
  const prev = window._statsPrevContext || "home";
  window._statsPrevContext = null;

  if (prev === "settings" && typeof showSettings === "function") {
    currentContext = "settings";
    showSettings();
  } else {
    // sonst normal nach Home
    currentContext = "home";
    showHome();
  }
}

function limitRoll(input) {
  let val = parseInt(input.value, 10);
  if (isNaN(val)) return;
  if (val > 6) input.value = 6;
  if (val < 1) input.value = 1;
}

function streakIncrease() {
  if (streakState.ended) return;
  streakState.steps += 1;     // ‚Äûkein 1er gew√ºrfelt‚Äú
  renderStreakUI();
}

function streakLoseAll() {
  if (streakState.ended) return;
  streakState.ended = true;   // ‚Äû1 gew√ºrfelt‚Äú
  streakState.payout = 0;
  renderStreakUI();
}

function streakCashOut(amount) {
  if (streakState.ended) return;
  streakState.ended = true;
  streakState.payout = Number(amount) || 0;
  renderStreakUI();
}

// === App-Start (REPLACE WHOLE onload) ===
window.onload = async () => {
  try {
    // erst D1 laden
    cloudData = await apiGetLucky();
    if (!cloudData) return;
  } catch (e) {
    console.error("LuckyCube load failed", e);
    cloudData = { currentId:null, order:[], games:{}, lastPlayerCount:"" };
  }

  // Wenn es ein aktuelles Spiel gibt, in Runtime laden
  if (cloudData.currentId && cloudData.games && cloudData.games[cloudData.currentId]) {
    const g = ensureGame(cloudData.currentId);
    loadGameToRuntime(g);
  }

  applyTheme();

  // Start immer im Runden-Men√º (wie gew√ºnscht: Runden sichtbar nach Reload)
  renderRoundsMenu();
};

// Unicode-Faces: ‚öÄ ‚öÅ ‚öÇ ‚öÉ ‚öÑ ‚öÖ
const DICE_CHARS = ['‚öÄ','‚öÅ','‚öÇ','‚öÉ','‚öÑ','‚öÖ'];

/**
 * Animiert einen W√ºrfel √ºber den Bildschirm und liefert die zuf√§llige Endzahl (1‚Äì6).
 * Nutzung: const n = await rollDiceAnimation();  // n = 1..6
 */
function rollDiceAnimation(options = {}) {
  return new Promise(resolve => {
    const final = getRandomIntInclusive(1, 6);
    const duration = options.duration || getRandomIntInclusive(900, 1400); // ms
    const startSide = Math.random() < 0.5 ? 'left' : 'right';
    const startX = (startSide === 'left') ? -100 : (window.innerWidth + 100);
    const endX = window.innerWidth / 2 - 40; // W√ºrfelmitte ungef√§hr in Screenmitte
    const y = getRandomIntInclusive(Math.floor(window.innerHeight * 0.25),
                                    Math.floor(window.innerHeight * 0.65));

    // W√ºrfel erzeugen
    const dice = document.createElement('div');
    dice.className = 'dice-el';
    dice.textContent = DICE_CHARS[0];
    document.body.appendChild(dice);

    // Faces schnell durchbl√§ttern
    const faceTimer = setInterval(() => {
      dice.textContent = DICE_CHARS[getRandomIntInclusive(0, 5)];
    }, 70);

    let startTime = null;
    const totalRot = (startSide === 'left' ? 1 : -1) * 720; // 2 Umdrehungen

    function frame(ts) {
      if (!startTime) startTime = ts;
      const t = (ts - startTime) / duration;
      const p = Math.min(1, t);
      // EaseOutCubic
      const ease = 1 - Math.pow(1 - p, 3);
      // Position + Rotation
      const x = startX + (endX - startX) * ease;
      const rot = totalRot * ease;
      dice.style.transform = `translate(${x}px, ${y}px) rotate(${rot}deg)`;

      if (p < 1) {
        requestAnimationFrame(frame);
      } else {
        // Stopp: endg√ºltiges Face zeigen + kleines ‚ÄûSettle‚Äú
        clearInterval(faceTimer);
        dice.textContent = DICE_CHARS[final - 1];
        dice.style.transition = 'transform 280ms ease-out';
        dice.style.transform = `translate(${endX + (startSide==='left'?10:-10)}px, ${y}px) rotate(${totalRot + (startSide==='left'?10:-10)}deg)`;
        setTimeout(() => {
          dice.style.transform = `translate(${endX}px, ${y}px) rotate(${totalRot}deg)`;
          setTimeout(() => { dice.remove(); resolve(final); }, 260);
        }, 60);
      }
    }
    requestAnimationFrame(frame);
  });
}

let _battleRolling = false;

function setBattleControlsDisabled(disabled) {
  const btn = document.getElementById('battleRollBtn');
  if (btn) {
    btn.style.opacity = disabled ? '0.6' : '1';
    btn.style.pointerEvents = disabled ? 'none' : 'auto';
  }
}

function showBattleError(msg) {
  const el = document.getElementById('battleError');
  if (!el) return;
  el.textContent = msg || "";
  el.style.display = msg ? 'block' : 'none';
}

async function doBattleAnimated() {
  if (_battleRolling) return;

  const challenger = document.getElementById('challenger').value;
  const opponent   = document.getElementById('opponent').value;
  const wager      = Number(document.getElementById('wager').value);

  if (!challenger || !opponent) { showBattleError('Bitte beide Spieler w√§hlen.'); return; }
  if (challenger === opponent)  { showBattleError('Herausforderer und Gegner m√ºssen unterschiedlich sein.'); return; }
  if (!wager || wager <= 0)     { showBattleError('Bitte einen g√ºltigen Einsatz (> 0) eingeben.'); return; }
  showBattleError('');

  const out = document.getElementById('battleOutcome');
  _battleRolling = true;
  setBattleControlsDisabled(true);
  try {
    // Erstes Roll (Challenger)
    out.innerHTML = `üé≤ ${challenger} w√ºrfelt...`;
    const a = await rollDiceAnimation();
    out.innerHTML = `üé≤ ${challenger} w√ºrfelt <b>${a}</b>`;

    // kurze Pause
    await new Promise(r => setTimeout(r, 300));

    // Zweites Roll (Opponent)
    out.innerHTML += `<br>üé≤ ${opponent} w√ºrfelt...`;
    const b = await rollDiceAnimation();
    out.innerHTML = `üé≤ ${challenger} w√ºrfelt <b>${a}</b> | ${opponent} <b>${b}</b>`;

    // Auswertung
    let winner = null;
    if (battleState.mode === 'highest') {
      if (a > b) winner = challenger;
      else if (b > a) winner = opponent;
    } else { // 'lowest'
      if (a < b) winner = challenger;
      else if (b < a) winner = opponent;
    }

    if (!winner) {
      out.innerHTML += `<br><span class="small">Unentschieden ‚Äì bitte nochmal.</span>`;
    } else {
      const loser = (winner === challenger) ? opponent : challenger;
      out.innerHTML += `<br><b>${winner}</b> gewinnt <b>${wager} ‚Ç¨</b> von ${loser}.`;
    }
  } finally {
    _battleRolling = false;
    setBattleControlsDisabled(false);
  }
}

<!-- ===== 50-50 ===== -->
let allnothingStats = { win: 0, lose: 0 };
let allnothingState = { playerIdx: null, trophyLine: "" };

function startAllNothing() {
  currentContext = "allnothing";
  const opts = playerNames.map((n, i) => `<option value="${i}">${n}</option>`).join("");

  document.getElementById("app-section").innerHTML = `
    <div class="auction-header">
      <div class="auction-title">üé≤ All or Nothing</div>
      <div class="icon-btn" onclick="showHome()">‚úñ</div>
    </div>

    <div class="allnothing-wrap">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:14px;">
        <div style="text-align:left;">
          <div>‚úÖ Gewonnen: <span id="statWins">${allnothingStats.win}</span></div>
          <div>‚ùå Verloren: <span id="statLoses">${allnothingStats.lose}</span></div>
        </div>
        <div><b>Einsatz: 20 ‚Ç¨</b></div>
      </div>

      <div class="section" style="text-align:center;margin-bottom:8px;">
        <div class="small" style="margin-bottom:6px;">Spieler w√§hlen</div>
        <select id="aonPlayer" onchange="setAonPlayer(this.value)">
          <option value="" disabled selected>Bitte w√§hlen</option>
          ${opts}
        </select>
        <div id="aonErr" class="error" style="margin-top:6px;"></div>
      </div>

      <div class="button" onclick="playAllOrNothing()">‚öñÔ∏è All or Nothing</div>
      <div id="allnothingResult" class="result"></div>
      <div id="allnothingTrophy" class="small" style="margin-top:8px;"></div>
    </div>
  `;
}
function setAonPlayer(v) {
  const idx = parseInt(v, 10);
  allnothingState.playerIdx = Number.isNaN(idx) ? null : idx;
  const err = document.getElementById("aonErr");
  if (err) err.textContent = "";
}

function playAllOrNothing() {
  const resultEl  = document.getElementById("allnothingResult");
  const trophyEl  = document.getElementById("allnothingTrophy");
  const errEl     = document.getElementById("aonErr");

  // Spieler muss gew√§hlt sein
  if (allnothingState.playerIdx === null) {
    if (errEl) errEl.textContent = "Bitte zuerst einen Spieler w√§hlen.";
    return;
  }
  if (errEl) errEl.textContent = "";

  const player = playerNames[allnothingState.playerIdx] || "Spieler";
  const win = Math.random() < 0.5;

  if (win) {
    allnothingStats.win++;
    resultEl.innerHTML = "‚úÖ Gewonnen! Auszahlung: <b>40 ‚Ç¨</b>";
    resultEl.className = "result win animate-pop";

    // wie bei Poker: klare Trophy-Zeile anzeigen
    const info = calcTrophyDrop("allnothing", player, 20, 40);
    allnothingState.trophyLine = info;               // z. B. ‚ÄûüèÜ Spieler erh√§lt 1 Troph√§e‚Äú
    if (trophyEl) trophyEl.textContent = info;
  } else {
    allnothingStats.lose++;
    resultEl.innerHTML = "‚ùå Verloren! Keine Auszahlung.";
    resultEl.className = "result lose animate-pop";

    // bei Verlust keine Trophy (explizit anzeigen ‚Äì ‚Äûwie bei Poker‚Äú)
    allnothingState.trophyLine = "‚ùå Keine Troph√§e erhalten";
    if (trophyEl) trophyEl.textContent = allnothingState.trophyLine;
  }

  increaseStat("allnothing");
  document.getElementById("statWins").textContent  = allnothingStats.win;
  document.getElementById("statLoses").textContent = allnothingStats.lose;
  setTimeout(() => resultEl.classList.remove("animate-pop"), 500);
}

// Statistik-Objekt global
let stats = {
  lotto:        { total: 0, session: 0 },
  auction:      { total: 0, session: 0 },
  jackpot:      { total: 0, session: 0 },
  streak:       { total: 0, session: 0 },
  roulette:     { total: 0, session: 0 },
  poker:        { total: 0, session: 0 },
  allnothing:   { total: 0, session: 0 }
};

// === nur Gesamt in localStorage speichern ===
function saveStats() {
  const totalOnly = {};
  for (let key in stats) {
    totalOnly[key] = { total: stats[key].total };  // Session wird NICHT gespeichert
  }
  localStorage.setItem("stats", JSON.stringify(totalOnly));
}

function loadStats() {
  const s = localStorage.getItem("stats");
  if (s) {
    const totalOnly = JSON.parse(s);
    for (let key in stats) {
      if (totalOnly[key]) stats[key].total = totalOnly[key].total;
      stats[key].session = 0; // immer neu anfangen
    }
  }
}
loadStats();

// Statistik erh√∂hen
function increaseStat(game) {
  if (!stats[game]) return;
  stats[game].total++;
  stats[game].session++;
  saveStats();
}

// === Troph√§en Drop ===
let trophyStats = { total: 0, session: 0 };

function saveTrophies() {
  localStorage.setItem("trophyStats", JSON.stringify({ total: trophyStats.total }));
}
function loadTrophies() {
  const t = localStorage.getItem("trophyStats");
  if (t) {
    const d = JSON.parse(t);
    trophyStats.total = d.total || 0;
  }
  trophyStats.session = 0;
}
loadTrophies();

function awardTrophies(player, amount) {
  if (amount <= 0) return;
  trophyStats.total += amount;
  trophyStats.session += amount;
  saveTrophies?.();

  // korrekt loggen + speichern
  if (typeof logTrophies === "function") {
    logTrophies(player || "Spieler", amount);
  } else {
    addEventLog({ player: player || "Spieler", kind:"trophy", text: `${amount} Troph√§e${amount>1?"n":""}` });
  }
}

/**
 * Berechnet die Dropchance und vergibt Troph√§en
 * @param {string} game - Spielname ("lotto","auction","jackpot","streak","poker","allnothing","roulette")
 * @param {string} player - Spielername
 * @param {number} bet - Einsatz (‚Ç¨)
 * @param {number} win - Gewinn (‚Ç¨)
 * @param {object} extra - Zusatzinfos (z.B. {rolledSix:true, betType:"green"})
 */
 
function calcTrophyDrop(game, player, bet=0, win=0, extra={}) {
  let trophies = 0;
  let chance = 0;

  switch(game) {
    case "lotto":
      chance = 50;
      break;

    case "auction":
      if (win > 0) chance = ((win - bet) / win) * 100;
      break;

    case "jackpot":
      chance = Math.min(100, win);
      if (win > 50) trophies++;
      break;

    case "streak":
      let finalWin = extra.rolledSix ? Math.floor(win/2) : win;
      chance = Math.min(100, finalWin);
      if (finalWin > 50) trophies++;
      break;

    case "poker":
      chance = Math.min(100, win);
      if (win > 50) trophies++;
      break;

    case "allnothing":
      chance = 50; 
      break;

    case "roulette":
      if (extra.betType === "green") { trophies += 5; break; }
      if (extra.betType === "number") { trophies += 3; break; }
      chance = 50 + Math.min(50, bet);
      break;
  }

  if (Math.random() * 100 < chance) trophies++;

  if (trophies > 0) {
    awardTrophies(player, trophies);
    return `üèÜ ${player} erh√§lt ${trophies} Troph√§e${trophies>1?"n":""}`;
  } else {
    return `‚ùå ${player} hat keine Troph√§en erhalten`;
  }
}

/* Sch√∂ne Labels wie am Home-Bildschirm */
const GAME_LABEL = {
  lotto:      "üéØ Lotto",
  auction:    "üí∞ Auktion",
  jackpot:    "üé∞ Jackpot",
  streak:     "üé≤ Lucky Streak",
  roulette:   "üé° Roulette",
  poker:      "üÉè Poker",
  allnothing: "‚öñÔ∏è All or Nothing"   // <‚Äî korrekter Name
};
function gameLabel(key){ return GAME_LABEL[key] || key; }

function showStatistics() {
  currentContext = "stats";

  let rows = Object.keys(stats).map(game => {
    return `
      <tr>
        <td>${gameLabel(game)}</td>
        <td>${stats[game].session}</td>
        <td>${stats[game].total}</td>
      </tr>
    `;
  }).join("");

  document.getElementById("app-section").innerHTML = `
    <div class="auction-header">
      <div class="auction-title">üìä Statistik</div>
      <div class="icon-btn" onclick="showSettings()">‚úñ</div>
    </div>

    <div class="panel stats-section">
      <table class="stats-table">
        <tr>
          <th>Spiel</th>
          <th>Diese Session</th>
          <th>Gesamt</th>
        </tr>
        ${rows}
      </table>
    </div>
  `;
}

/* =========================
   Ereignis-Log: Anzeige
   ========================= */
function showEventLog(){
  currentContext = "eventlog";
  const esc = s => String(s ?? "")
    .replace(/&/g,"&amp;").replace(/</g,"&lt;")
    .replace(/>/g,"&gt;").replace(/"/g,"&quot;")
    .replace(/'/g,"&#039;");

  const labelOf = k =>
      k==="card"   ? "üé¥ Ereigniskarte" :
      k==="shop"   ? "üóø Artefaktum"    :
      k==="trophy" ? "üèÜ Troph√§e"       : "";

  const rows = (Array.isArray(window.eventLog) && window.eventLog.length)
    ? window.eventLog.map(e=>{
        // Fallback f√ºr alte Eintr√§ge ohne kind
        let kind = e.kind;
        if(!kind && typeof e.text==="string"){
          const t = e.text;
          if (/Ereigniskarte/i.test(t)) kind = "card";
          else if (/Troph(√§|ae)/i.test(t)) kind = "trophy";
          else if (/(Artefaktum|gekauft|versteinert)/i.test(t)) kind = "shop";
        }
        const label = labelOf(kind);
        const content = String(e.text||"").replace(/^Ereigniskarte:\s*/i,"").trim();

        return `
          <div class="event-card">
            <div class="event-left">
              <div class="event-player">üë§ ${esc(e.player||"")}</div>
              <div class="event-time">üïí ${esc(e.time||"")}</div>
            </div>
            <div class="event-right">
              ${label ? `<div class="event-kind">${label}</div>` : ""}
              <div class="event-text">${esc(content)}</div>
            </div>
          </div>
        `;
      }).join("")
    : `<div class="small" style="text-align:center;margin:20px 0;">Noch keine Ereignisse.</div>`;

  const app = document.getElementById("app-section");
  if (!app) return;
  app.innerHTML = `
    <div class="auction-header">
      <div class="auction-title">üìú Ereignisverlauf</div>
      <div class="icon-btn" onclick="showSettings()">‚úñ</div>
    </div>
    <div class="event-log">${rows}</div>
  `;
}
window.showEventLog = showEventLog;

/* =========================
   Ereignis-Log: Daten & Helper (kollisionssicher)
   ========================= */
// NIE mehr removeItem("eventLog") aufrufen!
(function initEventLog(){
  // vorhandenes Array weiterverwenden, sonst neu
  if (!Array.isArray(window.eventLog)) window.eventLog = [];

  function saveEventLog(){
    try {
      localStorage.setItem("eventLog", JSON.stringify(window.eventLog.slice(0,300)));
    } catch(e) { console.warn("saveEventLog failed:", e); }
  }
  function loadEventLog(){
    try {
      const raw = localStorage.getItem("eventLog");
      if (raw) {
        const arr = JSON.parse(raw);
        if (Array.isArray(arr)) window.eventLog = arr;
      }
    } catch(e) { console.warn("loadEventLog failed:", e); }
  }
  function addEventLog({player, kind, text, time}){
    window.eventLog.unshift({
      player: player || "Spieler",
      kind: kind || "",                   // "card" | "shop" | "trophy"
      text: String(text || ""),
      time: time || new Date().toLocaleTimeString()
    });
    saveEventLog();
  }

  // public machen
  window.saveEventLog = saveEventLog;
  window.addEventLog  = addEventLog;

  // Komfort-Wrapper
  window.logEreigniskarte = (player, cardText)=> addEventLog({ player, kind:"card",   text: cardText });
  window.logArtefaktum    = (player, itemName)=> addEventLog({ player, kind:"shop",   text: itemName });
  window.logTrophies      = (player, n)       => addEventLog({ player, kind:"trophy", text: `${n} Troph√§e${n>1?"n":""}` });

  // Laden beim Start
  loadEventLog();
  // Sicherheitsspeicher vorm Tab-Schlie√üen
  window.addEventListener("beforeunload", saveEventLog);
})();

// Einheitliches Logging f√ºr Ereigniskarten
window.logEreigniskarte = function(player, cardTitle, cardBody="") {
  // h√ºbscher Text ohne doppelten Prefix
  const text = cardBody
    ? `${cardTitle}: ${cardBody}`   // z.B. "Ereigniskarte XY: Zahle 10 ‚Ç¨"
    : `${cardTitle}`;

  // schreibe als "card", damit showEventLog sicher labelt
  if (typeof addEventLog === "function") {
    addEventLog({
      player: player || "Spieler",
      kind: "card",
      text: text
    });
  }
};

/* ========= ARTEFAKTUM ========= */

const ARTEFAKTUM_ITEMS = [
  { id:"owl",      name:"versteinerte Eule",              		emoji:"ü¶â" },   // Weisheit
  { id:"infty",    name:"versteinertes Unendlichkeitssymbol", 	emoji:"‚ôæÔ∏è" }, // Unendlichkeit
  { id:"puzzle",   name:"versteinertes Puzzleteil",       		emoji:"üß©" },   // R√§tsel
  { id:"shooting", name:"versteinerte Sternschnuppe",     		emoji:"üå†" },   // Hoffnung
  { id:"brain",    name:"versteinertes Gehirn",          		emoji:"üß†" },   // Erinnerung
  { id:"hourglass",name:"versteinerte Sanduhr",          		emoji:"‚è≥" },   // Zeit
  { id:"book",     name:"versteinertes Buch",             		emoji:"üìñ" },   // Wissen
  { id:"scale",    name:"versteinerte Waage",             		emoji:"‚öñÔ∏è" },   // Harmonie
  { id:"eye",      name:"versteinertes Auge",             		emoji:"üëÅÔ∏è" },   // Wahrheit
  { id:"dice",     name:"versteinerter W√ºrfel",          		emoji:"üé≤" },   // Schicksal
  { id:"bell",     name:"versteinerte Glocke",            		emoji:"üîî" },   // Stille
  { id:"hands",    name:"versteinerter H√§nde-Abdruck", 	  		emoji:"ü§ù" }, // Freundschaft
  { id:"clover",   name:"versteinertes Kleeblatt",        		emoji:"üçÄ" },   // Gl√ºck
  { id:"drop",     name:"versteinerter Tropfen",          		emoji:"üíß" },   // Reinheit
  { id:"moon",     name:"versteinerter Halbmond",         		emoji:"üåô" },   // Dunkelheit
  { id:"sun",      name:"versteinerte Sonne",             		emoji:"‚òÄÔ∏è" },   // Licht
  { id:"yin",      name:"versteinertes Yin-Yang-Symbol",  		emoji:"‚òØÔ∏è" },   // Balance
  { id:"pigeon",   name:"versteinerte Taube",             		emoji:"üïäÔ∏è" },   // Frieden
  { id:"ring",     name:"versteinerter Ring",             		emoji:"üíç" },   // Treue
  { id:"crystal",  name:"versteinerte Kristallkugel",    		emoji:"üîÆ" }    // Zukunft
];

/* Cache (Items + Zeitstempel) ‚Äì 60 Sekunden g√ºltig */
window._arteCache = window._arteCache || { items: [], ts: 0 };

function _pickUniqueRandom(arr, n){
  const a = arr.slice();
  for (let i=a.length-1;i>0;i--){
    const j=Math.floor(Math.random()*(i+1));
    [a[i],a[j]]=[a[j],a[i]];
  }
  return a.slice(0, Math.min(n, a.length));
}

// ==== Artefaktum √∂ffnen: IMMER K√§ufer-Auswahl zeigen ====
window.startArtefaktum = function(){
  currentContext = "artefaktum";

  // Angebote ggf. neu ziehen (Cache ~60s)
  const now = Date.now();
  const elapsed = now - (window._arteCache.ts || 0);
  if (elapsed > 60*1000 || !Array.isArray(window._arteCache.items) || window._arteCache.items.length===0) {
    window._arteCache.items = _pickUniqueRandom(ARTEFAKTUM_ITEMS, 3);
    window._arteCache.ts = now;
  }

  // Seite rendern ‚Ä¶
  renderArtefaktum(window._arteCache.items);

  // ‚Ä¶ und JEDES MAL die K√§ufer-Auswahl √∂ffnen
  openArteBuyerModal();
};

function renderArtefaktum(offers){
  const until = new Date(window._arteCache.ts + 60000).toLocaleTimeString();

  // kleiner Header mit aktuellem K√§ufer + Button zum Wechseln
  const buyerLine = `
  `;

  const cards = (offers||[]).map((it,idx)=>{
    const bought = it._bought;
    return `
      <div class="arte-card">
        <div class="arte-emoji">${it.emoji}</div>
        <div class="arte-name">${it.name}</div>
        <div class="arte-price">50 ‚Ç¨</div>
        <div class="button arte-buy ${bought ? "disabled" : ""}"
             onclick="${bought ? "" : `buyArtefakt(${idx})`}">
          ${bought ? "Gekauft" : "Kaufen"}
        </div>
      </div>
    `;
  }).join("");

  document.getElementById("app-section").innerHTML = `
    <div class="auction-header">
      <div class="auction-title">üóø Artefaktum</div>
      <div class="icon-btn" onclick="showHome()">‚úñ</div>
    </div>
    <div class="arte-wrap">
      ${buyerLine}
      <div class="arte-col">${cards}</div>
      <div class="arte-foot">Angebote g√ºltig bis ${until}.</div>
    </div>
  `;
  window._currentArte = offers;
}

window.buyArtefakt = function(idx){
  const item = (window._currentArte || [])[idx];
  if (!item || item._bought) return;

  // Sicherstellen, dass ein K√§ufer gew√§hlt ist
  if (!arteState.started || arteState.currentBuyerIdx === null) {
    openArteBuyerModal(); // erst K√§ufer w√§hlen lassen
    return;
  }

  item._bought = true;

  const buyer = arteState.currentBuyerName || "Spieler";

  // Log mit Emoji statt ‚Äû(50 ‚Ç¨)‚Äú
  if (typeof logArtefaktum === "function") {
    logArtefaktum(buyer, `${item.name} ${item.emoji}`);
  } else {
    addEventLog({ player: buyer, kind:"shop", text:`${item.name} ${item.emoji}` });
  }

  renderArtefaktum(window._currentArte);
};

// ==== Artefaktum-State (wer kauft?) ====
window.arteState = window.arteState || {
  started: false,
  currentBuyerIdx: null,
  currentBuyerName: null
};

/* === Artefaktum: K√§ufer w√§hlen (Lucky-Streak-Style) === */
function openArteBuyerModal() {
  closeArteBuyerModal();

  const overlay = document.createElement("div");
  overlay.id = "arteBuyerModal";
  overlay.className = "modal-backdrop";
  overlay.style.display = "flex";
  overlay.innerHTML = `
    <div class="modal">
      <h2>K√§ufer w√§hlen</h2>
      <div class="hint">Wer kauft was?</div>
      <div class="field">
        <label for="arteBuyerSel">K√§ufer</label>
        <select id="arteBuyerSel">
          <option value="" disabled selected>Bitte w√§hlen</option>
          ${playerNames.map((n,i)=>`<option value="${i}">${n}</option>`).join("")}
        </select>
      </div>
      <div id="arteBuyerErr" class="error"></div>

      <div class="modal-actions centered">
        <button class="btn equal" onclick="closeArteBuyerModalAndBack()">Abbrechen</button>
        <button class="btn primary equal" onclick="confirmArteBuyerFromModal()">√úbernehmen</button>
      </div>
    </div>
  `;
  document.body.appendChild(overlay);

  const sel = document.getElementById("arteBuyerSel");
  if (sel) sel.focus();
}

function closeArteBuyerModal(){ const m=document.getElementById("arteBuyerModal"); if(m) m.remove(); }

function closeArteBuyerModalAndBack(){
showHome()
}

function confirmArteBuyerFromModal(){
  const sel = document.getElementById("arteBuyerSel");
  const err = document.getElementById("arteBuyerErr");
  const idx = sel ? parseInt(sel.value,10) : NaN;

  if (Number.isNaN(idx)) {
    if (err) err.textContent = "Bitte zuerst einen K√§ufer w√§hlen.";
    return;
  }

  arteState.currentBuyerIdx  = idx;
  arteState.currentBuyerName = playerNames[idx] || "Spieler";
  arteState.started = true;

  closeArteBuyerModal();
  // UI aktualisieren, damit oben der K√§ufer sichtbar ist
  renderArtefaktum(window._currentArte || []);
}

// global, falls du direkt binden willst:
window.openArteBuyerModal = openArteBuyerModal;
window.confirmArteBuyerFromModal = confirmArteBuyerFromModal;

  </script>
</body>
</html>
