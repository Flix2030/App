<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Lucky Cube</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  


  <link rel="manifest" href="/manifest.webmanifest">
  <style>
    :root{
      --bg0:#05080f;
      --bg1:#070c16;
      --panel:rgba(17,24,39,.72);
      --panel2:rgba(17,24,39,.48);
      --border:rgba(255,255,255,.12);
      --text:rgba(255,255,255,.92);
      --mut:rgba(255,255,255,.62);
      --shadow:0 18px 60px rgba(0,0,0,.55);
      --r:18px;
      --acc:#2ee88f;          /* gruen */
      --acc2:rgba(46,232,143,.18);
      --danger:#ff5c5c;
      --warn:#ffcc66;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      color:var(--text);
      background:
        radial-gradient(900px 600px at 15% 0%, rgba(46,232,143,.18), transparent 60%),
        radial-gradient(900px 600px at 90% 20%, rgba(120,180,255,.12), transparent 65%),
        linear-gradient(180deg,var(--bg1),var(--bg0));
    }

    .container{max-width:1100px;margin:0 auto;padding:18px 14px 40px}
    .topbar{
      display:flex;align-items:center;justify-content:space-between;
      gap:12px;margin:4px 0 18px 0;
    }
    h1{
      margin:0;
      font-size:44px;
      letter-spacing:-.02em;
    }
    .top-actions{display:flex;align-items:center;gap:10px}

    .back-link, .iconbtn, .icon-btn{
      width:44px;height:44px;border-radius:14px;
      display:flex;align-items:center;justify-content:center;
      border:1px solid var(--border);
      background:rgba(0,0,0,.12);
      color:var(--text);
      text-decoration:none;
      cursor:pointer;
      user-select:none;
      box-shadow:0 10px 35px rgba(0,0,0,.35);
    }
    .back-link:hover, .iconbtn:hover, .icon-btn:hover{filter:brightness(1.10)}
    .back-link:active, .iconbtn:active, .icon-btn:active{transform:translateY(1px)}

    h2{margin:18px 0 10px 0;font-size:28px;color:var(--text)}
    h3{margin:14px 0 8px 0;font-size:20px;color:var(--text)}
    p, label, small{color:var(--mut)}

    /* Panels / cards */
    #app-section, .panel, .card, .settings-section, .stats-section, .event-section, .players-section{
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:var(--r);
      box-shadow:var(--shadow);
      padding:16px;
      margin:14px 0;
    }

    /* Inputs */
    input, select, textarea{
      width:100%;
      background:rgba(0,0,0,.18);
      color:var(--text);
      border:1px solid var(--border);
      border-radius:14px;
      padding:12px 12px;
      outline:none;
    }
    input::placeholder, textarea::placeholder{color:rgba(255,255,255,.42)}
    input:focus, select:focus, textarea:focus{
      border-color:rgba(46,232,143,.55);
      box-shadow:0 0 0 4px var(--acc2);
    }

    /* Euro input wrapper (falls vorhanden) */
    .input-eur{
      display:flex;align-items:center;gap:10px;
      border:1px solid var(--border);
      background:rgba(0,0,0,.18);
      border-radius:14px;
      padding:6px 10px;
      width:max-content;
      margin:0 auto;
    }
    .input-eur input{
      width:140px;
      border:none;
      background:transparent;
      padding:10px 6px;
    }
    .input-eur span{color:var(--mut);font-weight:800}

    /* Buttons */
    button, .btn, .action-btn, .primary-btn, .secondary-btn{
      border:none;
      border-radius:14px;
      padding:12px 14px;
      font-weight:900;
      cursor:pointer;
    }
    .btn, button, .action-btn{
      background:rgba(255,255,255,.08);
      color:var(--text);
      border:1px solid var(--border);
    }
    .btn:hover, button:hover, .action-btn:hover{filter:brightness(1.08)}
    .btn:active, button:active, .action-btn:active{transform:translateY(1px)}

    .btn-primary, .primary-btn{
      background:linear-gradient(180deg, rgba(46,232,143,.95), rgba(46,232,143,.72));
      color:#00150a;
      border:1px solid rgba(46,232,143,.45);
      box-shadow:0 14px 40px rgba(46,232,143,.20);
    }
    .btn-primary:hover, .primary-btn:hover{filter:brightness(1.03)}

    .btn-danger{
      background:linear-gradient(180deg, rgba(255,92,92,.92), rgba(255,92,92,.70));
      color:#1a0000;
      border:1px solid rgba(255,92,92,.45);
    }

    /* Lists / log */
    .event-log, #eventLog, .log{
      text-align:left;
      padding:0;
      list-style:none;
      margin:10px 0 0 0;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .event-item, .log-item, .row{
      display:flex;
      align-items:flex-start;
      gap:12px;
      background:var(--panel2);
      border:1px solid var(--border);
      border-radius:16px;
      padding:14px;
    }
    .event-time{color:rgba(255,255,255,.45);font-size:12px;margin-left:auto;white-space:nowrap}
    .event-kind{font-weight:900}
    .event-text{color:var(--text);word-break:break-word}

    /* Tables */
    table{width:100%;border-collapse:separate;border-spacing:0 10px}
    th{color:rgba(255,255,255,.70);text-align:left;font-weight:900}
    td{
      background:var(--panel2);
      border:1px solid var(--border);
      padding:12px 12px;
      border-radius:14px;
      color:var(--text);
    }

    /* Small helpers (override old light styles) */
    .main-header{display:none !important;}
    .icon-btn{ /* old header icons, keep style */
      font-size:18px;
    }

    @media (max-width:700px){
      h1{font-size:34px}
      .back-link,.iconbtn,.icon-btn{width:40px;height:40px;border-radius:12px}
      #app-section, .panel, .card, .settings-section, .stats-section, .event-section, .players-section{padding:14px}
    }
  </style>

</head>
<body>

<div class="container">
  <div class="topbar">
    <h1>ğŸ² Lucky Cube</h1>
    <div class="top-actions">
      <button class="iconbtn" onclick="showHelp(currentContext)" aria-label="Hilfe">â“</button>
      <button class="iconbtn" onclick="openSettings()" aria-label="Einstellungen">âš™ï¸</button>
      <a class="back-link" href="/home" aria-label="Home">ğŸ </a>
    </div>
  </div>
    ğŸ² Lucky Cube ğŸ²
    <div class="icon-btn" onclick="openSettings()">âš™ï¸</div>
  </h1>
</div>

  <div id="app-section">
    <h2>Spieleranzahl wÃ¤hlen</h2>
	<select id="playerCount">
	  <option value="" disabled>Bitte wÃ¤hlen</option>
	  <option value="2">2 Spieler</option>
	  <option value="3">3 Spieler</option>
	  <option value="4" selected>4 Spieler</option> <!-- voreingestellt -->
	  <option value="5">5 Spieler</option>
	  <option value="6">6 Spieler</option>
	  <option value="7">7 Spieler</option>
	  <option value="8">8 Spieler</option>
	</select>
    <br><br>
    <div class="button" onclick="confirmPlayerCount()">Weiter</div>
  </div>
</div>

  <script>
/* ===== Global ===== */
let totalPlayers = 0;
let playerNames = [];
let eventLog = [];  // [{player:"Alice", text:"Goldregen", time:"12:34:56"}]
// === Snapshot fÃ¼r Ereigniskarten (UI-Zustand merken) ===
window._eventcardSnapshot = null;

// --- EventLog NICHT automatisch loeschen (bleibt fuer Verlauf erhalten) ---
// (Wenn du es doch loeschen willst: mach das nur beim Reset-Button)
try { const saved = JSON.parse(localStorage.getItem("eventLog")||"[]"); if (Array.isArray(saved)) eventLog = saved; } catch(e) {}


/* === Event-Log persistent speichern === */
function saveEventLog() {
  try {
    localStorage.setItem("eventLog", JSON.stringify(eventLog.slice(0, 300))); // capped
  } catch(e) { console.warn("saveEventLog failed:", e); }
}
function loadEventLog() {
  try {
    const raw = localStorage.getItem("eventLog");
    if (raw) {
      const arr = JSON.parse(raw);
      if (Array.isArray(arr)) eventLog = arr;
    }
  } catch(e) { console.warn("loadEventLog failed:", e); }
}
loadEventLog();

// Auction mit geheimem Wert
let auctionState = {
  highestBid: 0,
  highestBidder: null,
  bids: [],
  ended: true,
  prize: null // Geheimwert
};

// Battle: immer frisch
let battleState = { challenger: null, opponent: null, wager: 0, mode: "highest", rollA: null, rollB: null, ended: false, error: "" };

// Lotto: 4 gemeinsame Zahlen (1â€“9), Zustand bleibt bis Rundenende
let lottoState = {
  numbers: [],       // [{ value:1..9, done:false }, ...] (4 StÃ¼ck)
  winner: null,
  active: false,
  ended: true,
  turnIndex: 0,      // wer ist dran
  activeIdx: 0       // welche der 4 Zahlen ist blau/aktiv
};

// Lucky Streak
let streakState = {
  buyIn: 0,           // 5/10/15/20
  multiplier: 1,      // 1.25 / 1.5 / 1.75 / 2
  steps: 0,           // wie oft erfolgreich (keine 1)
  base: 10,           // Basisgewinn je Erfolg
  ended: false,
  payout: 0
};

// Jackpot
let jackpotState = {
  pot: 0,                 // aktueller Pot in â‚¬
  history: [],            // [{round:n, winner:'Name', amount:â‚¬}, ...]
  round: 1
};

let settings = {
  devMode: false,
  externalRoll: false,
  directHome: false,
};

// beim Start laden
const saved = localStorage.getItem("settings");
if (saved) {
  try {
    settings = JSON.parse(saved);
    settings.externalRoll = (settings.externalRoll === true || settings.externalRoll === "yes");
    settings.devMode      = (settings.devMode === true || settings.devMode === "yes");
    settings.directHome   = (settings.directHome === true || settings.directHome === "yes");
  } catch (e) {
    console.error("Fehler beim Laden", e);
  }
}

function saveSettings() {
  localStorage.setItem("settings", JSON.stringify(settings));
}

let currentContext = "home";

let _settingsPrevContext = null;
let _settingsPrevHTML = "";

/* ===== Setup ===== */
function confirmPlayerCount() {
  const selected = document.getElementById("playerCount").value;
  if (!selected) {
    document.getElementById("app-section").innerHTML += "<p class='error'>Bitte zuerst die Spieleranzahl wÃ¤hlen.</p>";
    return;
  }
  totalPlayers = parseInt(selected, 10);

  if (settings.devMode && settings.directHome) {
    // sofort ins MenÃ¼
    playerNames = ["Alice", "Bob", "Carol", "Dave"];
    showHome();
  } else if (settings.devMode && totalPlayers === 4) {
    // DevMode: Namen schon drin
    playerNames = ["Alice", "Bob", "Carol", "Dave"];
    showNameInputs();
  } else {
    // normal
    showNameInputs();
  }
}
const DEV_MODE = true;

function showNameInputs() {
  currentContext = "players";

  let defaultNames = ["Alice", "Bob", "Carol", "Dave"];

  let html = `<h2>Spielernamen eingeben</h2><div id="nameList">`;

  for (let i = 1; i <= totalPlayers; i++) {
    let prefill = "";
    if (settings.devMode && totalPlayers === 4) {
      prefill = defaultNames[i-1] || "";
    }
    html += `
      <div class="player-row" data-index="${i}">
        <span class="drag-handle" draggable="true" title="Ziehen">â‰¡</span>
        <div style="display:flex; align-items:center; gap:6px;">
          <input type="text" id="name${i}" maxlength="20" placeholder="Spieler ${i}" value="${prefill}"
                 oninput="updateNameCounter('name${i}')">
          <span id="counter-name${i}" class="name-counter">${prefill.length}/20</span>
        </div>
      </div>`;
  }

  html += `</div>
           <div id="nameError" class="error"></div>
           <div class="button" onclick="saveNames()">Weiter</div>`;

  document.getElementById("app-section").innerHTML = html;
  enableNameDragDrop();
}

function enableNameDragDrop() {
  const list = document.getElementById("nameList");
  let draggingRow = null;

  // Drag nur am Griff starten
  list.querySelectorAll(".drag-handle").forEach(handle => {
    handle.addEventListener("dragstart", e => {
      draggingRow = handle.closest(".player-row");
      e.dataTransfer.effectAllowed = "move";
      e.dataTransfer.setData("text/plain", "drag");
    });
  });

  // Droppen auf Zeilen
  list.querySelectorAll(".player-row").forEach(row => {
    row.addEventListener("dragover", e => e.preventDefault());
    row.addEventListener("drop", e => {
      e.preventDefault();
      if (!draggingRow || draggingRow === row) return;

      const all = Array.from(list.children);
      const from = all.indexOf(draggingRow);
      const to   = all.indexOf(row);
      if (from < to) row.after(draggingRow);
      else row.before(draggingRow);

      // IDs der Inputs neu setzen (name1, name2, â€¦)
      Array.from(list.querySelectorAll(".player-row input")).forEach((inp, i) => {
        inp.id = "name" + (i + 1);
      });
    });
  });
}

function saveNames() {
  let message = "";
  const temp = [];
  for (let i = 1; i <= totalPlayers; i++) {
    const val = document.getElementById(`name${i}`).value.trim();
    if (!val) { message = "Bitte alle Namen eingeben!"; break; }
    if (temp.includes(val)) { message = `Der Name "${val}" ist bereits vergeben!`; break; }
    temp.push(val);
  }
  const err = document.getElementById("nameError");
  if (message) { err.textContent = message; return; } else { err.textContent = ""; }
  playerNames = temp;
  showHome();
  initDeck();
}

function showHome() {
  currentContext = "home";
  if (typeof _killOverlays === "function") _killOverlays();

  // Buttons zusammenbauen
  let html = "";

  html += `
    <div class="button" id="btnLotto">ğŸ¯ Lotto</div>
    <div class="button" id="btnAuction">ğŸ’° Auktion</div>
    <div class="button" id="btnJackpot">ğŸ° Jackpot</div>
    <div class="button" id="btnStreak">ğŸ² Lucky Streak</div>
    <div class="button" id="btnPoker">ğŸƒ Poker</div>
    <div class="button" id="btnAllNothing">ğŸ² All or Nothing</div>
	<div class="button" id="btnRoulette">ğŸ¡ Roulette</div>
    <div class="button" id="btnEventCards">ğŸ´ Ereigniskarten</div>
    <div class="button" id="btnInventory">ğŸ’ Inventar</div>
    <div class="button" id="btnArtefaktum">ğŸ—¿ Artefaktum</div>
  `;

  if (!settings.externalRoll) {
    html += `<div class="button" id="btnBattle">âš”ï¸ Battle</div>`;
  }

  const app = document.getElementById("app-section");
  if (app) app.innerHTML = html;

  // Sicheres Binden: nur wenn Ziel wirklich eine Funktion ist
  const bind = (id, fn) => {
    const el = document.getElementById(id);
    if (el && typeof fn === "function") el.addEventListener("click", fn);
  };

  bind("btnRoulette", window.startRoulette);
  bind("btnLotto",      window.startLotto);
  bind("btnAuction",    window.startAuction);
  bind("btnJackpot",    window.startJackpot);
  bind("btnStreak",     window.startStreak);
  bind("btnPoker",      window.startPoker);
  bind("btnAllNothing", window.startAllNothing);
  bind("btnEventCards", window.startEventCardDraw);
  bind("btnInventory",  window.showInventory);   // â† existiert jetzt sicher (eigene Funktion anlegen)
  if (!settings.externalRoll) bind("btnBattle",  window.startBattle);
  bind("btnArtefaktum", window.startArtefaktum);
}

// global verfÃ¼gbar machen
window.showHome = showHome;

// global machen
window.showHome = showHome;

// global machen (falls woanders Ã¼berschrieben wurde)
window.showHome = showHome;

function renderPlayerInventories() {
  let html = "<h2>ğŸ’ Inventar</h2>";

  playerNames.forEach((name, idx) => {
    const cards = playerHands[idx] || [];
    let cardHtml = "";

    if (cards.length === 0) {
      cardHtml = "<div class='small'>Keine Karten</div>";
    } else {
      cardHtml = cards.map((c, i) => `
        <div class="inv-card">
          ${c.text}
          <button onclick="playEventCard(${idx}, ${i})">Spielen</button>
        </div>
      `).join("");
    }

    html += `
      <div class="inventory">
        <b>${name}</b>
        <div class="inv-cards">${cardHtml}</div>
      </div>
    `;
  });

  return html;
}

// === Ereigniskarten ===
// Kategorien:
//   - mode: "instant" â†’ sofort ausspielen
//   - mode: "inventory" â†’ muss ins Inventar gelegt werden
//   - mode: "both" â†’ Spieler darf wÃ¤hlen (sofort oder ins Inventar)

const EVENT_CARDS = [
  { text: "Du erhÃ¤ltst +5 â‚¬", mode: "instant" },
  { text: "Du erhÃ¤ltst +10 â‚¬", mode: "instant" },
  { text: "Du erhÃ¤ltst +15 â‚¬", mode: "instant" },
  { text: "Du erhÃ¤ltst +20 â‚¬", mode: "instant" },
  { text: "Du erhÃ¤ltst +25 â‚¬", mode: "instant" },
  { text: "Du verlierst â€“5 â‚¬", mode: "instant" },
  { text: "Du verlierst â€“10 â‚¬", mode: "instant" },
  { text: "Du verlierst â€“15 â‚¬", mode: "instant" },
  { text: "Du verlierst â€“20 â‚¬", mode: "instant" },
  { text: "Du verlierst â€“25 â‚¬", mode: "instant" },
  { text: "Erhalte 1 TrophÃ¤e", mode: "instant" },
  { text: "Erhalte 2 TrophÃ¤en (selten)", mode: "instant" },
  { text: "Stehle 1 TrophÃ¤e von einem Mitspieler", mode: "instant" },
  { text: "Du musst 1 TrophÃ¤e an einen Mitspieler abgeben", mode: "instant" },
  { text: "Dein nÃ¤chster Wurf wird verdoppelt", mode: "instant" },
  { text: "Setze eine Runde aus", mode: "instant" },
  { text: "Erhalte einen Extra-Zug", mode: "instant" },

  { text: "1 Runde unbesiegbar gegen Knockback", mode: "both" },
  { text: "1 Runde sicher vor Diebstahl", mode: "both" },
  { text: "2 Runden sicher vor Knockback", mode: "both" },
  { text: "2 Runden sicher vor Diebstahl", mode: "both" },
  { text: "Dein Inventar kann nicht beklaut werden", mode: "both" },
  { text: "Das Museum kann nicht ausgeraubt werden", mode: "both" },

  { text: "Erhalte 20 Gratis-Lose im Lotto", mode: "inventory" },

  { text: "Erhalte ein Knockback-Upgrade", mode: "instant" },
  { text: "WÃ¤hle einen Spieler, der 1 Runde aussetzt", mode: "instant" },
  { text: "Tausche deine Position mit einem Mitspieler", mode: "instant" },
  { text: "Tausche eine Ereigniskarte mit einem Mitspieler", mode: "instant" },
  { text: "Gib 10 â‚¬ einem Mitspieler und erhalte dafÃ¼r 1 TrophÃ¤e von ihm", mode: "instant" },
  { text: "Ziehe sofort eine zweite Ereigniskarte", mode: "instant" },
  { text: "WÃ¼rfle: gerade = +30 â‚¬, ungerade = â€“30 â‚¬", mode: "instant" },
  { text: "Risiko-Karte: Verdopple deinen nÃ¤chsten Gewinn oder Verlust", mode: "instant" },
  { text: "Bestimme, wer der nÃ¤chste Spieler ist", mode: "instant" },
  { text: "WÃ¤hle, ob ein Mitspieler 10 â‚¬ bekommt oder verliert", mode: "instant" },
  { text: "Alle Spieler wÃ¼rfeln: kleinste Zahl verliert 5 â‚¬ an jeden", mode: "instant" },
  { text: "Mini-Steuer: alle Spieler geben dir 5 â‚¬", mode: "instant" },
  { text: "Zwangsspende: du gibst allen Spielern 5 â‚¬", mode: "instant" },
  { text: "Goldregen: jeder +10 â‚¬, du +20 â‚¬", mode: "instant" },
  { text: "Schwarzer Tag: jeder â€“5 â‚¬, du â€“10 â‚¬", mode: "instant" },
  { text: "Tausche deinen WÃ¼rfel mit dem linken Nachbarn", mode: "instant" },
  { text: "Stehle 1 Ereigniskarte von einem Mitspieler", mode: "instant" },
  { text: "Blockiere 1 Ereigniskarte eines Mitspielers", mode: "instant" },
  { text: "Gib 1 TrophÃ¤e ab an einen Mitspieler", mode: "instant" },
  { text: "Dein Knockbackstick verliert ein Upgrade", mode: "instant" }
];

function startEventCardDraw() {
  currentContext = "eventcard";
  pendingEventCard = null;
  ensureEventSystemReady();

  const options = playerNames.map((n,i)=>`<option value="${i}">${n}</option>`).join("");

  document.getElementById("app-section").innerHTML = `
    <div class="auction-header">
      <div class="auction-title">ğŸ´ Ereigniskarte ziehen</div>
      <div class="icon-btn" onclick="showHome()">âœ–</div>
    </div>

    <div style="text-align:center;">
      <div class="small">WÃ¤hle einen Spieler:</div>
      <select id="eventPlayer" onchange="enableEventDrawBtn()">
        <option value="" disabled selected>Bitte wÃ¤hlen</option>
        ${options}
      </select>
      <div style="margin-top:12px;">
        <div id="eventDrawBtn" class="button disabled" onclick="confirmEventDraw()"
             style="pointer-events:none;opacity:0.6;">
          Karte ziehen
        </div>
      </div>
      <div id="eventCardResult"></div>
    </div>
  `;
}

function enableEventDrawBtn() {
  const sel = document.getElementById("eventPlayer");
  const btn = document.getElementById("eventDrawBtn");
  if (!sel || !btn) return;
  const ok = sel.value !== "";
  btn.classList.toggle("disabled", !ok);
  btn.style.pointerEvents = ok ? "auto" : "none";
  btn.style.opacity = ok ? "1" : "0.6";
}

// === State ===
let playerHands = [];        // Inventar pro Spieler
let pendingEventCard = null; // gerade gezogene Karte

// Karten mischen
function shuffleEventCards() {
  for (let i = EVENT_CARDS.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [EVENT_CARDS[i], EVENT_CARDS[j]] = [EVENT_CARDS[j], EVENT_CARDS[i]];
  }
}

// NÃ¤chste Karte erzeugen (inkl. eindeutiger ID)
function randomEventCard() {
  const base = EVENT_CARDS[Math.floor(Math.random() * EVENT_CARDS.length)];
  return { ...base, _uid: Math.random().toString(36).slice(2) + Date.now().toString(36) };
}

// HÃ¤nde initialisieren
function initDeck() {
  playerHands = playerNames.map(() => []);
}

// Immer sicherstellen, dass HÃ¤nde passen
function ensureEventSystemReady() {
  if (!Array.isArray(playerHands) || playerHands.length !== playerNames.length) {
    const old = Array.isArray(playerHands) ? playerHands : [];
    playerHands = playerNames.map((_, i) => old[i] || []);
  }
}

// Karte ziehen
function drawEventCard(playerIdx, returnOnly = false) {
  const card = randomEventCard();
  if (returnOnly) return card;

  if (card.mode === "instant") {
    resolveEventCard(card, playerIdx);
  } else if (card.mode === "inventory") {
    if (!playerHands[playerIdx]) playerHands[playerIdx] = [];
    playerHands[playerIdx].push(card);
  } else if (card.mode === "both") {
    pendingEventCard = card; // Spieler darf wÃ¤hlen im UI
  }
  return card;
}

function showInventory() {
  currentContext = "inventory";
  ensureEventSystemReady();

  const app = document.getElementById("app-section");
  if (!app) return;

  app.innerHTML = `
    <div class="auction-header">
      <div class="auction-title">ğŸ§³ Inventar</div>
      <div class="icon-btn" onclick="showHome()">âœ–</div>
    </div>
    ${renderPlayerInventories()}
  `;
}
window.showInventory = showInventory; // global verfÃ¼gbar machen

// UI: Karte zeigen nach Ziehen
function confirmEventDraw() {
  const sel = document.getElementById("eventPlayer");
  const idx = Number(sel && sel.value);
  if (isNaN(idx)) return;

  ensureEventSystemReady();

  // ğŸ‘‰ Nur VORSCHAU: Karte ziehen, aber NICHT ins Inventar legen und NICHT loggen
  const card = drawEventCard(idx, true); // returnOnly = true  -> keine Seiteneffekte
  pendingEventCard = card;

  let html = `
    <div style="font-size:1.4em;margin-top:12px;">${playerNames[idx]} zieht:</div>
    <div style="background:#fff;border:2px solid #333;border-radius:12px;
                padding:20px;margin:20px auto;max-width:420px;
                font-size:1.2em;box-shadow:0 4px 12px rgba(0,0,0,0.2);">
      ${card.text}
    </div>
  `;

  if (card.mode === "instant") {
    html += `
      <div class="small">(Sofortkarte â€“ muss direkt eingesetzt werden)</div>
      <div class="button" onclick="playEventCardImmediate(${idx})">Jetzt ausfÃ¼hren</div>
    `;
  } else if (card.mode === "inventory") {
    html += `
      <div class="small">(Inventarkarte â€“ wird gesichert)</div>
      <div class="button" onclick="keepEventCard(${idx})">Sichern</div>
    `;
  } else if (card.mode === "both") {
    html += `
      <div class="small">(Kann sofort gespielt oder ins Inventar gelegt werden)</div>
      <div class="button" onclick="playEventCardImmediate(${idx})">Jetzt ausfÃ¼hren</div>
      <div class="button" onclick="keepEventCard(${idx})">Behalten</div>
    `;
  }

  const box = document.getElementById("eventCardResult");
  if (box) box.innerHTML = html;

  // â›”ï¸ KEIN eventLog hier â€“ erst beim tatsÃ¤chlichen EinlÃ¶sen
}

// Karte sofort ausfÃ¼hren
function playEventCardImmediate(playerIdx) {
  if (!pendingEventCard) return;
  const card = pendingEventCard;
  pendingEventCard = null;

  // ğŸ‘‰ Jetzt WIRKLICH einlÃ¶sen (hier wird geloggt)
  resolveEventCard(card, playerIdx);

  const target = document.getElementById("eventCardResult");
  if (target) {
    target.innerHTML = `
      <div style="margin-top:15px;color:#006080;font-weight:600;">
        ğŸ¯ Karte wurde ausgespielt.
      </div>
    `;
  }
}

// Karte ins Inventar legen
function keepEventCard(playerIdx) {
  if (!pendingEventCard) return;
  ensureEventSystemReady();

  // ğŸ‘‰ Nur ins Inventar legen â€“ KEIN Log!
  if (!playerHands[playerIdx]) playerHands[playerIdx] = [];
  playerHands[playerIdx].push(pendingEventCard);
  pendingEventCard = null;

  const target = document.getElementById("eventCardResult");
  if (target) {
    target.innerHTML = `
      <div style="margin-top:15px;color:#0b7a28;font-weight:600;">
        âœ… Karte wurde ins Inventar gelegt.
      </div>
      <div style="margin-top:20px;">
        <div class="button" onclick="showInventory()">ğŸ’ Inventar Ã¶ffnen</div>
      </div>
    `;
  }
}

// Karte aus Inventar spielen
function playEventCard(playerIdx, cardIdx) {
  const card = (playerHands[playerIdx] || []).splice(cardIdx, 1)[0];
  if (!card) return;
  resolveEventCard(card, playerIdx);
  showInventory();
}

// Effekte (Platzhalter â€“ hier kannst du deine Logik einbauen)
function resolveEventCard(card, playerIdx) {
  // 1) Basics
  const player = (playerNames && playerNames[playerIdx]) ? playerNames[playerIdx] : "Spieler";
  const now    = new Date();

  // 2) Ereignis im Verlauf loggen (mit Typ "card") + speichern
  try {
    if (typeof addEventLog === "function") {
      // Einheitliche zentrale Logging-Funktion (beschriftet & speichert)
      addEventLog({
        player: player,
        kind:   "card",                     // â† WICHTIG: damit showEventLog korrekt labelt
        text:   String(card && card.text ? card.text : ""),
        time:   now.toLocaleTimeString()
      });
    } else {
      // Fallback: direkt ins Array + optional speichern
      window.eventLog = Array.isArray(window.eventLog) ? window.eventLog : [];
      window.eventLog.unshift({
        player: player,
        kind:   "card",                     // â† WICHTIG
        text:   String(card && card.text ? card.text : ""),
        time:   now.toLocaleTimeString()
      });
      if (typeof saveEventLog === "function") {
        try { saveEventLog(); } catch (e) { /* noop */ }
      } else {
        // Minimaler Fallback: selbst persistieren (ohne GrÃ¶ÃŸenlimit)
        try { localStorage.setItem("eventLog", JSON.stringify(window.eventLog)); } catch (e) {}
      }
    }
  } catch (e) {
    console.warn("Ereigniskarte konnte nicht geloggt werden:", e);
  }

  // 3) Effekte der Karte anwenden (hier deine Game-Logik einbauen â€“ Beispiele/Platzhalter)
  try {
    const text = String(card && card.text ? card.text : "");

    // Beispielhafte, einfache Muster â€“ passe das an deine Regeln an:
    if (/erhÃ¤ltst\s*\+?(\d+)\s*â‚¬/i.test(text)) {
      const amount = parseInt(RegExp.$1, 10);
      // TODO: Guthaben des Spielers um 'amount' erhÃ¶hen
    } else if (/verlierst\s*[-â€“â€”]?\s*(\d+)\s*â‚¬/i.test(text)) {
      const amount = parseInt(RegExp.$1, 10);
      // TODO: Guthaben des Spielers um 'amount' verringern
    } else if (/Erhalte\s*(\d+)\s*TrophÃ¤/i.test(text)) {
      const n = parseInt(RegExp.$1, 10) || 1;
      if (typeof awardTrophies === "function") {
        try { awardTrophies(player, n); } catch (e) {}
      }
    } else if (/Erhalte\s*1\s*TrophÃ¤/i.test(text)) {
      if (typeof awardTrophies === "function") {
        try { awardTrophies(player, 1); } catch (e) {}
      }
    }

    // ggf. weitere Karten-Typen hier behandeln â€¦

  } catch (e) {
    console.warn("Karten-Effekt konnte nicht angewendet werden:", e);
  }
}

function showSettings() {
  currentContext = "settings";

  document.getElementById("app-section").innerHTML = `
    <div class="settings-section">
      <!-- Header -->
      <div class="auction-header">
        <div class="auction-title">âš™ï¸ Einstellungen</div>
        <div class="icon-btn" onclick="closeSettings()" title="ZurÃ¼ck">âœ–</div>
      </div>

      <!-- Extern wÃ¼rfeln -->
      <div class="settings-row">
        <label for="externalRoll">Extern wÃ¼rfeln:</label>
        <label class="switch">
          <input type="checkbox" id="externalRoll"
                 ${settings.externalRoll ? "checked" : ""}
                 onchange="toggleExternalRoll(this.checked)">
          <span class="track" data-on="an" data-off="aus"></span>
        </label>
      </div>

      <!-- Dev-Modus -->
      <div class="settings-row">
        <label for="devMode">Dev-Modus:</label>
        <label class="switch">
          <input type="checkbox" id="devMode"
                 ${settings.devMode ? "checked" : ""}
                 onchange="toggleDevMode(this.checked)">
          <span class="track" data-on="an" data-off="aus"></span>
        </label>
      </div>

      <!-- Direkt zum Home-Screen (nur sichtbar, wenn Dev an) -->
      <div class="settings-row" id="directHomeRow" style="display:${settings.devMode ? "flex" : "none"};">
        <label for="directHome">Direkt zum Home-Screen:</label>
        <label class="switch">
          <input type="checkbox" id="directHome"
                 ${settings.directHome ? "checked" : ""}
                 onchange="toggleDirectHome(this.checked)">
          <span class="track" data-on="an" data-off="aus"></span>
        </label>
      </div>

      <!-- Aktionen -->
      <div style="margin-top:18px;">
        <div class="button" onclick="managePlayers()">ğŸ‘¥ Spieler verwalten</div>
      </div>

      <div style="margin-top:12px;">
        <div class="button" onclick="openStatistics()">ğŸ“Š Statistik</div>
      </div>

      <div style="margin-top:12px;">
        <div class="button" onclick="showEventLog()">ğŸ“œ Ereignisverlauf</div>
      </div>
    </div>
  `;
}

function toggleDevMode(checked) {
  settings.devMode = !!checked;
  saveSettings();
  showSettings(); // zeigt/verbirgt Direct-Home-Zeile sofort
}

function toggleDirectHome(checked) {
  settings.directHome = !!checked;
  saveSettings();
}

function toggleExternalRoll(checked) {
  settings.externalRoll = !!checked;
  saveSettings();
  // kein showHome() -> kein Teleport
}

/* ===== Settings: Kontext merken + Snapshots ===== */
window._settingsPrevContext = window._settingsPrevContext || "home";

function openSettings() {
  // Herkunft merken
  const ctx = (typeof currentContext === "string" && currentContext) ? currentContext : "home";
  window._settingsPrevContext = ctx;

  /* ğŸƒ Poker â€“ Snapshot */
  if (ctx === "poker" && window.pokerState) {
    window._pokerSnapshot = JSON.parse(JSON.stringify(window.pokerState));
  } else {
    window._pokerSnapshot = null;
  }

  /* ğŸ´ Ereigniskarten â€“ Snapshot */
  if (ctx === "eventcard") {
    const sel = document.getElementById("eventPlayer");
    const res = document.getElementById("eventCardResult");
    const btn = document.getElementById("eventDrawBtn");
    window._eventcardSnapshot = {
      selected:  sel ? sel.value : "",
      resultHTML: res ? res.innerHTML : "",
      btnEnabled: btn ? !btn.classList.contains("disabled") : false,
      pending:   (typeof pendingEventCard === "object" && pendingEventCard)
                   ? JSON.parse(JSON.stringify(pendingEventCard))
                   : null
    };
  } else {
    window._eventcardSnapshot = null;
  }

  /* âš–ï¸ All or Nothing â€“ Snapshot */
  if (ctx === "allnothing") {
    const sel = document.getElementById("aonPlayer");
    const res = document.getElementById("allnothingResult");
    const tro = document.getElementById("allnothingTrophy");
    window._aonSnapshot = {
      selected:  sel ? sel.value : "",
      resultHTML: res ? res.innerHTML : "",
      trophyHTML: tro ? tro.innerHTML : ""
    };
  } else {
    window._aonSnapshot = null;
  }

  /* ğŸ² Lucky Streak â€“ Snapshot */
  if (ctx === "streak" && typeof window.streakState === "object" && window.streakState) {
    window._streakSnapshot = JSON.parse(JSON.stringify(window.streakState));
  } else {
    window._streakSnapshot = null;
  }

  /* ğŸ° Jackpot â€“ Snapshot */
  if (ctx === "jackpot") {
    window._jackpotSnapshot = {
      bet:   document.getElementById("jackpotBet")?.value || "",
      roll:  document.getElementById("jackpotRoll")?.value || "",
      pSel:  document.getElementById("jackpotPlayer")?.value || "",
      res:   document.getElementById("jackpotResult")?.innerHTML || "",
      err:   document.getElementById("jackpotErr")?.innerHTML || ""
    };
  } else {
    window._jackpotSnapshot = null;
  }

  currentContext = "settings";
  showSettings();
}

/** ===== Einstellungen schlieÃŸen â€“ exakt zum gemerkten Screen zurÃ¼ck ===== */
function closeSettings() {
  const prev = window._settingsPrevContext || "home";
  window._settingsPrevContext = null;   // Reset fÃ¼r den nÃ¤chsten Durchlauf
  currentContext = prev;

  /* ğŸƒ Poker: nie neu starten â€“ Snapshot rendern */
  if (prev === "poker") {
    if (window._pokerSnapshot) {
      window.pokerState = window._pokerSnapshot;
      window._pokerSnapshot = null;
    }
    if (typeof renderPokerUI === "function") renderPokerUI();
    else if (typeof startPoker === "function") startPoker();
    return;
  }

  /* ğŸ´ Ereigniskarten: UI + Snapshot zurÃ¼ckspielen */
  if (prev === "eventcard") {
    startEventCardDraw(); // Basis-UI
    if (window._eventcardSnapshot) {
      const snap = window._eventcardSnapshot;

      const sel = document.getElementById("eventPlayer");
      if (sel && snap.selected) sel.value = snap.selected;

      if (typeof enableEventDrawBtn === "function") enableEventDrawBtn();

      const res = document.getElementById("eventCardResult");
      if (res && snap.resultHTML) res.innerHTML = snap.resultHTML;

      if (snap.pending) pendingEventCard = snap.pending;

      const btn = document.getElementById("eventDrawBtn");
      if (btn) {
        if (snap.btnEnabled) {
          btn.classList.remove("disabled");
          btn.style.pointerEvents = "auto";
          btn.style.opacity = "1";
        } else {
          btn.classList.add("disabled");
          btn.style.pointerEvents = "none";
          btn.style.opacity = "0.6";
        }
      }
      window._eventcardSnapshot = null;
    }
    return;
  }

  /* âš–ï¸ All or Nothing: UI + Snapshot zurÃ¼ckspielen */
  if (prev === "allnothing") {
    startAllNothing();
    if (window._aonSnapshot) {
      const snap = window._aonSnapshot;

      const sel = document.getElementById("aonPlayer");
      if (sel && snap.selected) sel.value = snap.selected;

      const res = document.getElementById("allnothingResult");
      if (res && snap.resultHTML) res.innerHTML = snap.resultHTML;

      const tro = document.getElementById("allnothingTrophy");
      if (tro && snap.trophyHTML) tro.innerHTML = snap.trophyHTML;

      window._aonSnapshot = null;
    }
    return;
  }

  /* ğŸ² Lucky Streak: Zustand zurÃ¼ck, NICHT neu starten */
  if (prev === "streak") {
    if (window._streakSnapshot) {
      window.streakState = window._streakSnapshot;
      window._streakSnapshot = null;
    }
    if (typeof renderStreakUI === "function") renderStreakUI();
    else if (typeof startStreak === "function") startStreak(); // Fallback
    return;
  }

  /* ğŸ° Jackpot: UI + Snapshot zurÃ¼ckspielen */
  if (prev === "jackpot") {
    startJackpot(); // Basis-UI
    try {
      const snap = window._jackpotSnapshot;
      if (snap) {
        const sel   = document.getElementById("jackpotPlayer");
        const betEl = document.getElementById("jackpotBet");
        const rolEl = document.getElementById("jackpotRoll");
        const resEl = document.getElementById("jackpotResult");
        const errEl = document.getElementById("jackpotErr");

        if (sel && snap.pSel !== "") sel.value = snap.pSel;
        if (betEl) betEl.value = snap.bet || "";
        if (rolEl) rolEl.value = snap.roll || "";
        if (resEl) resEl.innerHTML = snap.res || "";
        if (errEl) errEl.innerHTML = snap.err || "";
      }
    } catch (e) {
      console.warn("Jackpot restore failed:", e);
    }
    window._jackpotSnapshot = null;
    return;
  }

/* ğŸ—¿ Artefaktum: zurÃ¼ck zum Angebot */
if (prev === "artefaktum") {
  // Angebote sind via window._arteCache 1 Minute gecached,
  // _bought-Status steckt in den Items â€“ einfach neu rendern.
  if (typeof startArtefaktum === "function") startArtefaktum();
  else if (window.startArtefaktum) window.startArtefaktum();
  return;
}

  /* ğŸŒ Alle anderen Kontexte normal herstellen */
  switch (prev) {
    case "roulette":  startRoulette();  break;
    case "auction":   startAuction();   break;
    case "lotto":     startLotto();     break;
    case "battle":    startBattle();    break;
    case "inventory": showInventory();  break;
    case "eventlog":  showEventLog();   break;
    case "stats":     showStatistics(); break;
    case "home":      showHome();       break;
    default:          showHome();
  }
}

function setTheme(val) {
  console.log("Theme gesetzt auf:", val);
  // hier spÃ¤ter CSS-Klassen oder Styles wechseln
}

function toggleSound(on) {
  console.log("Soundeffekte:", on ? "An" : "Aus");
  // hier spÃ¤ter Sounds steuern
}

function setLanguage(lang) {
  console.log("Sprache:", lang);
  // hier spÃ¤ter Text-Labels austauschen
}

/* ===== Spieler verwalten ===== */
function updateNameCounter(inputId) {
  const input = document.getElementById(inputId);
  const counter = document.getElementById("counter-" + inputId);
  if (input && counter) {
    counter.textContent = `${input.value.length}/20`;
  }
}

function managePlayers() {
  currentContext = "players";
  const listHTML = playerNames.map((name, idx) => `
    <div class="player-row" data-index="${idx}" style="display:flex;align-items:center;gap:6px;">
      <span class="drag-handle" draggable="true" title="Ziehen">â‰¡</span>
      <input type="text" id="player${idx}" maxlength="20" value="${name}"
             oninput="updateNameCounter('player${idx}'); renamePlayer(${idx}, this.value)">
      <span id="counter-player${idx}" class="name-counter">${name.length}/20</span>
      <span class="button" style="width:auto;padding:6px 10px;font-size:.9em;" onclick="deletePlayer(${idx})">âŒ</span>
    </div>
  `).join("");

  document.getElementById("app-section").innerHTML = `
    <div class="lotto-header">
      <div class="lotto-title">ğŸ‘¥ Spieler verwalten</div>
      <div class="icon-btn" onclick="showSettings()">âœ–</div>
    </div>

    <div id="playerList">${listHTML}</div>

	<div class="input-wrap">
	  <input type="text" id="newPlayerName" maxlength="20" placeholder="Neuer Spieler"
			 oninput="updateNameCounter('newPlayerName')">
	  <span id="counter-newPlayerName" class="name-counter">0/20</span>
	</div>
    <div class="button" style="width:200px;margin-top:8px;" onclick="addPlayer()">â• HinzufÃ¼gen</div>
    <div id="playerError" class="error"></div>
  `;

  enablePlayerDragDrop();
}

/**
 * Benennt einen bestehenden Spieler um. Die Eingabe wird getrimmt und
 * geprÃ¼ft, ob der Name bereits von einem anderen Spieler verwendet wird.
 * Ist der Name bereits vergeben, wird eine Fehlermeldung angezeigt und
 * das Eingabefeld zurÃ¼ck auf den vorherigen Namen gesetzt.
 */
function renamePlayer(idx, newName) {
  const trimmed = newName.trim();
  const errorEl = document.getElementById("playerError");
  // Leere Namen sind nicht erlaubt
  if (trimmed === "") {
    if (errorEl) {
      errorEl.textContent = "Bitte einen Namen eingeben.";
    }
    const input = document.getElementById('player' + idx);
    if (input) {
      input.value = playerNames[idx];
      updateNameCounter('player' + idx);
    }
    return;
  }
  // PrÃ¼fe, ob der neue Name bereits an einer anderen Position verwendet wird
  const duplicate = playerNames.some((n, i) => i !== idx && n === trimmed);
  if (duplicate) {
    if (errorEl) {
      errorEl.textContent = `Der Name "${trimmed}" ist bereits vergeben.`;
    }
    // Eingabefeld wieder auf den alten Wert setzen und ZÃ¤hler aktualisieren
    const input = document.getElementById('player' + idx);
    if (input) {
      input.value = playerNames[idx];
      updateNameCounter('player' + idx);
    }
    return;
  }
  // Kein Duplikat: Fehler zurÃ¼cksetzen und Namen aktualisieren
  if (errorEl) errorEl.textContent = "";
  playerNames[idx] = trimmed;
}

// === Spieler hinzufÃ¼gen (REPLACE) ===
function addPlayer() {
  const name = document.getElementById("newPlayerName").value.trim();
  const errorEl = document.getElementById("playerError");
  if (!name) { errorEl.textContent = "Bitte einen Namen eingeben."; return; }
  if (playerNames.includes(name)) { errorEl.textContent = `Der Name "${name}" ist bereits vergeben.`; return; }
  errorEl.textContent = "";

  playerNames.push(name);
  // neue, leere Hand fÃ¼r den Spieler
  if (!Array.isArray(playerHands)) playerHands = [];
  playerHands.push([]);

  managePlayers();
}

// === Spieler lÃ¶schen (REPLACE) ===
function deletePlayer(idx) {
  playerNames.splice(idx, 1);
  if (Array.isArray(playerHands)) playerHands.splice(idx, 1);
  managePlayers();
}

function renderHeader(title, context) {
  return `
    <div style="display:flex;align-items:center;justify-content:center;position:relative;">
      <h1 style="flex:1;text-align:center;">${title}</h1>
      <div class="icon-btn" style="position:absolute;right:50px;top:10px;" onclick="showHelp('${context}')">â“</div>
      <div class="icon-btn" style="position:absolute;right:10px;top:10px;" onclick="showSettings()">âš™ï¸</div>
    </div>
  `;
}

function colorfulRouletteWord() {
  const letters = "Roulette".split("");
  const colors = ["red", "black", "green"];
  return letters.map((ch,i)=>{
    const col = colors[i % colors.length];
    return `<span style="color:${col}">${ch}</span>`;
  }).join("");
}

function showHelp(context) {
  let text = "";
  switch (context) {
	case "lotto":
	  text = "ğŸ¯ <b>Lotto:</b><br>" +
			"<div style='text-align:left;margin:10px auto;max-width:600px;'>" +
			 "Es werden zufÃ¤llig <span style='color:#0057d9;font-weight:bold;'>4 Zahlen</span> gezogen.<br>" +
			 "Dann wÃ¼rfelt <span style='color:#0057d9;font-weight:bold;'>jeder 1x</span>, wenn er am Zug ist, und legt <span style='color:#0b7a28;font-weight:bold;'>1 â‚¬</span> in den Pot.<br>" +
			 " <br>" +
			 "Variante 1: Der Spieler muss eine <span style='color:#0b7a28;font-weight:bold;'>3</span> WÃ¼rfeln wÃ¼rfelt aber eine <span style='color:#b00020;font-weight:bold;'>5</span> und schafft es nicht,<br>" +
			 "dann drÃ¼ckt man auf den button ğŸ‘¤ und die nÃ¤chste Person ist ander reihe.<br>" +
			 " <br>" +
			 "Variante 2: Der Spieler muss eine <span style='color:#0b7a28;font-weight:bold;'>3</span> WÃ¼rfeln und wÃ¼rfelt auch die <span style='color:#0b7a28;font-weight:bold;'>3</span><br>" +
			 "Jetzt wird die Zahl abgehackt, in dem man auf sie drÃ¼ckt<br>" +
			 " <br>" +
			 "Wer die <span style='color:#b00020;font-weight:bold;'>letzte Zahl</span> ankreuzt, gewinnt den Pot.";
	break;
	case "auction":
	  text = "ğŸ’° <b>Auktion:</b><br>" +
		"<div style='text-align:left;margin:10px auto;max-width:600px;'>" +
		  "Alle Spieler kÃ¶nnen Gebote abgeben, ohne den Wert des Gewinns zu kennen.<br>" +
		  "Der Geheimwert liegt zufÃ¤llig zwischen <b>0 â‚¬</b> und <b>200 â‚¬</b>.<br><br>" +
		  "â¡ï¸ Der <span class='text-green'>hÃ¶chstbietende Spieler</span> gewinnt die Auktion.<br>" +
		  "â¡ï¸ Erst nach dem Ende wird der Geheimwert aufgedeckt und ausgezahlt." +
		"</div>";
	  break;
	case "battle":
	  text = "âš”ï¸ <b>Battle:</b><br>" +
			"<div style='text-align:left;margin:10px auto;max-width:600px;'>" +
			 "Zwei Spieler treten gegeneinander an.<br>" +
			 "Beide wÃ¤hlen einen Einsatz (ğŸ’¶) und wÃ¼rfeln je 1x.<br><br>" +
			 "<b>Modi:</b><br>" +
			 "ğŸ”º HÃ¶chste Zahl gewinnt<br>" +
			 "ğŸ”» Kleinste Zahl gewinnt<br><br>" +
			 "â¡ï¸ Der Gewinner erhÃ¤lt den <span class='text-green'>Einsatz</span> vom Verlierer.";
	  break;
	case "jackpot":
	  text = "ğŸ° <b>Jackpot:</b><br>" +
			"<div style='text-align:left;margin:10px auto;max-width:600px;'>" +
			 "Der Spieler setzt einen Einsatz (ğŸ’¶).<br>" +
			 "Dann wÃ¼rfelt er 1x und trÃ¤gt sein Ergebnis ein.<br><br>" +
			 "<div style='text-align:left;margin:10px auto;max-width:250px;'>" +
			"âŒ <span style='color:#e53935;'>1</span> = Alles verloren<br>" +
			"ğŸ˜¬ <span style='color:#fb8c00;'>2</span> = HÃ¤lfte zurÃ¼ck<br>" +
			"ğŸ™‚ <span style='color:#1e88e5;'>3</span> = Einsatz zurÃ¼ck<br>" +
			"ğŸ‰ <span style='color:#43a047;'>4</span> = 1,5Ã— Gewinn<br>" +
			"ğŸ¥³ <span style='color:#2e7d32;'>5</span> = Doppelter Gewinn<br>" +
			"ğŸ² <span style='color:#8e24aa;'>6</span> = Nochmal wÃ¼rfeln!"
			 "</div>";
	  break;
	case "streak":
	  text = "ğŸ² <b>Lucky Streak:</b><br>" +
			"<div style='text-align:left;margin:10px auto;max-width:600px;'>" +
			 "Der Spieler wÃ¼rfelt so lange, bis er stoppt oder verliert.<br><br>" +
			 "Regeln:<br>" +
		  	 "âŒ <span class='text-red'>1</span> = Alles verloren<br>" +
		  	 "âœ… <span class='text-green'>2â€“5</span> = +1 â‚¬ (1â‚¬ mehr pro Runde)<br><br>" +
		  	 "ğŸ˜¬ <span class='text-orange'>6</span> = Gewinn halbiert<br>" +
			 "â¡ï¸ Nach jedem erfolgreichen Wurf kann man entscheiden: <b>Weiter</b> oder <b>Stopp</b>.";
	  break;
	case "roulette":
	  text = "ğŸ¡ <b>Roulette:</b><br>" +
		"<div style='text-align:left;margin:10px auto;max-width:600px;'>" +
		  "Man legt seinen Einsatz fest und wÃ¼rfelt mit dem <b>" + colorfulRouletteWord() + "</b> WÃ¼rfel, um festzulegen worauf gesetzt werden soll.<br><br>" +
		  "ğŸ‘‰ <u>Auszahlungen:</u><br>" +
		  "ğŸ”¢ Zahl 2â€“12 = <b>Ã—50</b><br>" +
		  "â– Gerade / ã€°ï¸ Ungerade = <b>Ã—2</b><br>" +
		  "ğŸ”´ Rot / âš« Schwarz = <b>Ã—2</b><br>" +
		  "ğŸŸ¢ GrÃ¼n = <b>Ã—30</b><br><br>" +
		"</div>";
	  break;
	case "poker":
  text = "ğŸƒ <b>Poker:</b><br>" +
    "<div style='text-align:left;margin:10px auto;max-width:600px;'>" +
      "Jeder Spieler wÃ¼rfelt <span style='color:#006080;font-weight:bold;'>5Ã— mit allen 5 WÃ¼rfeln</span>.<br>" +
      "Nach jeder Runde wird das Ergebnis in die Tabelle eingetragen.<br><br>" +

      "<span style='color:#2e7d32;font-weight:bold;'>âœ”ï¸ Jede Kombination</span> darf <b>nur 1Ã—</b> gewÃ¤hlt werden.<br>" +
      "<span style='color:#d32f2f;font-weight:bold;'>âŒ Ausnahme:</span> <span style='color:#000;'>Niete (0 â‚¬)</span> darf bis zu <b>5Ã—</b> gewÃ¤hlt werden.<br><br>" +

      "<span style='color:#fbc02d;font-weight:bold;'>â­ Bonus:</span> Wer " +
      "<span style='color:#9c27b0;font-weight:bold;'>5Ã— Niete</span> schafft, gewinnt automatisch " +
      "<span style='color:#1e88e5;font-weight:bold;'>200 â‚¬</span>!<br><br>" +

      "<span style='color:#00897b;font-weight:bold;'>â¡ï¸ Ende:</span> Nach <b>5 EintrÃ¤gen</b> ist das Spiel vorbei.<br><br>" +
	  " Der Einsatz betrÃ¤gt <span style='color:#e53935;'><b>50 â‚¬</b></span> wird aber Automatisch abgezogen" +
    "</div>";
  break;
case "allnothing":
  text = "ğŸ² <b>All or Nothing:</b><br>" +
    "Du Bezahlst am Anfang 20 â‚¬.<br>" +
    "DrÃ¼cke auf <b>All or Nothing</b>:<br>" +
    "âœ… Gewinn = 40 â‚¬ Auszahlung<br>" +
    "âŒ Verlust = 0 â‚¬<br><br>" +
    "Reine 50/50-Chance!";
  break;

case "home":
  text = "ğŸ  <b>Ziel des Spiels:</b><br>" +
    "<div style='text-align:left;margin:10px auto;max-width:600px;'>" +
      "Sammle Geld, setze es in verschiedenen GlÃ¼cksspielen ein und sichere dir TrophÃ¤en.<br>" +
      "Mit deinem gewonnenen Geld kannst du Artefakte kaufen und sie zusammen mit deinen gewonnenen TrophÃ¤en zu neuen Statuen craften.<br>" +
      "So entsteht nach und nach dein eigenes Museum.<br><br>" +
      "<b>Das groÃŸe Ziel:</b><br>" +
      "Wer es schafft, sein Museum mit allen vier Statuen von der Steintafel zu fÃ¼llen " +
      "und zusÃ¤tzlich den goldenen WÃ¼rfel auszustellen, gewinnt das Spiel." +
    "</div>";
  break;

case "settings":
  text = "âš™ï¸ <b>Einstellungen:</b><br>" +
    "<div style='text-align:left;margin:10px auto;max-width:600px;'>" +
      "Hier kannst du festlegen, ob du extern wÃ¼rfeln mÃ¶chtest oder direkt in der App.<br><br>" +
      "<b>Spieler verwalten:</b><br>" +
      "Alte Spieler lÃ¶schen, Spieler umbenennen oder neue Spieler anlegen.<br><br>" +
      "<b>Statistik:</b><br>" +
      "Sieh nach, wie oft du in jedem Spiel gespielt hast â€“ sowohl in dieser Session als auch insgesamt seit Beginn des Spiels.<br><br>" +
      "<b>Ereignisverlauf:</b><br>" +
      "Hier erkennst du, wer ein Artefakt gekauft oder eine Ereigniskarte gezogen hat.<br>" +
      "Das ist hilfreich, falls du den Effekt einer Karte noch einmal nachlesen mÃ¶chtest.<br>" +
      "AuÃŸerdem wird angezeigt, wer eine TrophÃ¤e erhalten hat." +
    "</div>";
  break;

case "eventcard":
  text = "ğŸ´ <b>Ereigniskarten:</b><br>" +
    "<div style='text-align:left;margin:10px auto;max-width:600px;'>" +
      "Kaufe eine Ereigniskarte fÃ¼r <b>10 â‚¬</b>. AnschlieÃŸend ziehst du eine Karte.<br><br>" +
      "ğŸ‘‰ Steht auf der Karte nur der Button <b>â€Jetzt einlÃ¶senâ€œ</b>, musst du den Effekt sofort anwenden. " +
      "Im Ereignisverlauf wird angezeigt, welche Karte du eingelÃ¶st hast.<br><br>" +
      "ğŸ‘‰ Steht auf der Karte nur der Button <b>â€Jetzt sichernâ€œ</b>, kannst du die Karte in dein Inventar legen " +
      "und sie zu einem spÃ¤teren Zeitpunkt einlÃ¶sen.<br><br>" +
      "ğŸ‘‰ Sind beide Buttons vorhanden (<b>â€Jetzt einlÃ¶senâ€œ</b> und <b>â€Jetzt sichernâ€œ</b>), kannst du selbst entscheiden, " +
      "ob du den Effekt sofort nutzt oder die Karte fÃ¼r spÃ¤ter aufbewahrst." +
    "</div>";
  break;

case "inventory":
  text = "ğŸ’ <b>Inventar:</b><br>" +
    "<div style='text-align:left;margin:10px auto;max-width:600px;'>" +
      "Hier siehst du alle deine <b>gesicherten Ereigniskarten</b>.<br>" +
      "Du kannst sie jederzeit aus dem Inventar heraus einlÃ¶sen." +
    "</div>";
  break;

case "artefaktum":
  text = "ğŸ—¿ <b>Artefaktum:</b><br>" +
    "<div style='text-align:left;margin:10px auto;max-width:600px;'>" +
      "Hier kannst du eines oder mehrere der <b>drei angebotenen Artefakte</b> kaufen.<br>" +
      "Jedes Artefakt kostet <b>50 â‚¬</b>.<br><br>" +
      "Die Auswahl an Artefakten <b>wechselt regelmÃ¤ÃŸig</b>, sodass immer neue MÃ¶glichkeiten entstehen." +
    "</div>";
  break;

    default:
      text = "â„¹ï¸ Keine Hilfe verfÃ¼gbar.";
  }

  const overlay = document.createElement("div");
  overlay.className = "help-overlay";
  overlay.innerHTML = `
    <div class="help-box">
      <div class="help-header">
        <h2>â„¹ï¸ Spielinformationen</h2>
        <div class="help-close" onclick="closeHelp(this)">âœ–</div>
      </div>
      <div>${text.replace(/\n/g, "<br>")}</div>
    </div>
  `;
  document.body.appendChild(overlay);
}

function closeHelp(el) {
  document.body.removeChild(el.closest(".help-overlay"));
}

function enablePlayerDragDrop() {
  const list = document.getElementById("playerList");
  let draggingRow = null;

  // Drag nur am Griff starten
  list.querySelectorAll(".drag-handle").forEach(handle => {
    handle.addEventListener("dragstart", e => {
      draggingRow = handle.closest(".player-row");
      e.dataTransfer.effectAllowed = "move";
      e.dataTransfer.setData("text/plain", "drag");
    });
  });

  // Droppen auf Zeilen
  list.querySelectorAll(".player-row").forEach(row => {
    row.addEventListener("dragover", e => e.preventDefault());
    row.addEventListener("drop", e => {
      e.preventDefault();
      if (!draggingRow || draggingRow === row) return;

      const all = Array.from(list.children);
      const from = all.indexOf(draggingRow);
      const to   = all.indexOf(row);
      if (from < to) row.after(draggingRow);
      else row.before(draggingRow);

      // Array entsprechend neu bauen (nach DOM)
      playerNames = Array.from(list.querySelectorAll(".player-row input")).map(inp => inp.value.trim());
      managePlayers();
    });
  });
}

/* ===== Helpers ===== */
function getRandomIntInclusive(min, max) {
  const lo = Math.ceil(min);
  const hi = Math.floor(max);
  return Math.floor(Math.random() * (hi - lo + 1)) + lo;
}

// === Auktion: Chance berechnen anhand der Distanz zum Geheimpreis ===
// Beispiel: secret=40, bid=20  -> |40-20|/40*100 = 50%
//          secret=24, bid=20   -> |24-20|/24*100 â‰ˆ 16.7%
//          secret=90, bid=20   -> |90-20|/90*100 â‰ˆ 77.8%
function calcAuctionTrophyChance(bid, secret) {
  const denom = Math.max(1, Number(secret) || 0); // nie durch 0 teilen
  const dist  = Math.abs((Number(secret) || 0) - (Number(bid) || 0));
  const pct   = Math.round((dist / denom) * 100);
  return Math.min(100, Math.max(0, pct));
}

// Lucky Streak â€“ TrophÃ¤en-Chance: linear bis 21 â‚¬ (erste Summe > 20 â‚¬)
function streakTrophyChance(finalWin, cap = 21) {
  const w = Math.max(0, Number(finalWin) || 0);
  return Math.round(Math.min(100, (w / cap) * 100));
}

/* === Lucky Streak: TrophÃ¤en nach finalem Gewinn bewerten === */
function streakTrophyOutcome(finalWin, player) {
  const w = Math.max(0, Number(finalWin) || 0);
  // Standard-Text
  let msg = "âŒ Du hast keine TrophÃ¤e gewonnen.";

  if (w > 20) {
    // Sicher ab > 20 â‚¬
    if (typeof awardTrophies === "function") awardTrophies(player, 1);
    msg = "ğŸ† Du hast eine TrophÃ¤e gewonnen.";
  } else if (w > 0) {
    // Linear bis 20 â‚¬ (10 â‚¬ = 50 %, 20 â‚¬ = 100 %)
    const chance = Math.min(100, Math.round((w / 20) * 100));
    if (Math.random() * 100 < chance) {
      if (typeof awardTrophies === "function") awardTrophies(player, 1);
      msg = "ğŸ† Du hast eine TrophÃ¤e gewonnen.";
    }
  }
  return msg;
}

// Vergibt ggf. 1 TrophÃ¤e und gibt eine kurze Zeile fÃ¼rs UI zurÃ¼ck.
// Keine Prozent-Ausgabe.
function maybeAwardStreakTrophy(finalWin, player = (playerNames[0] || "Spieler")) {
  if (finalWin <= 0) return "";           // bei 0 â‚¬ nichts anzeigen

  if (finalWin >= 21) {                   // garantiert ab >20 â‚¬
    awardTrophies(player, 1);
    return "ğŸ† TrophÃ¤e erhalten";
  }

  const chance = streakTrophyChance(finalWin, 21);
  if (Math.random() * 100 < chance) {
    awardTrophies(player, 1);
    return "ğŸ† TrophÃ¤e erhalten";
  }
  return "âŒ Keine TrophÃ¤e";
}

// Glatte Kurve fÃ¼r < 50 â‚¬: bis 25 â‚¬ linear, danach "ease-out" steiler.
// Beispiele: 25â‚¬ â†’ 50%, 45â‚¬ â†’ ~99%, 0â‚¬ â†’ 0%, 50â‚¬+ â†’ 100%
function trophyChanceByNet(net, cap = 50) {
  const n = Math.max(0, Number(net) || 0);
  if (n <= 0) return 0;
  if (n >= cap) return 100;

  const half = cap / 2; // 25 bei cap=50
  if (n <= half) {
    // 0..25 â‚¬ â†’ 0..50 % (linear)
    return Math.round((n / cap) * 100);
  }
  // 25..50 â‚¬ â†’ 50..100 % mit Ease-Out (p=3)
  const t = (n - half) / half;            // 0..1
  const eased = 1 - Math.pow(1 - t, 3);   // easeOutCubic
  return Math.min(100, Math.round(50 + 50 * eased));
}

// Vergibt TrophÃ¤en anhand der AUSZAHLUNG (payout), nicht netto.
// Regel: payout >= 50 â‚¬ -> 100% sicher, darunter Kurve (trophyChanceByNet).
function awardTrophiesByBetPayout(game, player, bet, payout) {
  const p = Math.max(0, Number(payout) || 0);

  let drop = 0;
  let chance = trophyChanceByNet(p, 50);

  // Sicher ab 50 â‚¬
  if (p >= 50) {
    drop = 1;
  } else if (p > 0) {
    if (Math.random() * 100 < chance) drop = 1;
  } else {
    chance = 0;
  }

  if (drop > 0) {
    awardTrophies(player, drop);
    // Optional: kurzes Log (falls du das hier mÃ¶chtest)
    const now = new Date();
    eventLog.unshift({
      player,
      text: `ğŸ† ${drop} TrophÃ¤e${drop>1?"n":""} erhalten`,
      time: now.toLocaleTimeString()
    });
  }

  return { drop, chance, payout: p };
}

/* ===== Lotto ===== */
function startLotto() {
  currentContext = "lotto";

  if (!lottoState.active || lottoState.ended) {
    const startIdx = (playerNames && playerNames.length)
      ? getRandomIntInclusive(0, playerNames.length - 1)
      : 0;

    lottoState = {
      numbers: Array.from({ length: 4 }, () => ({
        value: getRandomIntInclusive(1, 6),
        done: false
      })),
      winner: null,
      trophyWon: null,     // <â€” NEU: wird am Ende gesetzt (true/false)
      active: true,
      ended: false,
      turnIndex: startIdx,
      activeIdx: 0
    };
  }

  renderLottoUI();
}

function getLastDoneIndex() {
  let last = -1;
  for (let i = 0; i < lottoState.numbers.length; i++) {
    if (lottoState.numbers[i].done) last = i;
  }
  return last;
}

// Einzelne Kachel rendern
function renderTile(num, idx) {
  // Statusklasse ermitteln
  let cls = "open";
  if (num.done) cls = "done";
  else if (idx === lottoState.activeIdx) cls = "active";

  // Klickbarkeit: 
  // - setzen: nur aktive (blaue) offene Zahl
  // - rÃ¼ckgÃ¤ngig: nur zuletzt gesetzte grÃ¼ne Zahl
  const lastDone = getLastDoneIndex();
  const isClickable =
    (!num.done && idx === lottoState.activeIdx) ||
    (num.done && idx === lastDone);

  const onClick = isClickable ? `onclick="attemptToggle(${idx})"` : "";
  const clickableClass = isClickable ? "clickable" : "";

  return `
    <div class="lotto-tile">
      <div class="lotto-num ${cls} ${clickableClass}" ${onClick}>${num.value}</div>
    </div>
  `;
}

function attemptToggle(idx) {
  if (lottoState.ended) return;

  const n = lottoState.numbers[idx];

  if (!n.done) {
    // Ã¶ffnen (ğŸ”³ -> âœ…) nur bei aktiver blauer Zahl
    if (idx !== lottoState.activeIdx) return;
    toggleActiveCheck(idx);
    return;
  }

  // rÃ¼ckgÃ¤ngig (âœ… -> ğŸ”³) nur bei der zuletzt gesetzten grÃ¼nen
  const last = getLastDoneIndex();
  if (idx !== last) return;
  undoLastDone(idx);
}

function renderLottoUI() {
  const app = document.getElementById("app-section");
  if (!app) return;

  // === GEWINN-SCREEN ===
  if (lottoState.winner) {
    const trophyLine =
      lottoState.trophyWon === true
        ? `<p style="margin:4px 0 12px;">ğŸ… Du hast eine TrophÃ¤e gewonnen.</p>`
        : `<p style="margin:4px 0 12px;">âŒ Du hast keine TrophÃ¤e gewonnen.</p>`;

    app.innerHTML = `
      <div class="lotto-area">
        <div class="lotto-header">
          <!-- Links: Neue Runde -->
          <div class="icon-btn" onclick="startLotto()" title="Neue Runde">ğŸ”</div>
          <div class="lotto-title">ğŸ¯ Lotto</div>
          <!-- Rechts: SchlieÃŸen -->
          <div class="icon-btn" onclick="showHome()" title="SchlieÃŸen">âœ–</div>
        </div>

        <div class="lotto-player" style="margin-top:8px;">${lottoState.winner}</div>
        <p style="margin:6px 0 6px;">gewinnt den Pot! ğŸ†</p>
        ${trophyLine}
      </div>
    `;
    return;
  }

  // === LAUFENDE RUNDE ===
  const pn = (playerNames && playerNames.length) ? playerNames : ["Spieler"];
  const currentPlayer = pn[lottoState.turnIndex % pn.length];

  const tiles = lottoState.numbers.map((n, i) => {
    const cls = n.done ? "done" : (i === lottoState.activeIdx ? "active" : "open");
    return `<div class="lotto-num ${cls}" onclick="attemptToggle(${i})">${n.value}</div>`;
  }).join("");

  app.innerHTML = `
    <div class="lotto-area">
      <div class="lotto-header">
        <!-- Links: NÃ¤chster Spieler -->
        <div class="icon-btn" onclick="nextPlayer()" title="NÃ¤chster Spieler">ğŸ‘¤</div>
        <div class="lotto-title">ğŸ¯ Lotto</div>
        <!-- Rechts: SchlieÃŸen -->
        <div class="icon-btn" onclick="showHome()" title="SchlieÃŸen">âœ–</div>
      </div>

      <div class="lotto-player">${currentPlayer}</div>
      <div class="lotto-grid">${tiles}</div>
    </div>
  `;
}

function toggleActiveCheck(idx) {
  if (lottoState.ended) return;
  if (idx !== lottoState.activeIdx) return;

  const n = lottoState.numbers[idx];
  if (!n || n.done) return;

  // Zahl setzen
  n.done = true;

  // PrÃ¼fen, ob alle gesetzt sind
  const allDone = lottoState.numbers.every(x => x && x.done === true);
  if (allDone) {
    const pn = (playerNames && playerNames.length) ? playerNames : ["Spieler"];
    const winnerName = pn[lottoState.turnIndex % pn.length];

    lottoState.winner = winnerName;
    lottoState.ended = true;

    // 50%-Chance auf TrophÃ¤e
    lottoState.trophyWon = Math.random() < 0.5;

    // Stats/TrophÃ¤en nur ausfÃ¼hren, wenn vorhanden â€” niemals Spielabbruch
    if (typeof safeIncreaseStat === "function") safeIncreaseStat("lotto");
    else if (typeof increaseStat === "function") { try { increaseStat("lotto"); } catch(e){ console.warn(e); } }

    if (lottoState.trophyWon) {
      if (typeof safeCalcTrophyDrop === "function") safeCalcTrophyDrop("lotto", winnerName);
      else if (typeof calcTrophyDrop === "function") { try { calcTrophyDrop("lotto", winnerName); } catch(e){ console.warn(e); } }
    }

    // Direkt Endscreen rendern
    return renderLottoUI();
  }

  // NÃ¤chster Spieler & nÃ¤chste offene Zahl aktivieren
  const pn = (playerNames && playerNames.length) ? playerNames : ["Spieler"];
  lottoState.turnIndex = (lottoState.turnIndex + 1) % pn.length;

  const nextOpen = lottoState.numbers.findIndex((z, i) => !z.done && i > idx);
  if (nextOpen !== -1) lottoState.activeIdx = nextOpen;

  renderLottoUI();
}

function undoLastDone(idx) {
  // Nur letzte grÃ¼ne Zahl darf rÃ¼ckgÃ¤ngig sein â€“ das ist bereits in attemptToggle geprÃ¼ft
  const n = lottoState.numbers[idx];
  n.done = false;

  // Aktive (blaue) Zahl wird diese eben geÃ¶ffnete Position
  lottoState.activeIdx = idx;

  // KEIN Spielerwechsel beim RÃ¼ckgÃ¤ngig-machen
  renderLottoUI();
}

function checkActive(idx) {
  const activeIdx = lottoState.numbers.findIndex(n => !n.done);
  if (idx !== activeIdx || lottoState.ended) return;

  const n = lottoState.numbers[idx];
  n.done = true;
  n.checkedBy = playerNames[lottoState.turnIndex % playerNames.length];

  if (lottoState.numbers.every(x => x.done)) {
    lottoState.winner = n.checkedBy || "Spieler";
    lottoState.ended = true;
  } else {
    lottoState.turnIndex = (lottoState.turnIndex + 1) % playerNames.length;
  }
  renderLottoUI();
}

function nextPlayer() {
  if (lottoState.ended) return;

  // Wenn die aktuelle Zahl erledigt ist, blau auf die nÃ¤chste offene schieben
  if (lottoState.numbers[lottoState.activeIdx]?.done) {
    const nextOpen = lottoState.numbers.findIndex((z, i) => !z.done && i > lottoState.activeIdx);
    if (nextOpen !== -1) {
      lottoState.activeIdx = nextOpen;
    } else {
      // keine weitere offene Zahl -> ggf. schon als Sieger markiert
      // (falls noch nicht gesetzt, nicht beenden â€“ der Haken bestimmt den Sieger)
    }
  }

  // Spieler reihum
  lottoState.turnIndex = (lottoState.turnIndex + 1) % playerNames.length;
  renderLottoUI();
}

// ==== SAFE HELPERS (optional, aber empfohlen) ====
function safeIncreaseStat(mode) {
  try {
    if (typeof increaseStat === "function") increaseStat(mode);
  } catch (e) {
    console.warn("increaseStat() schlug fehl:", e);
  }
}
function safeCalcTrophyDrop(mode, winnerName) {
  try {
    if (typeof calcTrophyDrop === "function") calcTrophyDrop(mode, winnerName);
  } catch (e) {
    console.warn("calcTrophyDrop() schlug fehl:", e);
  }
}

/* â€” Damit showHome/Buttons SICHER dieses Poker verwenden â€” */
window.startPoker = startPoker;

/* â€” Damit showHome/Buttons SICHER dieses Poker verwenden â€” */
window.startPoker = startPoker;

/* ===== Battle (wie gehabt) ===== */
function startBattle() {
  currentContext = "battle";
  document.getElementById("app-section").innerHTML = `
    <div class="auction-header">
      <div class="auction-title">âš”ï¸ Battle</div>
      <div class="icon-btn" onclick="showHome()">âœ–</div>
    </div>

    <div class="battle-wrap">
      <div class="section">
        <div class="row">
          <div style="flex:1;">
            <div class="small">Herausforderer</div>
            <select id="challenger">${playerNames.map(n=>`<option value="${n}">${n}</option>`).join("")}</select>
          </div>
          <div style="flex:1;">
            <div class="small">Gegner</div>
            <select id="opponent">${playerNames.map(n=>`<option value="${n}">${n}</option>`).join("")}</select>
          </div>
        </div>

        <div class="row">
          <div>
            <div class="small">Einsatz</div>
            <label class="input-eur">
              <input type="number" id="wager" min="1" step="1" placeholder="Betrag">
              <span>â‚¬</span>
            </label>
          </div>

          <div style="margin-left:auto;">
            <div class="small">Modus</div>
            <div class="row">
              <div id="modeHighest" class="mode-btn active" onclick="setBattleMode('highest')">HÃ¶chste Zahl</div>
              <div id="modeLowest" class="mode-btn" onclick="setBattleMode('lowest')">Kleinste Zahl</div>
            </div>
          </div>
        </div>

        <div id="battleError" class="error" style="display:none;"></div>
      </div>

      <div class="section">
        <div class="row" style="justify-content:center;">
          <div class="button" id="battleRollBtn" onclick="doBattleAnimated()">WÃ¼rfeln</div>
        </div>
        <div id="battleOutcome" style="margin-top:10px;"></div>
      </div>
    </div>
  `;
}

function setBattleMode(mode) {
  battleState.mode = mode;
  const hi = document.getElementById('modeHighest');
  const lo = document.getElementById('modeLowest');
  if (hi && lo) { hi.classList.toggle('active', mode==='highest'); lo.classList.toggle('active', mode==='lowest'); }
}
function showBattleError(msg) {
  const el = document.getElementById('battleError');
  if (!el) return;
  el.textContent = msg || "";
  el.style.display = msg ? 'block' : 'none';
}
function rollDie(max=6) { return Math.floor(Math.random() * max) + 1; }
function doBattle() {
  const challenger = document.getElementById('challenger').value;
  const opponent   = document.getElementById('opponent').value;
  const wager      = Number(document.getElementById('wager').value);
  if (!challenger || !opponent) { showBattleError('Bitte beide Spieler wÃ¤hlen.'); return; }
  if (challenger === opponent)  { showBattleError('Herausforderer und Gegner mÃ¼ssen unterschiedlich sein.'); return; }
  if (!wager || wager <= 0)     { showBattleError('Bitte einen gÃ¼ltigen Einsatz (> 0) eingeben.'); return; }
  showBattleError('');

  const a = rollDie(6), b = rollDie(6);
  let winner = null;
  if (battleState.mode === 'highest') { if (a>b) winner=challenger; else if (b>a) winner=opponent; }
  else { if (a<b) winner=challenger; else if (b<a) winner=opponent; }

  const out = document.getElementById('battleOutcome');
  if (!winner) out.innerHTML = `ğŸ² ${challenger} wÃ¼rfelt <b>${a}</b> | ${opponent} <b>${b}</b><br><span class="small">Unentschieden â€“ bitte nochmal.</span>`;
  else {
    const loser = (winner===challenger)?opponent:challenger;
    out.innerHTML = `ğŸ² ${challenger} wÃ¼rfelt <b>${a}</b> | ${opponent} <b>${b}</b><br><b>${winner}</b> gewinnt <b>${wager} â‚¬</b> von ${loser}.`;
  }
}

/* ===== Roulette Logik ===== */

function ensureRouletteReady() {
  // Reihenfolge + SegmentgrÃ¶ÃŸe bereitstellen, falls noch nicht definiert
  if (!window.ROULETTE_ORDER) window.ROULETTE_ORDER = [1,2,3,4,5,6,7,8,9,10,11,12];
  if (!window.ROULETTE_SEG_DEG) window.ROULETTE_SEG_DEG = 360 / window.ROULETTE_ORDER.length;

  // State anlegen, falls noch nicht initialisiert (z. B. wegen frÃ¼herem Fehler im Script)
  if (typeof window.rouletteState !== "object" || window.rouletteState === null) {
    window.rouletteState = {
      betType: null,
      betNumber: null,
      stake: null,
      rotation: 0,
      spinning: false,
      stakeSet: false,
      currentPlayerIdx: null,
      _tempBetType: null
    };
  }
}

function startRoulette(){
  ensureRouletteReady();
  currentContext = "roulette";
  document.getElementById("app-section").innerHTML = `
    <div class="auction-header">
      <div class="auction-title">ğŸ¡ Roulette</div>
      <div class="icon-btn" onclick="showHome()">âœ–</div>
    </div>

    <div class="roulette-wrap">
      <div id="rouletteWheel" class="roulette-wheel"></div>
      <div id="rouletteBallContainer" class="roulette-ball-container">
        <div id="rouletteBall" class="roulette-ball"></div>
      </div>
    </div>

    <div class="roulette-grid">
      <div id="btnEven"  class="roulette-btn" onclick="rouletteSelect('even')">Gerade</div>
      <div id="btnOdd"   class="roulette-btn" onclick="rouletteSelect('odd')">Ungerade</div>
      <div id="btnRed"   class="roulette-btn" onclick="rouletteSelect('red')">Rot</div>
      <div id="btnBlack" class="roulette-btn" onclick="rouletteSelect('black')">Schwarz</div>

      <div class="roulette-number-green-row">
        <input id="rouletteNumber" type="number" min="1" max="12" step="1"
               placeholder="" oninput="rouletteSetNumber(this.value)">
        <div id="btnNumber" class="roulette-btn" onclick="rouletteSelect('number')">Setzen</div>
        <div id="btnGreen" class="roulette-btn wide" onclick="rouletteSelect('green')">GrÃ¼n</div>
      </div>
    </div>

    <div class="action-row">
      <div id="playBtn"  class="roulette-btn disabled" onclick="rouletteSpin()">Spielen</div>
      <div id="stakeBtn" class="roulette-btn" onclick="openStakeModal()">Einsatz</div>
    </div>
    <div id="warnMsg">Du musst zuerst eine Wette setzen und den Einsatz festlegen.</div>

    <!-- Ergebnis-Modal -->
    <div id="resultModal" class="modal-backdrop" style="display:none;">
      <div class="modal">
        <h2>Runden-Ergebnis</h2>
        <div id="resultSummary" class="hint" style="margin-top:6px;"></div>
        <div class="modal-actions" style="margin-top:12px;">
          <button class="btn primary" onclick="closeResultModal()">OK</button>
        </div>
      </div>
    </div>

    <!-- Einsatz-Modal -->
    <div id="stakeModal" class="modal-backdrop" style="display:none;">
      <div class="modal">
        <h2>Einsatz wÃ¤hlen</h2>
        <div class="hint">Gib deinen Einsatz (â‰¥1 â‚¬) ein.</div>
        <div class="field">
          <label for="stakeInput">Einsatz (â‚¬)</label>
          <input id="stakeInput" type="number" min="1" step="1" value="1" />
        </div>
        <div id="modalError" class="error"></div>
        <div class="modal-actions">
          <button class="btn" onclick="closeStakeModal()">Abbrechen</button>
          <button class="btn primary" onclick="submitStake()">Einsatz setzen</button>
        </div>
      </div>
    </div>
  `;

  // State zurÃ¼cksetzen
  rouletteState.betType = null;
  rouletteState.betNumber = null;
  rouletteState.stake = null;
  rouletteState.rotation = 0;
  rouletteState.spinning = false;
  rouletteState.stakeSet = false;
  rouletteState.currentPlayerIdx = null;
  rouletteState._tempBetType = null;

  renderWheel();
  enablePlayIfReady();
}

/* ===== Roulette: Konstanten & State ===== */
const ROULETTE_ORDER = [1,2,3,4,5,6,7,8,9,10,11,12];
const ROULETTE_SEG_DEG = 360 / ROULETTE_ORDER.length;

function rouletteColor(n){ return n===1 ? 'green' : (n%2===0 ? 'red' : 'black'); }

let rouletteState = {
  betType:null,
  betNumber:null,
  stake:null,
  rotation:0,
  spinning:false,
  stakeSet:false,
  currentPlayerIdx:null,
  _tempBetType:null
};

/* ===== Rad zeichnen ===== */
function renderWheel(){
  const wheel = document.getElementById("rouletteWheel");
  if(!wheel) return;
  const grad = ROULETTE_ORDER.map((n,i)=>{
    const col = rouletteColor(n)==='green' ? '#1eaf5a' : (rouletteColor(n)==='red' ? '#e74c3c' : '#2c3e50');
    const a0 = i * ROULETTE_SEG_DEG;
    const a1 = (i+1) * ROULETTE_SEG_DEG;
    return `${col} ${a0}deg ${a1}deg`;
  }).join(',');
  wheel.style.background = `conic-gradient(${grad})`;

  const START_OFFSET = -90;
  const BORDER = 6, INNER = 6, labelOffset = 26;
  const RADIUS = wheel.clientWidth/2 - BORDER - INNER - labelOffset;

  wheel.innerHTML = ROULETTE_ORDER.map((n,i)=>{
    const mid = (i + 0.5) * ROULETTE_SEG_DEG + START_OFFSET;
    return `<div class="roulette-numlabel"
      style="transform: translate(-50%,-50%) rotate(${mid}deg) translate(${RADIUS}px) rotate(${-mid}deg);">
      ${n}
    </div>`;
  }).join('');
}

/* ===== Helpers ===== */
function getRotationDegrees(el){
  const tr = getComputedStyle(el).getPropertyValue("transform");
  if (tr === "none") return 0;
  const [a,b] = tr.slice(7,-1).split(',').map(parseFloat);
  let angle = Math.round(Math.atan2(b,a) * (180/Math.PI));
  return (angle<0 ? angle+360 : angle);
}
function getResult(ballAngle, wheelAngle){
  let rel = ((ballAngle - wheelAngle + 90) % 360 + 360) % 360;
  const idx = Math.floor(rel / ROULETTE_SEG_DEG);
  return ROULETTE_ORDER[idx];
}
function jackpotTrophyChance(bet, cap = 50) {
  const b = Math.max(0, Number(bet) || 0);
  const pct = Math.round(Math.min(100, (b / cap) * 100));
  return pct;
}

/* ===== Auswahl & UI ===== */
function clearActive(){ document.querySelectorAll('.roulette-btn').forEach(b=>b.classList.remove('active')); }

function enablePlayIfReady(){
  const play = document.getElementById('playBtn');
  const warn = document.getElementById('warnMsg');
  if(!play || !warn) return;

  const numberOk = (rouletteState.betType!=='number') || (rouletteState.betNumber>=1 && rouletteState.betNumber<=12);
  const playerOk = (rouletteState.currentPlayerIdx !== null && rouletteState.currentPlayerIdx >= 0);
  const ready = !!rouletteState.betType && rouletteState.stakeSet && numberOk && playerOk;

  play.classList.toggle('disabled', !ready);
  warn.textContent = ready ? '' : 'Du musst zuerst eine Wette, den Einsatz und den Spieler festlegen.';
}

function rouletteSetNumber(v){
  const n = parseInt(v,10);
  if(!isNaN(n)) rouletteState.betNumber = n;
  enablePlayIfReady();
}
function rouletteSelect(type){
  clearActive();
  const idMap = { even:'btnEven', odd:'btnOdd', red:'btnRed', black:'btnBlack', green:'btnGreen', number:'btnNumber' };
  const elId = idMap[type];
  if (elId){ const el = document.getElementById(elId); if(el) el.classList.add('active'); }
  rouletteState.betType = type;
  enablePlayIfReady();
}

/* ===== Modals ===== */
function openStakeModal(){
  const m = document.getElementById('stakeModal');
  if(!m) return;

  const err = document.getElementById('modalError');
  if (err) err.textContent = '';

  let playerRow = document.getElementById('stakePlayerRow');
  if (!playerRow) {
    const modalBox = m.querySelector('.modal');
    const actions  = m.querySelector('.modal-actions');

    playerRow = document.createElement('div');
    playerRow.className = 'field';
    playerRow.id = 'stakePlayerRow';
    playerRow.innerHTML = `
      <label for="stakePlayerSel">Spieler</label>
      <select id="stakePlayerSel"></select>
    `;
    if (modalBox && actions) modalBox.insertBefore(playerRow, actions);
  }

  const sel = document.getElementById('stakePlayerSel');
  if (sel) {
    sel.innerHTML = playerNames
      .map((n,i)=>`<option value="${i}" ${rouletteState.currentPlayerIdx===i?'selected':''}>${n}</option>`)
      .join('');
  }

  m.style.display = 'flex';
  const input = document.getElementById('stakeInput');
  if (input) { input.focus(); input.select(); }
}
function closeStakeModal(){ const m = document.getElementById('stakeModal'); if(m) m.style.display='none'; }
function openResultModal(html){
  const m = document.getElementById('resultModal');
  const t = document.getElementById('resultSummary');
  if(!m || !t) return;
  t.innerHTML = html;
  m.style.display = 'flex';
}
function closeResultModal(){ const m = document.getElementById('resultModal'); if(m) m.style.display='none'; }

function submitStake(){
  const errEl = document.getElementById('modalError');

  const stake = parseInt(document.getElementById('stakeInput').value,10);
  if (isNaN(stake) || stake < 1){
    if (errEl) errEl.textContent = 'Bitte einen Einsatz von mindestens 1 â‚¬ eingeben.';
    return;
  }

  const sel = document.getElementById('stakePlayerSel');
  const idx = sel ? parseInt(sel.value,10) : NaN;
  if (isNaN(idx)) {
    if (errEl) errEl.textContent = 'Bitte einen Spieler auswÃ¤hlen.';
    return;
  }

  rouletteState.stake = stake;
  rouletteState.stakeSet = true;
  rouletteState.currentPlayerIdx = idx;

  closeStakeModal();
  enablePlayIfReady();
}

function colorDe(c){ return c==='red'?'rot':c==='black'?'schwarz':c==='green'?'grÃ¼n':c; }

/* ===== Spin ===== */
async function rouletteSpin(){
  const play = document.getElementById('playBtn');
  if (!play || play.classList.contains('disabled') || rouletteState.spinning) return;

  rouletteState.spinning = true;
  play.classList.add('disabled');

  try {
    const wheel = document.getElementById("rouletteWheel");
    const ballC = document.getElementById("rouletteBallContainer");
    const ball  = document.getElementById("rouletteBall");

    const wheelTarget = rouletteState.rotation + 1080 + Math.random()*360;
    const ballTarget  = Math.random()*360;

    wheel.style.transition = "transform 3s cubic-bezier(.1,.7,.3,1)";
    wheel.style.transform  = `rotate(${wheelTarget}deg)`;

    ballC.style.transition = "transform 3s cubic-bezier(.1,.7,.3,1)";
    ballC.style.transform  = `rotate(${ballTarget}deg)`;

    const radius = (wheel.clientWidth/2) - 20;
    ball.style.transition  = "transform 0.6s cubic-bezier(.2,.8,.2,1)";
    ball.style.transform   = `translate(-50%,-50%) translateX(${radius}px)`;

    rouletteState.rotation = wheelTarget;

    await new Promise(r=>setTimeout(r, 3000));

    const wheelDeg = getRotationDegrees(wheel);
    const ballDeg  = getRotationDegrees(ballC);
    const result   = getResult(ballDeg, wheelDeg);
    const color    = rouletteColor(result);

    const idx = ROULETTE_ORDER.indexOf(result);
    let midAngle = wheelDeg - 90 + (idx + 0.5) * ROULETTE_SEG_DEG;
    const current = getRotationDegrees(ballC);
    while (midAngle - current > 180) midAngle -= 360;
    while (midAngle - current < -180) midAngle += 360;
    ballC.style.transition = "transform 0.25s ease-out";
    ballC.style.transform  = `rotate(${midAngle}deg)`;

    const betTxt = (() => {
      switch(rouletteState.betType){
        case 'odd':   return 'Ungerade';
        case 'even':  return 'Gerade';
        case 'red':   return 'Rot';
        case 'black': return 'Schwarz';
        case 'green': return 'GrÃ¼n';
        case 'number':return `Zahl ${rouletteState.betNumber ?? 'â€”'}`;
        default:      return 'â€”';
      }
    })();

    const won = (() => {
      if (rouletteState.betType==='number') return result===rouletteState.betNumber;
      if (rouletteState.betType==='green')  return result===1;
      if (rouletteState.betType==='red')    return color==='red';
      if (rouletteState.betType==='black')  return color==='black';
      if (rouletteState.betType==='even')   return result%2===0;
      if (rouletteState.betType==='odd')    return result%2===1;
      return false;
    })();

    const mult = (() => {
      if (rouletteState.betType==='number') return 50;
      if (rouletteState.betType==='green')  return 30;
      if (['red','black','even','odd'].includes(rouletteState.betType)) return 2;
      return 0;
    })();
    const payout = won ? (rouletteState.stake || 0) * mult : 0;

    const player = playerNames[rouletteState.currentPlayerIdx ?? 0] || "Spieler";

    let trophies = 0;
    if (won) {
      if (['even','odd','red','black'].includes(rouletteState.betType)) {
        trophies = 1;
      } else if (rouletteState.betType === 'green' || rouletteState.betType === 'number') {
        trophies = 10;
      }
    }
    if (trophies > 0) awardTrophies(player, trophies);

    await new Promise(r=>setTimeout(r, 3000));
    ball.style.transition = "transform 0.4s cubic-bezier(.33,1,.68,1)";
    ball.style.transform  = "translate(-50%,-50%)";
    await new Promise(r=>setTimeout(r, 450));

    openResultModal(
      `Du hast <b>${result} ${colorDe(color)}</b>.<br>
       <b>Deine Wette:</b> ${betTxt}.<br>
       <b>Spieler:</b> ${player}.<br>
       <b>Einsatz:</b> ${rouletteState.stake}â‚¬.<br>
       <b>Auszahlung:</b> ${payout}â‚¬.<br>
       <b>TrophÃ¤en:</b> ${trophies > 0 ? 'ğŸ† Ã—'+trophies : 'âŒ Keine'}`
    );

    if (typeof increaseStat === 'function') increaseStat('roulette');
  } finally {
    rouletteState.spinning = false;
    play.classList.remove('disabled');
    enablePlayIfReady();
  }
}

/* --- Roulette-Handler global machen (fÃ¼r onclick="...") --- */
window.startRoulette     = startRoulette;
window.rouletteSelect    = rouletteSelect;
window.rouletteSetNumber = rouletteSetNumber;
window.openStakeModal    = openStakeModal;
window.closeStakeModal   = closeStakeModal;
window.submitStake       = submitStake;
window.rouletteSpin      = rouletteSpin;
window.openResultModal   = openResultModal;
window.closeResultModal  = closeResultModal;

/* --- (optional, aber hilfreich) Overlays wegrÃ¤umen --- */
function _killOverlays() {
  try {
    document.querySelectorAll('.modal-backdrop').forEach(el => el.style.display = 'none');
    document.querySelectorAll('.help-overlay').forEach(el => el.remove());
  } catch (e) {
    console.warn("Overlay-Cleanup failed:", e);
  }
}

/* ===== Auction (ohne Geheimwert) ===== */
function startAuction(){
  currentContext = "auction";
  if (auctionState.ended) {
    auctionState = { highestBid: 0, highestBidder: null, bids: [], ended: false,
                     prize: getRandomIntInclusive(0,200) };
  }
  const opts = playerNames.map(n => `<option value="${n}">${n}</option>`).join("");

  document.getElementById("app-section").innerHTML = `
    <div class="auction-area">
      <div class="auction-header">
        <div class="auction-title">ğŸ’° Auktion</div>
        <div class="icon-btn" onclick="showHome()">âœ–</div>
      </div>

      <!-- Geheimwert + HÃ¶chstgebot im gleichen Block -->
      <div id="topBidBox" style="text-align:center;margin-bottom:15px;">
        <div style="font-size:0.95em;color:#555;">
          Geheimwert: <span id="secretValue">? â‚¬</span>
        </div>
        <div style="font-size:2.2em;font-weight:700;">
          <span id="topBidValue">${auctionState.highestBid}</span> â‚¬
        </div>
        <div style="font-size:1.3em;color:#333;" id="topBidder">
          ${auctionState.highestBidder || "â€”"}
        </div>
      </div>

      <!-- Gebot abgeben -->
      <div class="bid-row">
        <input type="number" id="bidAmount" min="1" step="1" placeholder="Betrag">
        <select id="bidPlayer">
          <option value="" disabled selected>Spieler</option>
          ${opts}
        </select>
        <div class="button" onclick="placeBid()">Bieten</div>
      </div>
      <div id="bidError" class="error"></div>

      <!-- Verlauf -->
      <div id="bidList" style="margin-top:20px;"></div>

      <!-- Ende -->
      <div style="margin-top:20px;">
        <div class="button" onclick="endAuction()">Auktion beenden</div>
      </div>
      <div id="result" style="margin-top:10px;"></div>
    </div>
  `;

  renderBidList();
}

function showBidError(msg) {
  const el = document.getElementById('bidError');
  if (!el) return;
  el.textContent = msg || "";
  el.style.display = msg ? 'block' : 'none';
}

function placeBid() {
  if (auctionState.ended) return;
  const amount = Number(document.getElementById('bidAmount').value);
  const player = document.getElementById('bidPlayer').value;

  if (!player) { showBidError('Bitte Spieler auswÃ¤hlen.'); return; }
  if (!amount || amount <= 0) { showBidError('Bitte einen gÃ¼ltigen Betrag eingeben (> 0).'); return; }
  if (amount <= auctionState.highestBid) { showBidError(`Gebot muss grÃ¶ÃŸer als ${auctionState.highestBid} â‚¬ sein.`); return; }

  showBidError('');
  auctionState.highestBid = amount;
  auctionState.highestBidder = player;
  auctionState.bids.push({ name: player, amount });

  document.getElementById('bidAmount').value = '';
  updateTopBidDisplay();
  renderBidList();
}

function updateTopBidDisplay() {
  const v = document.getElementById('topBidValue');
  const b = document.getElementById('topBidder');
  if (v) v.textContent = auctionState.highestBid;
  if (b) b.textContent = auctionState.highestBidder || "â€”";
}

function renderBidList() {
  const list = document.getElementById('bidList');
  if (!list) return;
  if (auctionState.bids.length === 0) {
    list.innerHTML = `<div class="small">Noch keine Gebote.</div>`;
    return;
  }
  list.innerHTML = auctionState.bids
    .slice().reverse()
    .map(b => `
      <div class="bid-item" style="text-align:center; font-size:1.2em; margin:8px auto; max-width:200px;">
        <div style="font-weight:700;">${b.amount} â‚¬</div>
        <div style="font-size:0.95em; color:#333;">${b.name}</div>
      </div>
    `)
    .join('');
}

function endAuction() {
  if (auctionState.ended) return;
  auctionState.ended = true;

  const winner = auctionState.highestBidder;
  const bid    = auctionState.highestBid;
  const prize  = auctionState.prize;
  const resultEl = document.getElementById('result');

  document.getElementById('secretValue').textContent = prize + " â‚¬";

  if (!winner) {
    resultEl.innerHTML = `<div class="error">Es gibt kein gÃ¼ltiges Gebot. Die Auktion endet ohne Gewinner.</div>`;
    return;
  }

  const profit = prize - bid; 
  const profitText = profit >= 0
    ? `Gewinn: <strong>+${profit} â‚¬</strong> ğŸ‰`
    : `Verlust: <strong>${profit} â‚¬</strong> ğŸ˜¬`;

  // === TrophÃ¤en-Berechnung ===
  // Formel: je nÃ¤her am Preis, desto schlechter die Chance
  let ratio   = Math.min(bid, prize) / Math.max(bid, prize); // 0..1
  let chance  = Math.round((1 - ratio) * 100);               // in %
  let drop    = (Math.random() * 100 < chance) ? 1 : 0;

  if (drop > 0) awardTrophies(winner, drop);

  resultEl.innerHTML = `
    <div><strong>${winner}</strong> hat die Auktion gewonnen.</div>
    <div>Gebot: <b>${bid} â‚¬</b> Â· Geheimer Wert: <b>${prize} â‚¬</b></div>
    <div style="margin-top:8px;">${profitText}</div>
    <div style="margin-top:6px;">
      ${drop>0 ? "ğŸ† "+drop+" TrophÃ¤e erhalten" : "âŒ Keine TrophÃ¤e erhalten"}
    </div>
  `;

  increaseStat("auction");
}

/* ===== Poker (kompletter Block) ===== */

const POKER_BUYIN = 50; // nur Info â€“ NICHT abziehen (Buy-in extern)

let pokerState = {
  entries: [],             // gewÃ¤hlte Kategorien (Indices)
  total: 0,                // Gewinn (ohne Buy-in-Abzug)
  ended: false,            // Runde beendet?
  started: false,          // Spieler bereits gewÃ¤hlt?
  currentPlayerIdx: null,  // Index im playerNames-Array
  currentPlayerName: null  // stabiler Name fÃ¼r Logs/UI
};

const POKER_CATEGORIES = [
  { name: "Niete",           payout: 0,   max: 5 },
  { name: "Kleine StraÃŸe",   payout: 10,  max: 1 },
  { name: "Paar",            payout: 10,  max: 1 },
  { name: "Zwei Paare",      payout: 20,  max: 1 },
  { name: "Drilling",        payout: 30,  max: 1 },
  { name: "Full House",      payout: 40,  max: 1 },
  { name: "GroÃŸe StraÃŸe",    payout: 50,  max: 1 },
  { name: "Vierling",        payout: 60,  max: 1 },
  { name: "FÃ¼nfling",        payout: 100, max: 1 }
];

/* === Einstieg === */
function startPoker() {
  currentContext = "poker";
  pokerState = {
    entries: [],
    total: 0,
    ended: false,
    started: false,
    currentPlayerIdx: null,
    currentPlayerName: null
  };

  const app = document.getElementById("app-section");
  app.innerHTML = `
    <div class="lotto-header" style="display:grid;grid-template-columns:48px 1fr 48px;align-items:center;">
      <div class="icon-btn" onclick="showHome()" title="ZurÃ¼ck">âœ–</div>
      <div class="lotto-title">ğŸƒ Poker</div>
      <div class="icon-btn" onclick="showHelp && showHelp('poker')" title="Hilfe">â“</div>
    </div>
    <div class="section" style="text-align:center;margin-top:10px;">
      <div class="small">Bitte Spieler auswÃ¤hlenâ€¦</div>
    </div>
  `;
  openPokerPlayerModal();
}

/* === Rendering === */
function renderPokerUI() {
  const app = document.getElementById("app-section");
  if (!app) return;

  // Endscreen
  if (pokerState.ended) {
    const onlyNiete = pokerState.entries.every(e => POKER_CATEGORIES[e].name === "Niete");
    const total = pokerState.total || 0;
    const player = pokerState.currentPlayerName || playerNames[pokerState.currentPlayerIdx ?? 0] || "Spieler";

    const headline = onlyNiete ? "Alles Niete!" : "Ende der Runde";
    const winLine  = onlyNiete ? `Alles Niete, Gewinn <b>${total} â‚¬</b>` : `Gewinn: <b>${total} â‚¬</b>`;

    app.innerHTML = `
      <div class="lotto-header" style="display:grid;grid-template-columns:48px 1fr 48px;align-items:center;">
        <div class="icon-btn" onclick="startPoker()" title="Neue Runde">ğŸ”</div>
        <div class="lotto-title">ğŸƒ Poker</div>
        <div class="icon-btn" onclick="showHome()" title="ZurÃ¼ck">âœ–</div>
      </div>
      <div class="poker-result" style="text-align:center;">
        <div class="small" style="margin-top:6px;">Spieler: <b>${player}</b></div>
        <div style="font-size:1.6rem;margin:12px 0;">${headline}</div>
        <div style="font-size:1.4rem;margin:8px 0;">${winLine}</div>
        <div style="margin-top:8px;">${pokerState.trophyLine || "âŒ Du bekommst keine TrophÃ¤e."}</div>
      </div>
    `;
    return;
  }

  // Kein Spieler gewÃ¤hlt
  if (!pokerState.started) {
    app.innerHTML = `
      <div class="lotto-header" style="display:grid;grid-template-columns:48px 1fr 48px;align-items:center;">
        <div class="icon-btn" onclick="showHome()" title="ZurÃ¼ck">âœ–</div>
        <div class="lotto-title">ğŸƒ Poker</div>
        <div class="icon-btn" onclick="showHelp && showHelp('poker')" title="Hilfe">â“</div>
      </div>
      <div class="section" style="text-align:center;margin-top:10px;">
        <div class="small">Bitte Spieler auswÃ¤hlenâ€¦</div>
        <div class="button" style="width:220px;margin-top:12px;" onclick="openPokerPlayerModal()">Spieler wÃ¤hlen</div>
      </div>
    `;
    return;
  }

  // Laufende Runde
  const player = pokerState.currentPlayerName || playerNames[pokerState.currentPlayerIdx ?? 0] || "Spieler";
  const cats = POKER_CATEGORIES.map((cat, idx) => {
    const usedCount = pokerState.entries.filter(e => e === idx).length;
    const btns = [];
    for (let i = 0; i < cat.max; i++) {
      const checked = i < usedCount;
      const disabled = pokerState.entries.length >= 5 && !checked;
      btns.push(`
        <span class="poker-check ${checked ? "active" : ""}"
              onclick="selectPoker(${idx}, ${i})"
              style="${disabled ? 'pointer-events:none;opacity:.5;' : ''}">
          ${checked ? "âœ…" : "ğŸ”³"}
        </span>
      `);
    }
    return `
      <div class="poker-row">
        <span class="poker-name">${cat.name}</span>
        <span class="poker-payout">${cat.payout} â‚¬</span>
        <span class="poker-boxes">${btns.join("")}</span>
      </div>
    `;
  }).join("");

  app.innerHTML = `
    <div class="lotto-header" style="display:grid;grid-template-columns:48px 1fr 48px;align-items:center;">
      <div class="icon-btn" onclick="startPoker()" title="Neue Runde">ğŸ”</div>
      <div class="lotto-title">ğŸƒ Poker</div>
      <div class="icon-btn" onclick="showHome()" title="ZurÃ¼ck">âœ–</div>
    </div>
    <div class="poker-area">${cats}</div>
  `;
}

/* === Modal: Spielerauswahl === */
function openPokerPlayerModal() {
  closePokerPlayerModal();

  const overlay = document.createElement("div");
  overlay.id = "pokerPlayerModal";
  overlay.className = "modal-backdrop";
  overlay.style.display = "flex";
	overlay.innerHTML = `
	  <div class="modal">
		<h2>Spieler wÃ¤hlen</h2>
		<div class="field" style="margin-top:8px;">
		  <label for="pokerPlayerSel">Wer spielt diese Runde?</label>
		  <select id="pokerPlayerSel">
			<option value="" disabled ${pokerState.currentPlayerIdx===null ? "selected" : ""}>Bitte wÃ¤hlen</option>
			${playerNames.map((n,i)=>`<option value="${i}" ${pokerState.currentPlayerIdx===i ? "selected" : ""}>${n}</option>`).join("")}
		  </select>
		</div>
		<div id="pokerPlayerErr" class="error"></div>

		<!-- Buttons in einer Zeile, gleich groÃŸ, mittig -->
		<div class="modal-actions" style="justify-content:center; gap:12px;">
		  <button class="btn" style="flex:1; max-width:140px;" onclick="closePokerPlayerModalAndBack()">Abbrechen</button>
		  <button class="btn primary" style="flex:1; max-width:140px;" onclick="confirmPokerPlayerFromModal()">Runde starten</button>
		</div>
	  </div>
	`;
  document.body.appendChild(overlay);

  const sel = document.getElementById("pokerPlayerSel");
  if (sel) sel.focus();
}
function closePokerPlayerModal(){ const m=document.getElementById("pokerPlayerModal"); if(m) m.remove(); }
function closePokerPlayerModalAndBack(){ closePokerPlayerModal(); if(!pokerState.started) showHome(); }
function confirmPokerPlayerFromModal(){
  const sel = document.getElementById("pokerPlayerSel");
  const err = document.getElementById("pokerPlayerErr");
  const idx = sel ? parseInt(sel.value,10) : NaN;

  if (Number.isNaN(idx)){
    if (err) err.textContent = "Bitte zuerst einen Spieler wÃ¤hlen.";
    return;
  }

  pokerState.currentPlayerIdx  = idx;
  pokerState.currentPlayerName = playerNames[idx] || "Spieler";
  pokerState.started = true;

  closePokerPlayerModal();
  renderPokerUI();
}

/* === Auswahl / Abschluss === */
// KORREKTE Poker-Auswahl: Gewinn ohne Buy-in abziehen + TrophÃ¤e dem gewÃ¤hlten Spieler
function selectPoker(idx, slot) {
  if (pokerState.ended || !pokerState) return;

  const cat = POKER_CATEGORIES[idx];
  const usedCount = pokerState.entries.filter(e => e === idx).length;

  // Ein-/Aushaken pro Kategorie
  if (cat.max === 1) {
    if (usedCount) {
      const pos = pokerState.entries.indexOf(idx);
      if (pos !== -1) pokerState.entries.splice(pos, 1);
    } else {
      pokerState.entries.push(idx);
    }
  } else {
    // Mehrfachkategorie (Niete) sequentiell
    if (slot === usedCount) {
      if (usedCount < cat.max) pokerState.entries.push(idx);
    } else if (slot === usedCount - 1) {
      const pos = pokerState.entries.lastIndexOf(idx);
      if (pos !== -1) pokerState.entries.splice(pos, 1);
    }
  }

  // Ende nach 5 EintrÃ¤gen
  if (pokerState.entries.length === 5) {
    const onlyNiete = pokerState.entries.every(e => POKER_CATEGORIES[e].name === "Niete");
    const gross = onlyNiete
      ? 200
      : pokerState.entries.map(i => POKER_CATEGORIES[i].payout).reduce((a, b) => a + b, 0);

    // WICHTIG: Buy-in NICHT abziehen â€“ Gewinn wird vollstÃ¤ndig angezeigt
    pokerState.total = gross;
    pokerState.ended = true;

    // Statistik (best effort)
    try { if (typeof increaseStat === "function") increaseStat("poker"); } catch {}

    // Den GEWÃ„HLTEN Spieler zuverlÃ¤ssig ermitteln
    const player =
      pokerState.currentPlayerName ||
      (Number.isInteger(pokerState.currentPlayerIdx) ? playerNames[pokerState.currentPlayerIdx] : null) ||
      "Spieler";

    // TrophÃ¤en-Logik:
    // >= 50 â‚¬ => garantiert 1 TrophÃ¤e
    // < 50 â‚¬  => Chance = round(gross/50 * 100)
    let gotTrophy = false;
    if (gross >= 50) {
      try { awardTrophies(player, 1); gotTrophy = true; } catch {}
    } else if (gross > 0) {
      const chance = Math.round((gross / 50) * 100);
      if (Math.random() * 100 < chance) {
        try { awardTrophies(player, 1); gotTrophy = true; } catch {}
      }
    }

    // Optional: kurze Trophy-Zeile in den State, falls du sie im UI zeigen willst
    pokerState.trophyLine = gotTrophy ? "ğŸ† TrophÃ¤e erhalten" : "âŒ Keine TrophÃ¤e";
  }

  renderPokerUI();
}

/* === Hilfe-Text (optional im Help-Overlay) === */
function getPokerHelpText() {
  return `
    <div style='text-align:left;max-width:600px;margin:10px auto;'>
      Jeder Spieler wÃ¼rfelt <b>5Ã— mit allen 5 WÃ¼rfeln</b> und wÃ¤hlt pro Runde eine Kombination aus.
      <br><br>âœ”ï¸ Jede Kombi 1Ã—, <b>Niete</b> bis zu 5Ã— (sequentiell).
      <br><br><b>Bonus:</b> 5Ã— Niete ergibt automatisch <b>200 â‚¬ Gewinn</b>.
      <br><br><b>Buy-in:</b> ${POKER_BUYIN} â‚¬ (extern â€“ wird nicht abgezogen).
      <br><br><b>TrophÃ¤en:</b> >50 â‚¬ garantiert, sonst Gewinn/50 % Chance.
    </div>`;
}

/* === Globals/Exports === */
window.startPoker = startPoker;
window.openPokerPlayerModal = openPokerPlayerModal;
window.closePokerPlayerModalAndBack = closePokerPlayerModalAndBack;
window.confirmPokerPlayerFromModal = confirmPokerPlayerFromModal;
window.selectPoker = selectPoker;

/* ===== Lucky Streak ===== */
window.streakState = window.streakState || {
  win: 0,
  steps: 0,
  ended: false,
  started: false,
  currentPlayerIdx: null,
  currentPlayerName: null
};

function startStreak(reset = true) {
  currentContext = "streak";

  if (reset) {
    resetStreakState();
  } else {
    // Falls was fehlt, sicherstellen
    streakState = Object.assign({
      win: 0, steps: 0, ended: false, started: false,
      currentPlayerIdx: null, currentPlayerName: null
    }, streakState || {});
  }

  // Wenn noch kein Spieler gewÃ¤hlt: gleich das Popup Ã¶ffnen
  if (!streakState.started) {
    renderStreakUI();       // Basis UI (Header, Hintergrund)
    openStreakPlayerModal();// Popup direkt Ã¶ffnen
  } else {
    renderStreakUI();       // normale UI
  }
}

function resetStreakState() {
  streakState = {
    win: 0,
    steps: 0,
    ended: false,
    started: false,
    currentPlayerIdx: null,
    currentPlayerName: null
  };
}

function renderStreakUI() {
  const app = document.getElementById("app-section");
  if (!app) return;

  // Spieler noch nicht gewÃ¤hlt
  if (!streakState.started) {
    app.innerHTML = `
      <div class="lotto-header">
        <div class="icon-btn" onclick="showHome()" title="ZurÃ¼ck">âœ–</div>
        <div class="lotto-title">ğŸ² Lucky Streak</div>
        <div class="icon-btn" onclick="showHelp && showHelp('streak')" title="Hilfe">â“</div>
      </div>
      <div class="section" style="text-align:center;margin-top:10px;">
        <div class="small">Bitte Spieler auswÃ¤hlenâ€¦</div>
      </div>
    `;
    return;
  }

  // Runde lÃ¤uft / beendet
  const win   = streakState.win ?? 0;
  const steps = streakState.steps ?? 0;
  const next  = streakState.ended ? null : (win + (steps + 1));
  const player = streakState.currentPlayerName || playerNames[streakState.currentPlayerIdx ?? 0] || "Spieler";

  app.innerHTML = `
    <div class="lotto-header">
      <div class="icon-btn" onclick="startStreak()" title="Neue Runde">ğŸ”</div>
      <div class="lotto-title">ğŸ² Lucky Streak</div>
      <div class="icon-btn" onclick="showHome()" title="ZurÃ¼ck">âœ–</div>
    </div>

      <div style="font-size:2.2em;font-weight:700;margin:6px 0 14px;">
        Aktueller Gewinn:
        <span id="streakWin">${win} â‚¬</span>
        ${streakState.ended ? "" : `<span id="streakNext" class="small" style="font-weight:600;"> â¡ï¸ ${next} â‚¬</span>`}
      </div>

      <div style="display:flex;gap:12px;justify-content:space-between;align-items:center;max-width:360px;margin:0 auto 10px;">
        <div id="btnStreak1" class="button" style="width:100px;" onclick="handleStreakRoll(1)">1</div>
        <div id="btnStreak2to5" class="button" style="width:100px;" onclick="handleStreakRoll('2-5')">2â€“5</div>
        <div id="btnStreak6" class="button" style="width:100px;" onclick="handleStreakRoll(6)">6</div>
      </div>

      <div class="button" style="width:240px;" onclick="endStreak()">Stopp</div>

      <div id="streakResult" style="margin-top:14px;font-size:1.1em;"></div>
    </div>
  `;

  if (streakState.ended) setStreakButtonsDisabled(true);
}

/* === Modal: Spielerwahl (wie Poker) === */
function openStreakPlayerModal() {
  closeStreakPlayerModal();

  const overlay = document.createElement("div");
  overlay.id = "streakPlayerModal";
  overlay.className = "modal-backdrop";
  overlay.style.display = "flex";
  overlay.innerHTML = `
    <div class="modal">
      <h2>Spieler wÃ¤hlen</h2>
      <div class="field">
        <label for="streakPlayerSel">Wer spielt diese Runde?</label>
        <select id="streakPlayerSel">
          <option value="" disabled ${streakState.currentPlayerIdx===null ? "selected" : ""}>Bitte wÃ¤hlen</option>
          ${playerNames.map((n,i)=>`<option value="${i}" ${streakState.currentPlayerIdx===i ? "selected" : ""}>${n}</option>`).join("")}
        </select>
      </div>
      <div id="streakPlayerErr" class="error"></div>

      <!-- exakt wie Poker -->
      <div class="modal-actions centered">
        <button class="btn equal" onclick="closeStreakPlayerModalAndBack()">Abbrechen</button>
        <button class="btn primary equal" onclick="confirmStreakPlayerFromModal()">Runde starten</button>
      </div>
    </div>
  `;
  document.body.appendChild(overlay);

  const sel = document.getElementById("streakPlayerSel");
  if (sel) sel.focus();
}

function closeStreakPlayerModal(){ const m=document.getElementById("streakPlayerModal"); if(m) m.remove(); }
function closeStreakPlayerModalAndBack(){ closeStreakPlayerModal(); if(!streakState.started) showHome(); }
function confirmStreakPlayerFromModal(){
  const sel = document.getElementById("streakPlayerSel");
  const err = document.getElementById("streakPlayerErr");
  const idx = sel ? parseInt(sel.value,10) : NaN;

  if (Number.isNaN(idx)){
    if (err) err.textContent = "Bitte zuerst einen Spieler wÃ¤hlen.";
    return;
  }

  streakState.currentPlayerIdx  = idx;
  streakState.currentPlayerName = playerNames[idx] || "Spieler";
  streakState.started = true;

  closeStreakPlayerModal();
  renderStreakUI();
}

/* === Spiel-Logik === */
function handleStreakRoll(type) {
  if (streakState.ended) return;
  const out = document.getElementById("streakResult");
  if (out) out.innerHTML = "";

  const player =
    streakState.currentPlayerName ||
    playerNames[streakState.currentPlayerIdx ?? 0] ||
    "Spieler";

  if (type === 1) {
    // âŒ 1 = Alles verloren
    streakState.win = 0;
    streakState.ended = true;
    if (typeof increaseStat === "function") increaseStat("streak");

    const winEl = document.getElementById("streakWin");
    if (winEl) winEl.textContent = `${streakState.win} â‚¬`;

    if (out) {
      out.innerHTML =
        `âŒ 1 gewÃ¼rfelt â€“ alles verloren!<br>` +
        `Spieler: <b>${player}</b>`;
    }
  }
  else if (type === "2-5") {
    // âœ… 2â€“5 = +1 â‚¬, progressiv
    streakState.steps = (streakState.steps || 0) + 1;
    streakState.win   = (streakState.win   || 0) + streakState.steps;

    const winEl  = document.getElementById("streakWin");
    const nextEl = document.getElementById("streakNext");
    if (winEl)  winEl.textContent  = `${streakState.win} â‚¬`;
    if (nextEl) nextEl.textContent = ` â¡ï¸ ${streakState.win + (streakState.steps + 1)} â‚¬`;
    return; // Runde lÃ¤uft weiter
  }
  else if (type === 6) {
    // ğŸ˜¬ 6 = Gewinn halbiert + Runde endet
    streakState.win   = Math.floor((streakState.win || 0) / 2);
    streakState.ended = true;
    if (typeof increaseStat === "function") increaseStat("streak");

    const winEl = document.getElementById("streakWin");
    if (winEl) winEl.textContent = `${streakState.win} â‚¬`;

    // ğŸ† TrophÃ¤e prÃ¼fen nach neuer Regel
    const trophyMsg = streakTrophyOutcome(streakState.win, player);

    if (out) {
      out.innerHTML =
        `ğŸ˜¬ 6 gewÃ¼rfelt â€“ Gewinn halbiert.<br>` +
        `ğŸ Auszahlung: <b>${streakState.win} â‚¬</b><br>` +
        `${trophyMsg}<br>` ;
    }
  }

  if (streakState.ended) {
    const nextEl = document.getElementById("streakNext");
    if (nextEl) nextEl.remove();
    setStreakButtonsDisabled(true);
  }
}

function endStreak() {
  if (streakState.ended) return;
  streakState.ended = true;
  if (typeof increaseStat === "function") increaseStat("streak");

  const player = streakState.currentPlayerName
    || playerNames[streakState.currentPlayerIdx ?? 0]
    || "Spieler";

  // âœ… TrophÃ¤e anhand des finalen Gewinns prÃ¼fen
  const trophyMsg = streakTrophyOutcome(streakState.win, player);

  const out = document.getElementById("streakResult");
  if (out) {
    out.innerHTML =
      `Auszahlung: <b>${streakState.win} â‚¬</b><br>` +
      `${trophyMsg}<br>`;
  }
  const nextEl = document.getElementById("streakNext");
  if (nextEl) nextEl.remove();
  setStreakButtonsDisabled(true);
}

function setStreakButtonsDisabled(disabled) {
  ["btnStreak1", "btnStreak2to5", "btnStreak6"].forEach(id => {
    const el = document.getElementById(id);
    if (!el) return;
    el.style.opacity = disabled ? "0.6" : "1";
    el.style.pointerEvents = disabled ? "none" : "auto";
  });
}

/* Exporte, damit showHome-Bindings sicher funktionieren */
window.startStreak = startStreak;
window.openStreakPlayerModal = openStreakPlayerModal;
window.confirmStreakPlayerFromModal = confirmStreakPlayerFromModal;

/* ===== Jackpot ===== */
function startJackpot() {
  currentContext = "jackpot";

  const playerOpts = (playerNames || []).map((n, i) => `<option value="${i}">${n}</option>`).join("");

  document.getElementById("app-section").innerHTML = `
    <div class="auction-header">
      <div class="auction-title">ğŸ° Jackpot</div>
      <div class="icon-btn" onclick="showHome()">âœ–</div>
    </div>

    <div class="section" style="text-align:center;">
      <div class="row" style="justify-content:center; gap:14px; flex-wrap:wrap;">
        <div>
          <div class="small">Spieler</div>
          <select id="jackpotPlayer">
            <option value="" disabled selected>Bitte wÃ¤hlen</option>
            ${playerOpts}
          </select>
        </div>

        <div>
          <div class="small">Einsatz (â‚¬)</div>
          <input type="number" id="jackpotBet" min="1" step="1" placeholder="Einsatz â‚¬">
        </div>

        <div>
          <div class="small">WÃ¼rfel (1â€“6)</div>
          <input type="number" id="jackpotRoll" min="1" max="6" step="1"
                 placeholder="WÃ¼rfel (1-6)" oninput="limitRoll(this)">
        </div>
      </div>

      <div id="jackpotErr" class="error" style="margin-top:6px;"></div>

      <div class="button" onclick="evaluateJackpot()">Auswerten</div>
      <div id="jackpotResult" style="margin-top:16px;font-size:1.2em;"></div>
    </div>
  `;
}

/** Abrunden zugunsten der Bank (immer nach unten) */
function bankFloor(x) {
  return Math.floor(Number(x) || 0);
}

function evaluateJackpot() {
  const errEl = document.getElementById("jackpotErr");
  const outEl = document.getElementById("jackpotResult");
  if (errEl) errEl.textContent = "";
  if (outEl) outEl.textContent = "";

  const pIdx = parseInt((document.getElementById("jackpotPlayer") || {}).value, 10);
  const bet  = parseInt((document.getElementById("jackpotBet") || {}).value, 10);
  const roll = parseInt((document.getElementById("jackpotRoll") || {}).value, 10);

  if (Number.isNaN(pIdx)) { if (errEl) errEl.textContent = "Bitte einen Spieler wÃ¤hlen."; return; }
  if (!bet || bet < 1)     { if (errEl) errEl.textContent = "Bitte gÃ¼ltigen Einsatz (â‰¥ 1 â‚¬) eingeben."; return; }
  if (!roll || roll < 1 || roll > 6) { if (errEl) errEl.textContent = "WÃ¼rfelzahl muss 1â€“6 sein."; return; }

  const player = playerNames[pIdx] || "Spieler";

  // Payout nach deinen Regeln
  let payout = 0;
  let line   = "";

  switch (roll) {
    case 1:
      payout = 0;
      line = "Alles verloren.";
      break;
    case 2:
      payout = bankFloor(bet / 2);
      line = `HÃ¤lfte zurÃ¼ck â€“ ${payout} â‚¬ von ${bet} â‚¬.`; 
      break;
    case 3:
      payout = bet;
      line = `Einsatz zurÃ¼ck â€“ ${payout} â‚¬.`;
      break;
    case 4:
      payout = bankFloor(bet * 1.5);
      line = `Ã—1,5 â€“ Auszahlung ${payout} â‚¬.`;
      break;
    case 5:
      payout = bet * 2;
      line = `Doppelgewinn â€“ Auszahlung ${payout} â‚¬.`;
      break;
    case 6:
      if (outEl) {
        outEl.innerHTML = `Du hast eine <b>6</b> eingetragen. ğŸ² Bitte <b>nochmal wÃ¼rfeln</b> und die neue Zahl eintragen.`;
      }
      return;
  }

  const net = Math.max(0, payout - bet);

  // Statistik (best effort)
  try { if (typeof increaseStat === "function") increaseStat("jackpot"); } catch {}

  // TrophÃ¤en â€“ nur bei positivem Netto-Gewinn
  let trophyText = "âŒ Du hast keine TrophÃ¤e erhalten.";
  if (net > 0) {
    let res = null;
    if (typeof awardTrophiesByBetPayout === "function") {
      try {
        res = awardTrophiesByBetPayout("jackpot", player, bet, payout);
      } catch {}
    } else if (typeof awardTrophies === "function") {
      // Fallback: tatsÃ¤chliche Vergabe (einfach 1) â€“ dein awardTrophies schreibt ins Ereignis-Log
      try { awardTrophies(player, 1); res = { drop: 1, chance: 100, net }; } catch {}
    }

    // Anzeige je nach RÃ¼ckgabe
    if (res && typeof res.drop === "number") {
      trophyText = res.drop > 0 ? "ğŸ† Du hast eine TrophÃ¤e erhalten." : "âŒ Du hast keine TrophÃ¤e erhalten.";
    } else {
      // Falls keine Info zurÃ¼ckkam: bei positivem Netto konservativ davon ausgehen, dass evtl. vergeben wurde
      // (nur Anzeige â€“ die echte Vergabe passiert in den Funktionen oben)
      trophyText = "ğŸ† Du hast eine TrophÃ¤e erhalten.";
    }
  }

  if (outEl) {
    outEl.innerHTML = `
      Spieler: <b>${player}</b><br>
      GewÃ¼rfelt: <b>${roll}</b><br>
      ${line}<br>
      <div style="margin-top:8px;">${trophyText}</div>
    `;
  }
}

/* ===== Statistik-Navigation (zurÃ¼ck zur Quelle) ===== */
window._statsPrevContext = window._statsPrevContext || null;

function openStatistics() {
  // merken, woher wir Statistik Ã¶ffnen (Settings, Home, â€¦)
  window._statsPrevContext = typeof currentContext === "string" ? currentContext : "home";
  showStatistics();
}

function closeStatistics() {
  // wenn Statistik aus Settings kam -> zurÃ¼ck zu Settings
  const prev = window._statsPrevContext || "home";
  window._statsPrevContext = null;

  if (prev === "settings" && typeof showSettings === "function") {
    currentContext = "settings";
    showSettings();
  } else {
    // sonst normal nach Home
    currentContext = "home";
    showHome();
  }
}

function limitRoll(input) {
  let val = parseInt(input.value, 10);
  if (isNaN(val)) return;
  if (val > 6) input.value = 6;
  if (val < 1) input.value = 1;
}

function streakIncrease() {
  if (streakState.ended) return;
  streakState.steps += 1;     // â€kein 1er gewÃ¼rfeltâ€œ
  renderStreakUI();
}

function streakLoseAll() {
  if (streakState.ended) return;
  streakState.ended = true;   // â€1 gewÃ¼rfeltâ€œ
  streakState.payout = 0;
  renderStreakUI();
}

function streakCashOut(amount) {
  if (streakState.ended) return;
  streakState.ended = true;
  streakState.payout = Number(amount) || 0;
  renderStreakUI();
}

// === App-Start (REPLACE WHOLE onload) ===
window.onload = () => {
  if (settings.devMode && settings.directHome) {
    totalPlayers = 4;
    playerNames = ["Alice", "Bob", "Carol", "Dave"];
    initDeck();
    ensureEventSystemReady();
    showHome();
  } else {
    document.getElementById("app-section").innerHTML = `
      <h2>Spieleranzahl wÃ¤hlen</h2>
      <select id="playerCount">
        <option value="" disabled ${settings.devMode ? "" : "selected"}>Bitte wÃ¤hlen</option>
        <option value="2">2 Spieler</option>
        <option value="3">3 Spieler</option>
        <option value="4" ${settings.devMode ? "selected" : ""}>4 Spieler</option>
        <option value="5">5 Spieler</option>
        <option value="6">6 Spieler</option>
        <option value="7">7 Spieler</option>
        <option value="8">8 Spieler</option>
      </select>
      <br><br>
      <div class="button" onclick="confirmPlayerCount()">Weiter</div>
    `;
  } //  â† DIESE Klammer hat dir gefehlt
};

// Unicode-Faces: âš€ âš âš‚ âšƒ âš„ âš…
const DICE_CHARS = ['âš€','âš','âš‚','âšƒ','âš„','âš…'];

/**
 * Animiert einen WÃ¼rfel Ã¼ber den Bildschirm und liefert die zufÃ¤llige Endzahl (1â€“6).
 * Nutzung: const n = await rollDiceAnimation();  // n = 1..6
 */
function rollDiceAnimation(options = {}) {
  return new Promise(resolve => {
    const final = getRandomIntInclusive(1, 6);
    const duration = options.duration || getRandomIntInclusive(900, 1400); // ms
    const startSide = Math.random() < 0.5 ? 'left' : 'right';
    const startX = (startSide === 'left') ? -100 : (window.innerWidth + 100);
    const endX = window.innerWidth / 2 - 40; // WÃ¼rfelmitte ungefÃ¤hr in Screenmitte
    const y = getRandomIntInclusive(Math.floor(window.innerHeight * 0.25),
                                    Math.floor(window.innerHeight * 0.65));

    // WÃ¼rfel erzeugen
    const dice = document.createElement('div');
    dice.className = 'dice-el';
    dice.textContent = DICE_CHARS[0];
    document.body.appendChild(dice);

    // Faces schnell durchblÃ¤ttern
    const faceTimer = setInterval(() => {
      dice.textContent = DICE_CHARS[getRandomIntInclusive(0, 5)];
    }, 70);

    let startTime = null;
    const totalRot = (startSide === 'left' ? 1 : -1) * 720; // 2 Umdrehungen

    function frame(ts) {
      if (!startTime) startTime = ts;
      const t = (ts - startTime) / duration;
      const p = Math.min(1, t);
      // EaseOutCubic
      const ease = 1 - Math.pow(1 - p, 3);
      // Position + Rotation
      const x = startX + (endX - startX) * ease;
      const rot = totalRot * ease;
      dice.style.transform = `translate(${x}px, ${y}px) rotate(${rot}deg)`;

      if (p < 1) {
        requestAnimationFrame(frame);
      } else {
        // Stopp: endgÃ¼ltiges Face zeigen + kleines â€Settleâ€œ
        clearInterval(faceTimer);
        dice.textContent = DICE_CHARS[final - 1];
        dice.style.transition = 'transform 280ms ease-out';
        dice.style.transform = `translate(${endX + (startSide==='left'?10:-10)}px, ${y}px) rotate(${totalRot + (startSide==='left'?10:-10)}deg)`;
        setTimeout(() => {
          dice.style.transform = `translate(${endX}px, ${y}px) rotate(${totalRot}deg)`;
          setTimeout(() => { dice.remove(); resolve(final); }, 260);
        }, 60);
      }
    }
    requestAnimationFrame(frame);
  });
}

let _battleRolling = false;

function setBattleControlsDisabled(disabled) {
  const btn = document.getElementById('battleRollBtn');
  if (btn) {
    btn.style.opacity = disabled ? '0.6' : '1';
    btn.style.pointerEvents = disabled ? 'none' : 'auto';
  }
}

function showBattleError(msg) {
  const el = document.getElementById('battleError');
  if (!el) return;
  el.textContent = msg || "";
  el.style.display = msg ? 'block' : 'none';
}

async function doBattleAnimated() {
  if (_battleRolling) return;

  const challenger = document.getElementById('challenger').value;
  const opponent   = document.getElementById('opponent').value;
  const wager      = Number(document.getElementById('wager').value);

  if (!challenger || !opponent) { showBattleError('Bitte beide Spieler wÃ¤hlen.'); return; }
  if (challenger === opponent)  { showBattleError('Herausforderer und Gegner mÃ¼ssen unterschiedlich sein.'); return; }
  if (!wager || wager <= 0)     { showBattleError('Bitte einen gÃ¼ltigen Einsatz (> 0) eingeben.'); return; }
  showBattleError('');

  const out = document.getElementById('battleOutcome');
  _battleRolling = true;
  setBattleControlsDisabled(true);
  try {
    // Erstes Roll (Challenger)
    out.innerHTML = `ğŸ² ${challenger} wÃ¼rfelt...`;
    const a = await rollDiceAnimation();
    out.innerHTML = `ğŸ² ${challenger} wÃ¼rfelt <b>${a}</b>`;

    // kurze Pause
    await new Promise(r => setTimeout(r, 300));

    // Zweites Roll (Opponent)
    out.innerHTML += `<br>ğŸ² ${opponent} wÃ¼rfelt...`;
    const b = await rollDiceAnimation();
    out.innerHTML = `ğŸ² ${challenger} wÃ¼rfelt <b>${a}</b> | ${opponent} <b>${b}</b>`;

    // Auswertung
    let winner = null;
    if (battleState.mode === 'highest') {
      if (a > b) winner = challenger;
      else if (b > a) winner = opponent;
    } else { // 'lowest'
      if (a < b) winner = challenger;
      else if (b < a) winner = opponent;
    }

    if (!winner) {
      out.innerHTML += `<br><span class="small">Unentschieden â€“ bitte nochmal.</span>`;
    } else {
      const loser = (winner === challenger) ? opponent : challenger;
      out.innerHTML += `<br><b>${winner}</b> gewinnt <b>${wager} â‚¬</b> von ${loser}.`;
    }
  } finally {
    _battleRolling = false;
    setBattleControlsDisabled(false);
  }
}

//<!-- ===== 50-50 ===== -->
let allnothingStats = { win: 0, lose: 0 };
let allnothingState = { playerIdx: null, trophyLine: "" };

function startAllNothing() {
  currentContext = "allnothing";
  const opts = playerNames.map((n, i) => `<option value="${i}">${n}</option>`).join("");

  document.getElementById("app-section").innerHTML = `
    <div class="auction-header">
      <div class="auction-title">ğŸ² All or Nothing</div>
      <div class="icon-btn" onclick="showHome()">âœ–</div>
    </div>

    <div class="allnothing-wrap">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:14px;">
        <div style="text-align:left;">
          <div>âœ… Gewonnen: <span id="statWins">${allnothingStats.win}</span></div>
          <div>âŒ Verloren: <span id="statLoses">${allnothingStats.lose}</span></div>
        </div>
        <div><b>Einsatz: 20 â‚¬</b></div>
      </div>

      <div class="section" style="text-align:center;margin-bottom:8px;">
        <div class="small" style="margin-bottom:6px;">Spieler wÃ¤hlen</div>
        <select id="aonPlayer" onchange="setAonPlayer(this.value)">
          <option value="" disabled selected>Bitte wÃ¤hlen</option>
          ${opts}
        </select>
        <div id="aonErr" class="error" style="margin-top:6px;"></div>
      </div>

      <div class="button" onclick="playAllOrNothing()">âš–ï¸ All or Nothing</div>
      <div id="allnothingResult" class="result"></div>
      <div id="allnothingTrophy" class="small" style="margin-top:8px;"></div>
    </div>
  `;
}
function setAonPlayer(v) {
  const idx = parseInt(v, 10);
  allnothingState.playerIdx = Number.isNaN(idx) ? null : idx;
  const err = document.getElementById("aonErr");
  if (err) err.textContent = "";
}

function playAllOrNothing() {
  const resultEl  = document.getElementById("allnothingResult");
  const trophyEl  = document.getElementById("allnothingTrophy");
  const errEl     = document.getElementById("aonErr");

  // Spieler muss gewÃ¤hlt sein
  if (allnothingState.playerIdx === null) {
    if (errEl) errEl.textContent = "Bitte zuerst einen Spieler wÃ¤hlen.";
    return;
  }
  if (errEl) errEl.textContent = "";

  const player = playerNames[allnothingState.playerIdx] || "Spieler";
  const win = Math.random() < 0.5;

  if (win) {
    allnothingStats.win++;
    resultEl.innerHTML = "âœ… Gewonnen! Auszahlung: <b>40 â‚¬</b>";
    resultEl.className = "result win animate-pop";

    // wie bei Poker: klare Trophy-Zeile anzeigen
    const info = calcTrophyDrop("allnothing", player, 20, 40);
    allnothingState.trophyLine = info;               // z. B. â€ğŸ† Spieler erhÃ¤lt 1 TrophÃ¤eâ€œ
    if (trophyEl) trophyEl.textContent = info;
  } else {
    allnothingStats.lose++;
    resultEl.innerHTML = "âŒ Verloren! Keine Auszahlung.";
    resultEl.className = "result lose animate-pop";

    // bei Verlust keine Trophy (explizit anzeigen â€“ â€wie bei Pokerâ€œ)
    allnothingState.trophyLine = "âŒ Keine TrophÃ¤e erhalten";
    if (trophyEl) trophyEl.textContent = allnothingState.trophyLine;
  }

  increaseStat("allnothing");
  document.getElementById("statWins").textContent  = allnothingStats.win;
  document.getElementById("statLoses").textContent = allnothingStats.lose;
  setTimeout(() => resultEl.classList.remove("animate-pop"), 500);
}

// Statistik-Objekt global
let stats = {
  lotto:        { total: 0, session: 0 },
  auction:      { total: 0, session: 0 },
  jackpot:      { total: 0, session: 0 },
  streak:       { total: 0, session: 0 },
  roulette:     { total: 0, session: 0 },
  poker:        { total: 0, session: 0 },
  allnothing:   { total: 0, session: 0 }
};

// === nur Gesamt in localStorage speichern ===
function saveStats() {
  const totalOnly = {};
  for (let key in stats) {
    totalOnly[key] = { total: stats[key].total };  // Session wird NICHT gespeichert
  }
  localStorage.setItem("stats", JSON.stringify(totalOnly));
}

function loadStats() {
  const s = localStorage.getItem("stats");
  if (s) {
    const totalOnly = JSON.parse(s);
    for (let key in stats) {
      if (totalOnly[key]) stats[key].total = totalOnly[key].total;
      stats[key].session = 0; // immer neu anfangen
    }
  }
}
loadStats();

// Statistik erhÃ¶hen
function increaseStat(game) {
  if (!stats[game]) return;
  stats[game].total++;
  stats[game].session++;
  saveStats();
}

// === TrophÃ¤en Drop ===
let trophyStats = { total: 0, session: 0 };

function saveTrophies() {
  localStorage.setItem("trophyStats", JSON.stringify({ total: trophyStats.total }));
}
function loadTrophies() {
  const t = localStorage.getItem("trophyStats");
  if (t) {
    const d = JSON.parse(t);
    trophyStats.total = d.total || 0;
  }
  trophyStats.session = 0;
}
loadTrophies();

function awardTrophies(player, amount) {
  if (amount <= 0) return;
  trophyStats.total += amount;
  trophyStats.session += amount;
  saveTrophies?.();

  // korrekt loggen + speichern
  if (typeof logTrophies === "function") {
    logTrophies(player || "Spieler", amount);
  } else {
    addEventLog({ player: player || "Spieler", kind:"trophy", text: `${amount} TrophÃ¤e${amount>1?"n":""}` });
  }
}

/**
 * Berechnet die Dropchance und vergibt TrophÃ¤en
 * @param {string} game - Spielname ("lotto","auction","jackpot","streak","poker","allnothing","roulette")
 * @param {string} player - Spielername
 * @param {number} bet - Einsatz (â‚¬)
 * @param {number} win - Gewinn (â‚¬)
 * @param {object} extra - Zusatzinfos (z.B. {rolledSix:true, betType:"green"})
 */
 
function calcTrophyDrop(game, player, bet=0, win=0, extra={}) {
  let trophies = 0;
  let chance = 0;

  switch(game) {
    case "lotto":
      chance = 50;
      break;

    case "auction":
      if (win > 0) chance = ((win - bet) / win) * 100;
      break;

    case "jackpot":
      chance = Math.min(100, win);
      if (win > 50) trophies++;
      break;

    case "streak":
      let finalWin = extra.rolledSix ? Math.floor(win/2) : win;
      chance = Math.min(100, finalWin);
      if (finalWin > 50) trophies++;
      break;

    case "poker":
      chance = Math.min(100, win);
      if (win > 50) trophies++;
      break;

    case "allnothing":
      chance = 50; 
      break;

    case "roulette":
      if (extra.betType === "green") { trophies += 5; break; }
      if (extra.betType === "number") { trophies += 3; break; }
      chance = 50 + Math.min(50, bet);
      break;
  }

  if (Math.random() * 100 < chance) trophies++;

  if (trophies > 0) {
    awardTrophies(player, trophies);
    return `ğŸ† ${player} erhÃ¤lt ${trophies} TrophÃ¤e${trophies>1?"n":""}`;
  } else {
    return `âŒ ${player} hat keine TrophÃ¤en erhalten`;
  }
}

/* SchÃ¶ne Labels wie am Home-Bildschirm */
const GAME_LABEL = {
  lotto:      "ğŸ¯ Lotto",
  auction:    "ğŸ’° Auktion",
  jackpot:    "ğŸ° Jackpot",
  streak:     "ğŸ² Lucky Streak",
  roulette:   "ğŸ¡ Roulette",
  poker:      "ğŸƒ Poker",
  allnothing: "âš–ï¸ All or Nothing"   // <â€” korrekter Name
};
function gameLabel(key){ return GAME_LABEL[key] || key; }

function showStatistics() {
  currentContext = "stats";

  let rows = Object.keys(stats).map(game => {
    return `
      <tr>
        <td>${gameLabel(game)}</td>
        <td>${stats[game].session}</td>
        <td>${stats[game].total}</td>
      </tr>
    `;
  }).join("");

  document.getElementById("app-section").innerHTML = `
    <div class="auction-header">
      <div class="auction-title">ğŸ“Š Statistik</div>
      <div class="icon-btn" onclick="showSettings()">âœ–</div>
    </div>

    <div class="panel stats-section">
      <table class="stats-table">
        <tr>
          <th>Spiel</th>
          <th>Diese Session</th>
          <th>Gesamt</th>
        </tr>
        ${rows}
      </table>
    </div>
  `;
}

/* =========================
   Ereignis-Log: Anzeige
   ========================= */
function showEventLog(){
  currentContext = "eventlog";
  const esc = s => String(s ?? "")
    .replace(/&/g,"&amp;").replace(/</g,"&lt;")
    .replace(/>/g,"&gt;").replace(/"/g,"&quot;")
    .replace(/'/g,"&#039;");

  const labelOf = k =>
      k==="card"   ? "ğŸ´ Ereigniskarte" :
      k==="shop"   ? "ğŸ—¿ Artefaktum"    :
      k==="trophy" ? "ğŸ† TrophÃ¤e"       : "";

  const rows = (Array.isArray(window.eventLog) && window.eventLog.length)
    ? window.eventLog.map(e=>{
        // Fallback fÃ¼r alte EintrÃ¤ge ohne kind
        let kind = e.kind;
        if(!kind && typeof e.text==="string"){
          const t = e.text;
          if (/Ereigniskarte/i.test(t)) kind = "card";
          else if (/Troph(Ã¤|ae)/i.test(t)) kind = "trophy";
          else if (/(Artefaktum|gekauft|versteinert)/i.test(t)) kind = "shop";
        }
        const label = labelOf(kind);
        const content = String(e.text||"").replace(/^Ereigniskarte:\s*/i,"").trim();

        return `
          <div class="event-card">
            <div class="event-left">
              <div class="event-player">ğŸ‘¤ ${esc(e.player||"")}</div>
              <div class="event-time">ğŸ•’ ${esc(e.time||"")}</div>
            </div>
            <div class="event-right">
              ${label ? `<div class="event-kind">${label}</div>` : ""}
              <div class="event-text">${esc(content)}</div>
            </div>
          </div>
        `;
      }).join("")
    : `<div class="small" style="text-align:center;margin:20px 0;">Noch keine Ereignisse.</div>`;

  const app = document.getElementById("app-section");
  if (!app) return;
  app.innerHTML = `
    <div class="auction-header">
      <div class="auction-title">ğŸ“œ Ereignisverlauf</div>
      <div class="icon-btn" onclick="showSettings()">âœ–</div>
    </div>
    <div class="event-log">${rows}</div>
  `;
}
window.showEventLog = showEventLog;

/* =========================
   Ereignis-Log: Daten & Helper (kollisionssicher)
   ========================= */
// NIE mehr removeItem("eventLog") aufrufen!
(function initEventLog(){
  // vorhandenes Array weiterverwenden, sonst neu
  if (!Array.isArray(window.eventLog)) window.eventLog = [];

  function saveEventLog(){
    try {
      localStorage.setItem("eventLog", JSON.stringify(window.eventLog.slice(0,300)));
    } catch(e) { console.warn("saveEventLog failed:", e); }
  }
  function loadEventLog(){
    try {
      const raw = localStorage.getItem("eventLog");
      if (raw) {
        const arr = JSON.parse(raw);
        if (Array.isArray(arr)) window.eventLog = arr;
      }
    } catch(e) { console.warn("loadEventLog failed:", e); }
  }
  function addEventLog({player, kind, text, time}){
    window.eventLog.unshift({
      player: player || "Spieler",
      kind: kind || "",                   // "card" | "shop" | "trophy"
      text: String(text || ""),
      time: time || new Date().toLocaleTimeString()
    });
    saveEventLog();
  }

  // public machen
  window.saveEventLog = saveEventLog;
  window.addEventLog  = addEventLog;

  // Komfort-Wrapper
  window.logEreigniskarte = (player, cardText)=> addEventLog({ player, kind:"card",   text: cardText });
  window.logArtefaktum    = (player, itemName)=> addEventLog({ player, kind:"shop",   text: itemName });
  window.logTrophies      = (player, n)       => addEventLog({ player, kind:"trophy", text: `${n} TrophÃ¤e${n>1?"n":""}` });

  // Laden beim Start
  loadEventLog();
  // Sicherheitsspeicher vorm Tab-SchlieÃŸen
  window.addEventListener("beforeunload", saveEventLog);
})();

// Einheitliches Logging fÃ¼r Ereigniskarten
window.logEreigniskarte = function(player, cardTitle, cardBody="") {
  // hÃ¼bscher Text ohne doppelten Prefix
  const text = cardBody
    ? `${cardTitle}: ${cardBody}`   // z.B. "Ereigniskarte XY: Zahle 10 â‚¬"
    : `${cardTitle}`;

  // schreibe als "card", damit showEventLog sicher labelt
  if (typeof addEventLog === "function") {
    addEventLog({
      player: player || "Spieler",
      kind: "card",
      text: text
    });
  }
};

/* ========= ARTEFAKTUM ========= */

const ARTEFAKTUM_ITEMS = [
  { id:"owl",      name:"versteinerte Eule",              		emoji:"ğŸ¦‰" },   // Weisheit
  { id:"infty",    name:"versteinertes Unendlichkeitssymbol", 	emoji:"â™¾ï¸" }, // Unendlichkeit
  { id:"puzzle",   name:"versteinertes Puzzleteil",       		emoji:"ğŸ§©" },   // RÃ¤tsel
  { id:"shooting", name:"versteinerte Sternschnuppe",     		emoji:"ğŸŒ " },   // Hoffnung
  { id:"brain",    name:"versteinertes Gehirn",          		emoji:"ğŸ§ " },   // Erinnerung
  { id:"hourglass",name:"versteinerte Sanduhr",          		emoji:"â³" },   // Zeit
  { id:"book",     name:"versteinertes Buch",             		emoji:"ğŸ“–" },   // Wissen
  { id:"scale",    name:"versteinerte Waage",             		emoji:"âš–ï¸" },   // Harmonie
  { id:"eye",      name:"versteinertes Auge",             		emoji:"ğŸ‘ï¸" },   // Wahrheit
  { id:"dice",     name:"versteinerter WÃ¼rfel",          		emoji:"ğŸ²" },   // Schicksal
  { id:"bell",     name:"versteinerte Glocke",            		emoji:"ğŸ””" },   // Stille
  { id:"hands",    name:"versteinerter HÃ¤nde-Abdruck", 	  		emoji:"ğŸ¤" }, // Freundschaft
  { id:"clover",   name:"versteinertes Kleeblatt",        		emoji:"ğŸ€" },   // GlÃ¼ck
  { id:"drop",     name:"versteinerter Tropfen",          		emoji:"ğŸ’§" },   // Reinheit
  { id:"moon",     name:"versteinerter Halbmond",         		emoji:"ğŸŒ™" },   // Dunkelheit
  { id:"sun",      name:"versteinerte Sonne",             		emoji:"â˜€ï¸" },   // Licht
  { id:"yin",      name:"versteinertes Yin-Yang-Symbol",  		emoji:"â˜¯ï¸" },   // Balance
  { id:"pigeon",   name:"versteinerte Taube",             		emoji:"ğŸ•Šï¸" },   // Frieden
  { id:"ring",     name:"versteinerter Ring",             		emoji:"ğŸ’" },   // Treue
  { id:"crystal",  name:"versteinerte Kristallkugel",    		emoji:"ğŸ”®" }    // Zukunft
];

/* Cache (Items + Zeitstempel) â€“ 60 Sekunden gÃ¼ltig */
window._arteCache = window._arteCache || { items: [], ts: 0 };

function _pickUniqueRandom(arr, n){
  const a = arr.slice();
  for (let i=a.length-1;i>0;i--){
    const j=Math.floor(Math.random()*(i+1));
    [a[i],a[j]]=[a[j],a[i]];
  }
  return a.slice(0, Math.min(n, a.length));
}

// ==== Artefaktum Ã¶ffnen: IMMER KÃ¤ufer-Auswahl zeigen ====
window.startArtefaktum = function(){
  currentContext = "artefaktum";

  // Angebote ggf. neu ziehen (Cache ~60s)
  const now = Date.now();
  const elapsed = now - (window._arteCache.ts || 0);
  if (elapsed > 60*1000 || !Array.isArray(window._arteCache.items) || window._arteCache.items.length===0) {
    window._arteCache.items = _pickUniqueRandom(ARTEFAKTUM_ITEMS, 3);
    window._arteCache.ts = now;
  }

  // Seite rendern â€¦
  renderArtefaktum(window._arteCache.items);

  // â€¦ und JEDES MAL die KÃ¤ufer-Auswahl Ã¶ffnen
  openArteBuyerModal();
};

function renderArtefaktum(offers){
  const until = new Date(window._arteCache.ts + 60000).toLocaleTimeString();

  // kleiner Header mit aktuellem KÃ¤ufer + Button zum Wechseln
  const buyerLine = `
  `;

  const cards = (offers||[]).map((it,idx)=>{
    const bought = it._bought;
    return `
      <div class="arte-card">
        <div class="arte-emoji">${it.emoji}</div>
        <div class="arte-name">${it.name}</div>
        <div class="arte-price">50 â‚¬</div>
        <div class="button arte-buy ${bought ? "disabled" : ""}"
             onclick="${bought ? "" : `buyArtefakt(${idx})`}">
          ${bought ? "Gekauft" : "Kaufen"}
        </div>
      </div>
    `;
  }).join("");

  document.getElementById("app-section").innerHTML = `
    <div class="auction-header">
      <div class="auction-title">ğŸ—¿ Artefaktum</div>
      <div class="icon-btn" onclick="showHome()">âœ–</div>
    </div>
    <div class="arte-wrap">
      ${buyerLine}
      <div class="arte-col">${cards}</div>
      <div class="arte-foot">Angebote gÃ¼ltig bis ${until}.</div>
    </div>
  `;
  window._currentArte = offers;
}

window.buyArtefakt = function(idx){
  const item = (window._currentArte || [])[idx];
  if (!item || item._bought) return;

  // Sicherstellen, dass ein KÃ¤ufer gewÃ¤hlt ist
  if (!arteState.started || arteState.currentBuyerIdx === null) {
    openArteBuyerModal(); // erst KÃ¤ufer wÃ¤hlen lassen
    return;
  }

  item._bought = true;

  const buyer = arteState.currentBuyerName || "Spieler";

  // Log mit Emoji statt â€(50 â‚¬)â€œ
  if (typeof logArtefaktum === "function") {
    logArtefaktum(buyer, `${item.name} ${item.emoji}`);
  } else {
    addEventLog({ player: buyer, kind:"shop", text:`${item.name} ${item.emoji}` });
  }

  renderArtefaktum(window._currentArte);
};

// ==== Artefaktum-State (wer kauft?) ====
window.arteState = window.arteState || {
  started: false,
  currentBuyerIdx: null,
  currentBuyerName: null
};

/* === Artefaktum: KÃ¤ufer wÃ¤hlen (Lucky-Streak-Style) === */
function openArteBuyerModal() {
  closeArteBuyerModal();

  const overlay = document.createElement("div");
  overlay.id = "arteBuyerModal";
  overlay.className = "modal-backdrop";
  overlay.style.display = "flex";
  overlay.innerHTML = `
    <div class="modal">
      <h2>KÃ¤ufer wÃ¤hlen</h2>
      <div class="hint">Wer kauft was?</div>
      <div class="field">
        <label for="arteBuyerSel">KÃ¤ufer</label>
        <select id="arteBuyerSel">
          <option value="" disabled selected>Bitte wÃ¤hlen</option>
          ${playerNames.map((n,i)=>`<option value="${i}">${n}</option>`).join("")}
        </select>
      </div>
      <div id="arteBuyerErr" class="error"></div>

      <div class="modal-actions centered">
        <button class="btn equal" onclick="closeArteBuyerModalAndBack()">Abbrechen</button>
        <button class="btn primary equal" onclick="confirmArteBuyerFromModal()">Ãœbernehmen</button>
      </div>
    </div>
  `;
  document.body.appendChild(overlay);

  const sel = document.getElementById("arteBuyerSel");
  if (sel) sel.focus();
}

function closeArteBuyerModal(){ const m=document.getElementById("arteBuyerModal"); if(m) m.remove(); }

function closeArteBuyerModalAndBack(){
showHome()
}

function confirmArteBuyerFromModal(){
  const sel = document.getElementById("arteBuyerSel");
  const err = document.getElementById("arteBuyerErr");
  const idx = sel ? parseInt(sel.value,10) : NaN;

  if (Number.isNaN(idx)) {
    if (err) err.textContent = "Bitte zuerst einen KÃ¤ufer wÃ¤hlen.";
    return;
  }

  arteState.currentBuyerIdx  = idx;
  arteState.currentBuyerName = playerNames[idx] || "Spieler";
  arteState.started = true;

  closeArteBuyerModal();
  // UI aktualisieren, damit oben der KÃ¤ufer sichtbar ist
  renderArtefaktum(window._currentArte || []);
}

// global, falls du direkt binden willst:
window.openArteBuyerModal = openArteBuyerModal;
window.confirmArteBuyerFromModal = confirmArteBuyerFromModal;

  </script>
</body>
</html>
