<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
  <title>Lernen ‚Äì Whiteboard</title>
  <style>
    :root{
      --bg:#0b0b0d;
      --panel:#121218cc;
      --panel2:#171720;
      --text:#eaeaf2;
      --muted:#a8a8b8;
      --accent:#7c5cff;
      --border:#2a2a38;
      --shadow: 0 10px 30px rgba(0,0,0,.45);
      --radius:16px;
      --safe-bottom: env(safe-area-inset-bottom, 0px);
      --safe-top: env(safe-area-inset-top, 0px);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      background: radial-gradient(1200px 900px at 50% 0%, #151526, var(--bg));
      color:var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      overflow:hidden;
    }

    /* top bar */
    .topbar{
      position:fixed; left:0; right:0; top:0;
      padding: calc(10px + var(--safe-top)) 12px 10px;
      display:flex; align-items:center; gap:10px;
      background: linear-gradient(to bottom, rgba(0,0,0,.55), rgba(0,0,0,0));
      z-index:50;
      pointer-events:none;
    }
    .topbar > *{pointer-events:auto;}
    .btn{
      border:1px solid var(--border);
      background: rgba(18,18,24,.72);
      color:var(--text);
      padding:10px 12px;
      border-radius: 12px;
      cursor:pointer;
      box-shadow: var(--shadow);
      font-weight:700;
    }
    .btn:active{transform: translateY(1px);}
    .btn.secondary{font-weight:700; color:var(--muted)}
    .title{
      flex:1;
      min-width:0;
      display:flex; align-items:center; gap:10px;
      padding:10px 12px;
      border-radius: 12px;
      border:1px solid var(--border);
      background: rgba(18,18,24,.55);
      box-shadow: var(--shadow);
    }
    .title b{white-space:nowrap; overflow:hidden; text-overflow:ellipsis;}
    .title .pill{
      margin-left:auto;
      font-size:12px; color:var(--muted);
      padding:6px 10px;
      border:1px solid var(--border);
      border-radius:999px;
      background: rgba(0,0,0,.2);
      white-space:nowrap;
    }
    select{
      background: rgba(0,0,0,.25);
      color:var(--text);
      border:1px solid var(--border);
      border-radius: 10px;
      padding:8px 10px;
      outline:none;
    }

    /* canvas */
    #stage{
      position:absolute; inset:0;
      width:100vw; height:100vh;
      display:block;
    }

    /* bottom toolbar */
    .toolbar{
      position:fixed;
      left:10px; right:10px;
      bottom: calc(10px + var(--safe-bottom));
      z-index:60;
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      padding:10px 10px;
      border-radius: 18px;
      background: rgba(16,16,22,.82);
      border:1px solid var(--border);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    .toolgroup{display:flex; gap:8px; align-items:center;}
    .tool{
      width:44px; height:44px;
      display:grid; place-items:center;
      border-radius: 14px;
      border:1px solid transparent;
      background: rgba(255,255,255,.06);
      cursor:pointer;
      user-select:none;
      font-weight:900;
      color: var(--text);
    }
    .tool.active{
      border-color: rgba(124,92,255,.9);
      box-shadow: 0 0 0 3px rgba(124,92,255,.15) inset;
      background: rgba(124,92,255,.18);
    }
    .divider{width:1px; height:34px; background: var(--border); opacity:.9; margin:0 2px;}
    .sizes button{
      width:44px; height:44px;
      border-radius:14px;
      border:1px solid transparent;
      background: rgba(255,255,255,.06);
      color:var(--text);
      cursor:pointer;
      font-weight:900;
    }
    .sizes button.active{
      border-color: rgba(124,92,255,.9);
      background: rgba(124,92,255,.18);
    }

    /* color panel */
    .colorPanel{
      position:fixed;
      right:14px;
      bottom: calc(78px + var(--safe-bottom));
      width: 220px;
      background: rgba(16,16,22,.92);
      border:1px solid var(--border);
      border-radius: 18px;
      box-shadow: var(--shadow);
      padding: 10px;
      display:none;
      z-index:70;
      backdrop-filter: blur(10px);
    }
    .colorPanel.show{display:block;}
    .swatches{
      display:grid;
      grid-template-columns: repeat(5, 1fr);
      gap:10px;
      padding:8px 6px 10px;
    }
    .swatch{
      width:30px; height:30px;
      border-radius:999px;
      border:2px solid rgba(255,255,255,.10);
      cursor:pointer;
    }
    .swatch.selected{border-color: rgba(255,255,255,.8);}
    .row{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      padding: 6px;
      border-top: 1px solid rgba(255,255,255,.06);
    }
    .row label{color:var(--muted); font-size:12px; font-weight:700;}
    .row input[type="range"]{width: 120px;}
    .row input[type="color"]{
      width: 34px; height: 28px; border:none; background:transparent; padding:0;
    }

    /* inline editor */
    #textEditor{
      position:absolute;
      display:none;
      min-width: 80px;
      max-width: min(720px, 92vw);
      padding: 6px 8px;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.16);
      background: rgba(10,10,14,.9);
      color: var(--text);
      outline:none;
      resize:none;
      box-shadow: var(--shadow);
      z-index:80;
    }

    /* help toast */
    #toast{
      position:fixed; left:50%; transform:translateX(-50%);
      top: calc(64px + var(--safe-top));
      background: rgba(16,16,22,.86);
      border:1px solid var(--border);
      border-radius: 999px;
      padding: 8px 12px;
      color: var(--muted);
      font-size: 13px;
      box-shadow: var(--shadow);
      display:none;
      z-index:90;
    }
    #toast.show{display:block;}

    /* small screens */
    @media (max-width: 520px){
      .topbar{gap:8px; padding-left:10px; padding-right:10px;}
      .title{padding:10px;}
      .title .pill{display:none;}
      .toolbar{left:8px; right:8px; gap:8px; padding:10px;}
      .tool, .sizes button{width:42px; height:42px; border-radius: 13px;}
      .colorPanel{right:10px; width: 210px;}
    }
  </style>
</head>
<body>
  <div class="topbar">
    <button class="btn secondary" id="backBtn">‚Üê Zur√ºck</button>

    <div class="title">
      <b id="boardTitle">Whiteboard</b>
      <select id="boardSelect" title="Whiteboard ausw√§hlen"></select>
      <button class="btn" id="newBoardBtn" title="Neues Whiteboard">Ôºã</button>
      <span class="pill" id="statusPill">lokal</span>
    </div>

    <button class="btn" id="saveBtn">Speichern</button>
  </div>

  <canvas id="stage"></canvas>
  <textarea id="textEditor" rows="1"></textarea>

  <div class="colorPanel" id="colorPanel">
    <div class="swatches" id="swatches"></div>
    <div class="row">
      <label>Strich</label>
      <input id="strokeRange" type="range" min="1" max="18" value="3" />
    </div>
    <div class="row">
      <label>Farbe</label>
      <input id="colorPicker" type="color" value="#ff3bd4"/>
    </div>
  </div>

  <div class="toolbar" role="toolbar" aria-label="Whiteboard Werkzeuge">
    <div class="toolgroup">
      <div class="tool active" data-tool="select" title="Ausw√§hlen (V)">‚Üñ</div>
      <div class="tool" data-tool="hand" title="Freihand (P)">‚úé</div>
      <div class="tool" data-tool="arrow" title="Pfeil (A)">‚Üó</div>
      <div class="tool" data-tool="rect" title="Kasten (R)">‚ñ≠</div>
      <div class="tool" data-tool="text" title="Text (T)">T</div>
    </div>

    <div class="divider"></div>

    <div class="toolgroup sizes" aria-label="Textgr√∂√üe">
      <button data-size="16" title="S">S</button>
      <button data-size="22" class="active" title="M">M</button>
      <button data-size="30" title="L">L</button>
      <button data-size="40" title="XL">XL</button>
    </div>

    <div class="divider"></div>

    <div class="toolgroup">
      <div class="tool" id="colorBtn" title="Farbe/Strich">üé®</div>
      <div class="tool" id="groupBtn" title="Gruppieren">‚ñ¶</div>
      <div class="tool" id="ungroupBtn" title="Gruppe l√∂sen">‚ñ§</div>
      <div class="tool" id="deleteBtn" title="L√∂schen (Entf)">üóë</div>
    </div>
  </div>

  <div id="toast"></div>

<script>
(() => {
  // ---------- helpers ----------
  const $ = (s) => document.querySelector(s);
  const $$ = (s) => Array.from(document.querySelectorAll(s));
  const uid = () => "id_" + Math.random().toString(36).slice(2,10) + "_" + Date.now().toString(36);
  const clamp = (n,a,b)=>Math.max(a,Math.min(b,n));
  const nowISO = () => new Date().toISOString();

  function showToast(msg, ms=1400){
    const t = $("#toast");
    t.textContent = msg;
    t.classList.add("show");
    clearTimeout(showToast._tm);
    showToast._tm = setTimeout(()=>t.classList.remove("show"), ms);
  }

  // ---------- API (same style as Packliste) ----------
  async function apiGet(path){
    const r = await fetch(path, { credentials:"include" });
    const txt = await r.text();
    let data = null;
    try{ data = txt ? JSON.parse(txt) : null; } catch(e){ data = { raw: txt }; }
    if(!r.ok) throw Object.assign(new Error("HTTP "+r.status), {status:r.status, data});
    return data;
  }
  async function apiPut(path, body){
    const r = await fetch(path, {
      method:"PUT",
      headers:{ "Content-Type":"application/json" },
      body: JSON.stringify(body),
      credentials:"include"
    });
    const txt = await r.text();
    let data = null;
    try{ data = txt ? JSON.parse(txt) : null; } catch(e){ data = { raw: txt }; }
    if(!r.ok) throw Object.assign(new Error("HTTP "+r.status), {status:r.status, data});
    return data;
  }

  // ---------- state ----------
  // Stored server-side per user_id:
  // { version:1, boards:[{id,name,elements:[]}], activeBoardId, updatedAt }
  const DEFAULT_COLORS = [
    "#ffffff","#c9c9d6","#ff3bd4","#a855f7","#7c5cff",
    "#3b82f6","#22c55e","#facc15","#fb923c","#ef4444",
    "#14b8a6","#60a5fa","#f472b6","#10b981","#f97316"
  ];

  const state = {
    userId: localStorage.getItem("learn_userId") || "u_default",
    data: null,
    activeBoardId: null,
    tool: "select",
    color: localStorage.getItem("wb_color") || "#ff3bd4",
    stroke: Number(localStorage.getItem("wb_stroke") || 3),
    fontSize: Number(localStorage.getItem("wb_fontSize") || 22),
    isDirty: false
  };

  function ensureData(){
    if(!state.data || typeof state.data !== "object"){
      state.data = {
        version: 1,
        boards: [{ id: uid(), name: "Whiteboard 1", elements: [] }],
        activeBoardId: null,
        updatedAt: nowISO()
      };
    }
    if(!Array.isArray(state.data.boards) || state.data.boards.length === 0){
      state.data.boards = [{ id: uid(), name: "Whiteboard 1", elements: [] }];
    }
    if(!state.data.activeBoardId || !state.data.boards.find(b=>b.id===state.data.activeBoardId)){
      state.data.activeBoardId = state.data.boards[0].id;
    }
    state.activeBoardId = state.data.activeBoardId;
  }

  function currentBoard(){
    ensureData();
    return state.data.boards.find(b=>b.id===state.activeBoardId) || state.data.boards[0];
  }

  // ---------- canvas & rendering ----------
  const canvas = $("#stage");
  const ctx = canvas.getContext("2d");
  const DPR = () => Math.max(1, Math.min(2.5, window.devicePixelRatio || 1));

  function resize(){
    const dpr = DPR();
    canvas.width = Math.floor(window.innerWidth * dpr);
    canvas.height = Math.floor(window.innerHeight * dpr);
    canvas.style.width = window.innerWidth + "px";
    canvas.style.height = window.innerHeight + "px";
    ctx.setTransform(dpr,0,0,dpr,0,0);
    draw();
  }
  window.addEventListener("resize", resize);

  // selection
  let selectedIds = new Set();
  let hoverId = null;

  // interaction state
  let pointerDown = false;
  let startPt = null;
  let dragMode = null; // "move" | "boxSelect" | "draw"
  let tempEl = null;
  let moveOrigin = null;
  let movingSnapshot = null; // map id-> {x,y,...}
  let lastPt = null;

  // box selection rect
  let selectRect = null;

  function getPointerPos(e){
    const rect = canvas.getBoundingClientRect();
    return { x: e.clientX - rect.left, y: e.clientY - rect.top };
  }

  function markDirty(){
    state.isDirty = true;
    $("#statusPill").textContent = "ungespeichert";
    $("#statusPill").style.color = "#facc15";
  }
  function markSaved(){
    state.isDirty = false;
    $("#statusPill").textContent = "gespeichert";
    $("#statusPill").style.color = "var(--muted)";
  }

  // draw helpers
  function setStroke(color, w){
    ctx.strokeStyle = color;
    ctx.lineWidth = w;
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
  }
  function setFill(color){
    ctx.fillStyle = color;
  }

  function drawArrowHead(x1,y1,x2,y2, color, w){
    const ang = Math.atan2(y2-y1, x2-x1);
    const len = Math.max(10, w*3.2);
    ctx.save();
    ctx.translate(x2,y2);
    ctx.rotate(ang);
    ctx.beginPath();
    ctx.moveTo(0,0);
    ctx.lineTo(-len, -len*0.55);
    ctx.lineTo(-len, len*0.55);
    ctx.closePath();
    ctx.fillStyle = color;
    ctx.fill();
    ctx.restore();
  }

  function measureTextBox(text, fontSize){
    ctx.save();
    ctx.font = `${fontSize}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
    const lines = String(text||"").split("\n");
    let w = 0;
    for(const ln of lines) w = Math.max(w, ctx.measureText(ln).width);
    const lineH = Math.round(fontSize*1.25);
    const h = lines.length * lineH;
    ctx.restore();
    return {w, h, lineH};
  }

  function draw(){
    ensureData();
    const b = currentBoard();

    // background
    ctx.clearRect(0,0,window.innerWidth, window.innerHeight);
    // subtle dots grid
    const g = 26;
    ctx.save();
    ctx.globalAlpha = 0.12;
    ctx.fillStyle = "#ffffff";
    for(let y=0; y<window.innerHeight; y+=g){
      for(let x=0; x<window.innerWidth; x+=g){
        ctx.fillRect(x, y, 1, 1);
      }
    }
    ctx.restore();

    // elements
    for(const el of b.elements){
      const isSel = selectedIds.has(el.id);
      renderElement(el, isSel);
    }

    // temp element while drawing
    if(tempEl){
      renderElement(tempEl, false, true);
    }

    // box selection
    if(selectRect){
      ctx.save();
      ctx.strokeStyle = "rgba(124,92,255,.9)";
      ctx.lineWidth = 1.5;
      ctx.setLineDash([6,6]);
      ctx.strokeRect(selectRect.x, selectRect.y, selectRect.w, selectRect.h);
      ctx.fillStyle = "rgba(124,92,255,.10)";
      ctx.fillRect(selectRect.x, selectRect.y, selectRect.w, selectRect.h);
      ctx.restore();
    }
  }

  function renderElement(el, isSelected, isTemp=false){
    const color = el.color || "#fff";
    const stroke = el.stroke || 3;

    if(el.type === "rect"){
      ctx.save();
      const w = el.w || 10, h = el.h || 10;
      setStroke(color, stroke);
      ctx.globalAlpha = isTemp ? 0.85 : 1;
      ctx.beginPath();
      ctx.roundRect(el.x, el.y, w, h, 10);
      ctx.stroke();
      // selection outline
      if(isSelected){
        ctx.strokeStyle = "rgba(124,92,255,.95)";
        ctx.lineWidth = 2;
        ctx.setLineDash([6,4]);
        ctx.strokeRect(el.x-4, el.y-4, w+8, h+8);
      }
      ctx.restore();
      return;
    }

    if(el.type === "arrow"){
      ctx.save();
      setStroke(color, stroke);
      ctx.globalAlpha = isTemp ? 0.85 : 1;
      ctx.beginPath();
      ctx.moveTo(el.x1, el.y1);
      ctx.lineTo(el.x2, el.y2);
      ctx.stroke();
      drawArrowHead(el.x1, el.y1, el.x2, el.y2, color, stroke);
      if(isSelected){
        ctx.strokeStyle = "rgba(124,92,255,.95)";
        ctx.lineWidth = 2;
        ctx.setLineDash([6,4]);
        const bb = boundsOf(el);
        ctx.strokeRect(bb.x-4, bb.y-4, bb.w+8, bb.h+8);
      }
      ctx.restore();
      return;
    }

    if(el.type === "path"){
      ctx.save();
      setStroke(color, stroke);
      ctx.globalAlpha = isTemp ? 0.85 : 1;
      const pts = el.points || [];
      if(pts.length >= 2){
        ctx.beginPath();
        ctx.moveTo(pts[0].x, pts[0].y);
        for(let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x, pts[i].y);
        ctx.stroke();
      }
      if(isSelected){
        ctx.strokeStyle = "rgba(124,92,255,.95)";
        ctx.lineWidth = 2;
        ctx.setLineDash([6,4]);
        const bb = boundsOf(el);
        ctx.strokeRect(bb.x-4, bb.y-4, bb.w+8, bb.h+8);
      }
      ctx.restore();
      return;
    }

    if(el.type === "text"){
      ctx.save();
      const fs = el.fontSize || 22;
      ctx.font = `${fs}px system-ui, -apple-system, Segoe UI, Roboto, Arial`;
      ctx.textBaseline = "top";
      ctx.fillStyle = color;
      ctx.globalAlpha = isTemp ? 0.85 : 1;

      const lines = String(el.text||"").split("\n");
      const lineH = Math.round(fs*1.25);
      let y = el.y;
      for(const ln of lines){
        ctx.fillText(ln, el.x, y);
        y += lineH;
      }
      if(isSelected){
        ctx.strokeStyle = "rgba(124,92,255,.95)";
        ctx.lineWidth = 2;
        ctx.setLineDash([6,4]);
        const bb = boundsOf(el);
        ctx.strokeRect(bb.x-6, bb.y-6, bb.w+12, bb.h+12);
      }
      ctx.restore();
      return;
    }
  }

  // ---------- hit testing & bounds ----------
  function boundsOf(el){
    if(el.type === "rect"){
      return { x: el.x, y: el.y, w: el.w, h: el.h };
    }
    if(el.type === "arrow"){
      const x = Math.min(el.x1, el.x2);
      const y = Math.min(el.y1, el.y2);
      return { x, y, w: Math.abs(el.x2-el.x1), h: Math.abs(el.y2-el.y1) };
    }
    if(el.type === "path"){
      const pts = el.points || [];
      if(!pts.length) return {x:el.x||0,y:el.y||0,w:0,h:0};
      let minX=Infinity,minY=Infinity,maxX=-Infinity,maxY=-Infinity;
      for(const p of pts){
        minX=Math.min(minX,p.x); minY=Math.min(minY,p.y);
        maxX=Math.max(maxX,p.x); maxY=Math.max(maxY,p.y);
      }
      return { x:minX, y:minY, w:maxX-minX, h:maxY-minY };
    }
    if(el.type === "text"){
      const box = measureTextBox(el.text||"", el.fontSize||22);
      return { x: el.x, y: el.y, w: box.w, h: box.h };
    }
    return {x:0,y:0,w:0,h:0};
  }

  function ptInRect(px,py, r){
    return px>=r.x && py>=r.y && px<=r.x+r.w && py<=r.y+r.h;
  }

  function distToSegment(px,py, x1,y1,x2,y2){
    const A = px-x1, B = py-y1, C = x2-x1, D = y2-y1;
    const dot = A*C + B*D;
    const lenSq = C*C + D*D;
    let t = lenSq ? dot/lenSq : 0;
    t = clamp(t, 0, 1);
    const x = x1 + t*C;
    const y = y1 + t*D;
    const dx = px-x, dy = py-y;
    return Math.sqrt(dx*dx + dy*dy);
  }

  function hitTest(x,y){
    const els = currentBoard().elements;
    // topmost first
    for(let i=els.length-1;i>=0;i--){
      const el = els[i];
      if(el.type === "arrow"){
        const d = distToSegment(x,y, el.x1,el.y1, el.x2,el.y2);
        if(d <= (el.stroke||3) + 6) return el.id;
      } else if(el.type === "path"){
        const bb = boundsOf(el);
        if(ptInRect(x,y,{x:bb.x-8,y:bb.y-8,w:bb.w+16,h:bb.h+16})) return el.id;
      } else {
        const bb = boundsOf(el);
        if(ptInRect(x,y,{x:bb.x-6,y:bb.y-6,w:bb.w+12,h:bb.h+12})) return el.id;
      }
    }
    return null;
  }

  function elementsInRect(r){
    const out = [];
    for(const el of currentBoard().elements){
      const bb = boundsOf(el);
      const hit = !(bb.x > r.x+r.w || bb.x+bb.w < r.x || bb.y > r.y+r.h || bb.y+bb.h < r.y);
      if(hit) out.push(el.id);
    }
    return out;
  }

  function setTool(t){
    state.tool = t;
    $$(".tool[data-tool]").forEach(btn => btn.classList.toggle("active", btn.dataset.tool === t));
    const help = {
      select: "Ausw√§hlen: klicken/ziehen. Mehrfach: Strg + Klick. Box: ziehen auf leerer Fl√§che.",
      hand: "Freihand: gedr√ºckt halten und zeichnen.",
      arrow: "Pfeil: ziehen von Start zu Ende.",
      rect: "Kasten: ziehen.",
      text: "Text: klicken, schreiben, Enter f√ºr neue Zeile, Klick au√üerhalb = fertig."
    };
    showToast(help[t] || "", 1600);
  }

  function setFontSize(fs){
    state.fontSize = fs;
    localStorage.setItem("wb_fontSize", String(fs));
    $$(".sizes button").forEach(b => b.classList.toggle("active", Number(b.dataset.size) === fs));
    // apply to selected text elements
    if(selectedIds.size){
      const b = currentBoard();
      let changed = false;
      for(const id of selectedIds){
        const el = b.elements.find(e=>e.id===id);
        if(el && el.type==="text"){
          el.fontSize = fs;
          changed = true;
        }
      }
      if(changed){ markDirty(); draw(); }
    }
  }

  function setColor(c){
    state.color = c;
    localStorage.setItem("wb_color", c);
    $("#colorPicker").value = c;
    // update swatch selected state
    $$("#swatches .swatch").forEach(s=>s.classList.toggle("selected", s.dataset.color===c));
    // apply to selection
    if(selectedIds.size){
      const b = currentBoard();
      for(const id of selectedIds){
        const el = b.elements.find(e=>e.id===id);
        if(el){ el.color = c; }
      }
      markDirty(); draw();
    }
  }

  function setStroke(w){
    state.stroke = w;
    localStorage.setItem("wb_stroke", String(w));
    $("#strokeRange").value = String(w);
    // apply to selection (non-text too)
    if(selectedIds.size){
      const b = currentBoard();
      for(const id of selectedIds){
        const el = b.elements.find(e=>e.id===id);
        if(el && el.type!=="text"){ el.stroke = w; }
      }
      markDirty(); draw();
    }
  }

  // ---------- inline text editor ----------
  const editor = $("#textEditor");
  let editingId = null;

  function openEditorFor(el, atX, atY){
    editingId = el.id;
    editor.value = el.text || "";
    editor.style.left = (atX) + "px";
    editor.style.top  = (atY) + "px";
    editor.style.display = "block";
    editor.style.fontSize = (el.fontSize || state.fontSize) + "px";
    editor.style.color = el.color || state.color;
    editor.style.height = "auto";
    editor.style.width = "auto";
    editor.style.minHeight = (Math.round((el.fontSize||state.fontSize)*1.25) + 14) + "px";
    editor.focus();
    // size to content
    requestAnimationFrame(()=>autoSizeEditor());
  }

  function autoSizeEditor(){
    editor.style.height = "auto";
    editor.style.height = Math.min(380, editor.scrollHeight + 2) + "px";
    editor.style.width = "auto";
    const lines = editor.value.split("\n");
    const approx = Math.min(740, Math.max(140, Math.max(...lines.map(l=>l.length))* (state.fontSize*0.55) + 40));
    editor.style.width = approx + "px";
  }

  editor.addEventListener("input", () => {
    autoSizeEditor();
    const b = currentBoard();
    const el = b.elements.find(e=>e.id===editingId);
    if(el){
      el.text = editor.value;
      markDirty();
      draw();
    }
  });
  editor.addEventListener("keydown", (e) => {
    if(e.key === "Escape"){
      editor.blur();
    }
    // Ctrl+Enter closes
    if((e.ctrlKey || e.metaKey) && e.key === "Enter"){
      editor.blur();
    }
  });
  editor.addEventListener("blur", () => {
    editor.style.display = "none";
    editingId = null;
  });

  function startTextAt(x,y){
    const b = currentBoard();
    const el = {
      id: uid(),
      type: "text",
      x, y,
      text: "",
      fontSize: state.fontSize,
      color: state.color,
      groupId: null
    };
    b.elements.push(el);
    selectedIds = new Set([el.id]);
    markDirty();
    draw();
    openEditorFor(el, x, y);
  }

  function editExistingText(el){
    selectedIds = new Set([el.id]);
    draw();
    openEditorFor(el, el.x, el.y);
  }

  // ---------- board management ----------
  function syncBoardUI(){
    ensureData();
    const sel = $("#boardSelect");
    sel.innerHTML = "";
    for(const b of state.data.boards){
      const opt = document.createElement("option");
      opt.value = b.id;
      opt.textContent = b.name;
      sel.appendChild(opt);
    }
    sel.value = state.activeBoardId;
    $("#boardTitle").textContent = currentBoard().name;
  }

  $("#boardSelect").addEventListener("change", () => {
    state.activeBoardId = $("#boardSelect").value;
    state.data.activeBoardId = state.activeBoardId;
    $("#boardTitle").textContent = currentBoard().name;
    selectedIds.clear();
    draw();
    markDirty(); // active board changed (save desired)
  });

  $("#newBoardBtn").addEventListener("click", () => {
    ensureData();
    const name = prompt("Name f√ºr neues Whiteboard?", "Neues Whiteboard");
    if(name === null) return;
    const b = { id: uid(), name: (name||"Neues Whiteboard").trim() || "Neues Whiteboard", elements: [] };
    state.data.boards.unshift(b);
    state.activeBoardId = b.id;
    state.data.activeBoardId = b.id;
    syncBoardUI();
    selectedIds.clear();
    markDirty();
    draw();
  });

  // ---------- toolbar wiring ----------
  $$(".tool[data-tool]").forEach(btn => btn.addEventListener("click", () => setTool(btn.dataset.tool)));
  $$(".sizes button").forEach(btn => btn.addEventListener("click", () => setFontSize(Number(btn.dataset.size))));

  const colorPanel = $("#colorPanel");
  $("#colorBtn").addEventListener("click", () => {
    colorPanel.classList.toggle("show");
  });
  $("#strokeRange").addEventListener("input", (e)=> setStroke(Number(e.target.value)));
  $("#colorPicker").addEventListener("input", (e)=> setColor(e.target.value));

  // swatches
  const sw = $("#swatches");
  for(const c of DEFAULT_COLORS){
    const d = document.createElement("div");
    d.className = "swatch";
    d.style.background = c;
    d.dataset.color = c;
    d.addEventListener("click", ()=> setColor(c));
    sw.appendChild(d);
  }

  // group/ungroup/delete
  $("#deleteBtn").addEventListener("click", deleteSelection);
  $("#groupBtn").addEventListener("click", groupSelection);
  $("#ungroupBtn").addEventListener("click", ungroupSelection);

  function deleteSelection(){
    if(!selectedIds.size) return;
    const b = currentBoard();
    b.elements = b.elements.filter(e => !selectedIds.has(e.id));
    selectedIds.clear();
    markDirty();
    draw();
  }

  function groupSelection(){
    if(selectedIds.size < 2){
      showToast("W√§hle mindestens 2 Elemente aus.");
      return;
    }
    const gid = uid();
    const b = currentBoard();
    for(const id of selectedIds){
      const el = b.elements.find(e=>e.id===id);
      if(el) el.groupId = gid;
    }
    markDirty();
    draw();
    showToast("Gruppe erstellt.");
  }

  function ungroupSelection(){
    if(!selectedIds.size){
      showToast("Nichts ausgew√§hlt.");
      return;
    }
    const b = currentBoard();
    let changed = false;
    for(const id of selectedIds){
      const el = b.elements.find(e=>e.id===id);
      if(el && el.groupId){ el.groupId = null; changed = true; }
    }
    if(changed){
      markDirty(); draw(); showToast("Gruppe gel√∂st.");
    } else {
      showToast("Auswahl ist keine Gruppe.");
    }
  }

  // keyboard shortcuts
  window.addEventListener("keydown", (e) => {
    if(e.target === editor) return;

    if(e.key === "Delete" || e.key === "Backspace"){
      deleteSelection();
      return;
    }
    if(e.key === "Escape"){
      selectedIds.clear();
      draw();
      return;
    }
    const k = e.key.toLowerCase();
    if(k === "v"){ setTool("select"); }
    if(k === "p"){ setTool("hand"); }
    if(k === "a"){ setTool("arrow"); }
    if(k === "r"){ setTool("rect"); }
    if(k === "t"){ setTool("text"); }
    if((e.ctrlKey || e.metaKey) && k === "g"){ e.preventDefault(); groupSelection(); }
    if((e.ctrlKey || e.metaKey) && k === "s"){ e.preventDefault(); saveToCloud(); }
  });

  // ---------- pointer interactions ----------
  canvas.addEventListener("pointerdown", (e) => {
    // close color panel if click outside button/panel
    const cp = colorPanel;
    if(cp.classList.contains("show")){
      const within = cp.contains(e.target) || $("#colorBtn").contains(e.target);
      if(!within) cp.classList.remove("show");
    }

    canvas.setPointerCapture(e.pointerId);
    pointerDown = true;
    const pt = getPointerPos(e);
    startPt = pt;
    lastPt = pt;
    selectRect = null;
    dragMode = null;
    tempEl = null;

    const b = currentBoard();
    const hitId = hitTest(pt.x, pt.y);

    if(state.tool === "text"){
      if(hitId){
        const el = b.elements.find(x=>x.id===hitId);
        if(el && el.type === "text"){
          editExistingText(el);
          pointerDown = false;
          return;
        }
      }
      startTextAt(pt.x, pt.y);
      pointerDown = false;
      return;
    }

    if(state.tool === "select"){
      if(hitId){
        // selection logic
        if(e.ctrlKey || e.metaKey){
          if(selectedIds.has(hitId)) selectedIds.delete(hitId);
          else selectedIds.add(hitId);
        } else {
          if(!selectedIds.has(hitId)){
            selectedIds = new Set([hitId]);
          }
        }

        // if element has groupId, clicking selects group (unless ctrl)
        const el = b.elements.find(x=>x.id===hitId);
        if(el && el.groupId && !(e.ctrlKey || e.metaKey)){
          const gid = el.groupId;
          selectedIds = new Set(b.elements.filter(x=>x.groupId===gid).map(x=>x.id));
        }

        // start move
        dragMode = "move";
        moveOrigin = pt;
        movingSnapshot = new Map();
        for(const id of selectedIds){
          const el2 = b.elements.find(x=>x.id===id);
          if(el2) movingSnapshot.set(id, JSON.parse(JSON.stringify(el2)));
        }
        draw();
        return;
      } else {
        // start box select
        if(!(e.ctrlKey || e.metaKey)) selectedIds.clear();
        dragMode = "boxSelect";
        selectRect = { x: pt.x, y: pt.y, w: 0, h: 0 };
        draw();
        return;
      }
    }

    // drawing tools
    dragMode = "draw";
    if(state.tool === "arrow"){
      tempEl = { id: uid(), type:"arrow", x1: pt.x, y1: pt.y, x2: pt.x, y2: pt.y, color: state.color, stroke: state.stroke, groupId:null };
      draw();
      return;
    }
    if(state.tool === "rect"){
      tempEl = { id: uid(), type:"rect", x: pt.x, y: pt.y, w: 1, h: 1, color: state.color, stroke: state.stroke, groupId:null };
      draw();
      return;
    }
    if(state.tool === "hand"){
      tempEl = { id: uid(), type:"path", points:[{x:pt.x,y:pt.y}], color: state.color, stroke: state.stroke, groupId:null };
      draw();
      return;
    }
  });

  canvas.addEventListener("pointermove", (e) => {
    const pt = getPointerPos(e);

    if(!pointerDown){
      // hover cursor for select
      if(state.tool === "select"){
        const id = hitTest(pt.x, pt.y);
        canvas.style.cursor = id ? "grab" : "default";
      } else {
        canvas.style.cursor = (state.tool==="text") ? "text" : "crosshair";
      }
      return;
    }

    if(dragMode === "move"){
      const dx = pt.x - moveOrigin.x;
      const dy = pt.y - moveOrigin.y;
      const b = currentBoard();
      for(const id of selectedIds){
        const snap = movingSnapshot.get(id);
        const el = b.elements.find(x=>x.id===id);
        if(!snap || !el) continue;

        if(el.type === "arrow"){
          el.x1 = snap.x1 + dx; el.y1 = snap.y1 + dy;
          el.x2 = snap.x2 + dx; el.y2 = snap.y2 + dy;
        } else if(el.type === "path"){
          el.points = (snap.points||[]).map(p => ({x:p.x+dx, y:p.y+dy}));
        } else {
          el.x = snap.x + dx; el.y = snap.y + dy;
        }
      }
      markDirty();
      draw();
      return;
    }

    if(dragMode === "boxSelect"){
      const r = selectRect;
      r.w = pt.x - startPt.x;
      r.h = pt.y - startPt.y;
      // normalize for negative
      const norm = {
        x: Math.min(startPt.x, pt.x),
        y: Math.min(startPt.y, pt.y),
        w: Math.abs(pt.x-startPt.x),
        h: Math.abs(pt.y-startPt.y)
      };
      selectRect.x = norm.x; selectRect.y = norm.y; selectRect.w = norm.w; selectRect.h = norm.h;

      const hits = elementsInRect(selectRect);
      if(e.ctrlKey || e.metaKey){
        for(const id of hits) selectedIds.add(id);
      } else {
        selectedIds = new Set(hits);
      }
      draw();
      return;
    }

    if(dragMode === "draw" && tempEl){
      if(tempEl.type === "arrow"){
        tempEl.x2 = pt.x; tempEl.y2 = pt.y;
      } else if(tempEl.type === "rect"){
        tempEl.w = pt.x - startPt.x;
        tempEl.h = pt.y - startPt.y;
      } else if(tempEl.type === "path"){
        // add point if far enough
        const dx = pt.x - lastPt.x, dy = pt.y - lastPt.y;
        if(Math.hypot(dx,dy) > 2.2){
          tempEl.points.push({x:pt.x,y:pt.y});
          lastPt = pt;
        }
      }
      draw();
    }
  });

  canvas.addEventListener("pointerup", (e) => {
    pointerDown = false;

    if(dragMode === "draw" && tempEl){
      const b = currentBoard();
      // normalize rect
      if(tempEl.type === "rect"){
        let {x,y,w,h} = tempEl;
        if(w < 0){ x = x+w; w = Math.abs(w); }
        if(h < 0){ y = y+h; h = Math.abs(h); }
        tempEl.x = x; tempEl.y = y; tempEl.w = Math.max(6,w); tempEl.h = Math.max(6,h);
      }
      // minimal sizes
      if(tempEl.type === "arrow"){
        const bb = boundsOf(tempEl);
        if(bb.w + bb.h < 8){ tempEl = null; draw(); return; }
      }
      if(tempEl.type === "path"){
        if((tempEl.points||[]).length < 2){ tempEl = null; draw(); return; }
      }

      b.elements.push(tempEl);
      selectedIds = new Set([tempEl.id]);
      tempEl = null;
      markDirty();
      draw();
    }

    dragMode = null;
    movingSnapshot = null;
    moveOrigin = null;
    selectRect = null;
    draw();
  });

  // ---------- saving / loading ----------
  async function loadFromCloud(){
    try{
      const res = await apiGet(`/api/learn/data?profileId=${encodeURIComponent(state.userId)}`);
      // worker returns { ok:true, data: {...} } or raw
      const data = res?.data || res?.json || res;
      state.data = (data && typeof data === "object") ? data : null;
      ensureData();
      syncBoardUI();
      draw();
      $("#statusPill").textContent = "geladen";
      $("#statusPill").style.color = "var(--muted)";
      showToast("Daten geladen.");
      return true;
    }catch(err){
      // fallback local draft
      const local = localStorage.getItem("learn_whiteboard_local");
      if(local){
        try{
          state.data = JSON.parse(local);
        }catch(e){}
      }
      ensureData();
      syncBoardUI();
      draw();
      $("#statusPill").textContent = "lokal";
      $("#statusPill").style.color = "var(--muted)";
      showToast("Offline/Cloud-Fehler ‚Äì lokaler Stand.");
      return false;
    }
  }

  async function saveToCloud(){
    ensureData();
    state.data.updatedAt = nowISO();
    // always keep local
    localStorage.setItem("learn_whiteboard_local", JSON.stringify(state.data));

    try{
      const body = Object.assign({}, state.data, { profileId: state.userId });
      const res = await apiPut(`/api/learn/data?profileId=${encodeURIComponent(state.userId)}`, body);
      markSaved();
      showToast("Gespeichert.");
      return true;
    }catch(err){
      console.error(err);
      const msg = err?.data?.error || err?.message || "Fehler";
      showToast("Speichern fehlgeschlagen: " + msg, 2200);
      $("#statusPill").textContent = "lokal";
      $("#statusPill").style.color = "#f97316";
      return false;
    }
  }

  $("#saveBtn").addEventListener("click", saveToCloud);

  // back button: go to /lernen
  $("#backBtn").addEventListener("click", () => {
    if(state.isDirty){
      const ok = confirm("Du hast ungespeicherte √Ñnderungen. Trotzdem zur√ºck?");
      if(!ok) return;
    }
    location.href = "/lernen";
  });

  // auto-save periodically (safe)
  setInterval(() => {
    if(state.isDirty){
      localStorage.setItem("learn_whiteboard_local", JSON.stringify(state.data));
    }
  }, 2500);

  // before unload warning
  window.addEventListener("beforeunload", (e) => {
    if(state.isDirty){
      e.preventDefault();
      e.returnValue = "";
    }
  });

  // ---------- init ----------
  // load learn_userId (selected user) from localStorage used by /lernen page
  const storedUser = localStorage.getItem("learn_userId");
  if(storedUser) state.userId = storedUser;

  // initial UI states
  // size buttons
  setFontSize(state.fontSize);
  // stroke + color
  $("#strokeRange").value = String(state.stroke);
  setColor(state.color);
  setStroke(state.stroke);
  // tool
  setTool("select");

  resize();
  loadFromCloud();

})();
</script>
</body>
</html>
